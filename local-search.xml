<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python面向对象</title>
    <link href="/2021/01/10/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/01/10/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>#1. 引言<br>引用在各种编程语言中都有涉及，如java中值传递和引用传递。python的对象引用也是学习python过程中需要特别关注的一个知识点，特别是对函数参数传递，可能会引起不必要的BUG。本文将对引用做一个梳理，内容涉及如下：</p><p>变量和赋值</p><p>可变对象和不可变对象</p><p>函数参数的引用</p><p>浅拷贝和深拷贝</p><p>垃圾回收</p><p>弱引用</p><p>#2. python引用<br>2.1 变量和赋值<br>任何一个python对象都有标签，类型和值三个属性。标签在对象创建后直到内存回收就保持不变，可以理解为内存地址。</p><p>python在给变量赋值，会把赋值的对象的内存地址赋值给变量。也就是说python的变量是地址引用式的变量。引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的值本身。</p><p>可以通过is或者比较id()的判断是否引用的是同一个内存地址的变量。</p><p>== 是比较两个对象的内容是否相等，即两个对象的值是否相等</p><p>is同时检查对象的值和内存地址。可以通过is判断是否是同一个对象</p><p>id() 列出变量的内存地址的编号</p><h1 id="这个例子a-和-b-两个变量共同指向了同一个内存空间"><a href="#这个例子a-和-b-两个变量共同指向了同一个内存空间" class="headerlink" title="这个例子a 和 b 两个变量共同指向了同一个内存空间"></a>这个例子a 和 b 两个变量共同指向了同一个内存空间</h1><p>a = [1, 2, 3]<br>c = [1, 2, 3]<br>print(a is c) # False<br>print(a == c) # True<br>b = a<br>a.append(5)<br>print(a is b) # True<br>初始化赋值：变量的每一次初始化，都开辟了一个新的空间，将新内容的地址赋值给变量</p><p>变量赋值：引用地址的传递</p><p>2.2 可变对象和不可变对象<br>python中的一切都是对象。python对象又分为可变对象和不可变对象。二者的区别在于对象的值在不改变内存地址的情况下是否可修改。</p><p>可变对象包括字典dict、列表list、集合set、手动声明的类对象等</p><p>不可变对象包括数字int float、字符str、None、元组tuple等</p><p>下面举几个典型的例子：</p><p>list 可变对象，内容变更地址不变</p><p>a = [1, 2, 3]<br>print(id(a))<br>a.append(5)<br>print(id(a))<br>不可变对象（常用的共享地址或缓存）</p><h1 id="较小整数频繁被使用，python采用共享地址方式来管理"><a href="#较小整数频繁被使用，python采用共享地址方式来管理" class="headerlink" title="较小整数频繁被使用，python采用共享地址方式来管理"></a>较小整数频繁被使用，python采用共享地址方式来管理</h1><p>a = 1<br>b = 1<br>print(a is b) # True</p><h1 id="对于单词类str，python采用共享缓存的方式来共享地址"><a href="#对于单词类str，python采用共享缓存的方式来共享地址" class="headerlink" title="对于单词类str，python采用共享缓存的方式来共享地址"></a>对于单词类str，python采用共享缓存的方式来共享地址</h1><p>a = ‘hello’<br>b = ‘hello’<br>print(a is b) # True<br>不可变对象（不共享地址）</p><p>a = (1999, 1)<br>b = (1999, 1)<br>print(a is b) # False</p><p>a = ‘hello everyone’<br>b = ‘hello everyone’<br>print(a is b) # False<br>元组的相对不可变型</p><h1 id="元组的里元素是可变，改变可变的元素，不改变元组的引用"><a href="#元组的里元素是可变，改变可变的元素，不改变元组的引用" class="headerlink" title="元组的里元素是可变，改变可变的元素，不改变元组的引用"></a>元组的里元素是可变，改变可变的元素，不改变元组的引用</h1><p>a = (1999, [1, 2])<br>ida = id(a)<br>a[-1].append(3)<br>idb = id(a)</p><p>print(ida == idb) # True<br>这里之所以要提到变量可变和不可变的特性，其实主要是想说明变量的引用其实和变量的可变和不可变没有直接的关系。变量可变和不可变主要着眼点是变量可不可以修改，注意这个修改不是通过赋值的操作来完成。</p><p>a = [1, 2, 3]<br>print(id(a))<br>a = a + [5]<br>print(id(a))</p><h1 id="前后两个变量a，-已经不是同一个地址了"><a href="#前后两个变量a，-已经不是同一个地址了" class="headerlink" title="前后两个变量a， 已经不是同一个地址了"></a>前后两个变量a， 已经不是同一个地址了</h1><p>2.3 函数参数的引用<br>python中函数的传参方式是共享传参，即函数的形参是实参中各个引用的副本（别名）。函数会修改是可变对象的实参（表示的同一个对象）；而不会改变实参的引用。</p><p>def func(d):<br>    d[‘a’] = 10<br>    d[‘b’] = 20    # 改变了外部实参的值<br>    d = {‘a’: 0, ‘b’: 1}  # 赋值操作， 局部d贴向了新的标识<br>    print(d) # {‘a’: 0, ‘b’: 1}</p><p>d = {}<br>func(d)<br>print(d) # {‘a’: 10, ‘b’: 20}<br>建议不要写上面例子的代码，局部变量和全局变量的名称一样，尽量编码，否则很容易出bug而不自知。</p><p>函数的参数的默认值避免使用可变参数，尽量用None来代替。原因是函数的默认值是作为函数对象的属性，如果默认值是可变对象，而且修改了它，那边后续的函数对象都会受到影响。</p><p>class bus():<br>    def <strong>init</strong>(self, param=[]):<br>        self.param = param</p><pre><code>def test(self, elem):    self.param.append(elem)</code></pre><p>b = bus([2, 3])<br>b.param # [2, 3]</p><p>c = bus()<br>c.test(3)<br>c.param # [3]</p><p>d = bus()<br>d.param # [3]  # c 中修改了默认值的引用的内容<br>2.4 浅拷贝和深拷贝<br>对于可变对象，我们要时刻注意它的可变性，特别是对赋值或者拷贝后的变量做内容修改操作的时候，需要考虑下是否会影响到原始变量的值，如果程序有bug，可以往这方面想一想。这里讲一下拷贝即建立副本。拷贝有两种：</p><p>浅拷贝：只复制顶层的对象，对于有嵌套数据结构，内部的元素还是原有对象的引用，这时候需要特别注意</p><p>深拷贝：复制了所有对象，递归式的复制所有对象。复制后的对象和原来的对象是完全不同的对象。对于不可变对象来说，浅拷贝和深拷贝都是一样的地址。但是对于嵌套了可变对象元素的情况，就有所不同</p><p>test_a = (1, 2, 3)<br>test_b = copy.copy(test_a)<br>test_c = copy.deepcopy(test_a)<br>print(test_a is test_b) # True<br>print(test_a is test_c) # True</p><p>test_a[2].append(5) # 改变不可变对象中可变元素的内容<br>print(test_a is test_b) # True<br>print(test_a is test_c) # False<br>print(test_c) # (1, 2, [3, 4])<br>对于可变对象，只要拷贝，就创建了一个新的顶层对象。如果是浅拷贝，内部嵌套的可变对象只是拷贝引用，这样就会相互影响。深拷贝就不会有这种问题。</p><p>l1 = [3, [66, 55, 44], (2, 3, 4)]<br>l2 = list(l1) # l2是l1的浅拷贝</p><h1 id="顶层改变不会相互影响，因为是两个不同对象"><a href="#顶层改变不会相互影响，因为是两个不同对象" class="headerlink" title="顶层改变不会相互影响，因为是两个不同对象"></a>顶层改变不会相互影响，因为是两个不同对象</h1><p>l1.append(50)<br>print(l1) # 3, [66, 55, 44], (2, 3, 4), 50]<br>print(l2) # [3, [66, 55, 44], (2, 3, 4)]</p><h1 id="嵌套可变元素，浅拷贝共享一个地址"><a href="#嵌套可变元素，浅拷贝共享一个地址" class="headerlink" title="嵌套可变元素，浅拷贝共享一个地址"></a>嵌套可变元素，浅拷贝共享一个地址</h1><p>l1[1].append(100)<br>print(l1) # [3, [66, 55, 44, 100], (2, 3, 4), 50]<br>print(l2) # [3, [66, 55, 44, 100], (2, 3, 4)]</p><h1 id="嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响"><a href="#嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响" class="headerlink" title="嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响"></a>嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响</h1><p>l1[2] += (2,3)<br>print(l1) # [3, [66, 55, 44, 100], (2, 3, 4, 2, 3), 50]<br>print(l2) #[3, [66, 55, 44, 100], (2, 3, 4)]<br>2.5 垃圾回收<br>python对于垃圾回收，采取的是引用计数为主，标记-清除+分代回收为辅的回收策略。</p><p>引用计数：python可以给所有的对象（内存中的区域）维护一个引用计数的属性，在一个引用被创建或复制的时候，让python,把相关对象的引用计数+1；相反当引用被销毁的时候就把相关对象的引用计数-1。当对象的引用计数减到0时，认为整个python中不会再有变量引用这个对象，所以就可以把这个对象所占据的内存空间释放出来了。可以通过sys.getrefcount()来查看对象的引用</p><p>分代回收: 分代回收主要是为了提高垃圾回收的效率。对象的创建和消费的频率不一样。由于python在垃圾回收前需要检测是否是垃圾，是否回收，然后再回收。当对象很多的时候，垃圾检测的耗时变得很大，效率很低。python采用的对对象进行分代，按不同的代进行不同的频率的检测。代等级的规则根据对象的生命时间来判断，比如一个对象连续几次检测都是可达的，这个对象代的等级高，降低检测频率。python中默认把所有对象分成三代。第0代包含了最新的对象，第2代则是最早的一些对象</p><p>循环引用：一个对象直接或者间接引用自己本身，引用链形成一个环。这样改对象的引用计数永远不可能为0。所有能够引用其他对象的对象都被称为容器(container). 循环引用只能发生容器之间发生. Python的垃圾回收机制利用了这个特点来寻找需要被释放的对象。</p><p>import sys<br>a = [1, 2]<br>b = a</p><p>print(sys.getrefcount(a)) # 3 命令本身也是一次引用<br>del b<br>print(sys.getrefcount(a)) # 2<br>#3. 弱引用<br>弱引用在许多高级语言中都存在。如前所述，当对象的引用计数为0时，垃圾回收机制就会销毁对象。但有时候需要引用对象，但不希望增加引用计数。这样有什么好处？</p><p>应用在缓存中，只存在一定的时间存在。当它引用的对象存在时，则对象可用，当对象不存在时，就返回None</p><p>不增加引用计数，在循环引用使用，就降低内存泄露的可能性</p><p>这就是弱引用weak reference，不会增加对象的引用数量。引用的目标对象称为 所指对象 （referent）。</p><p>import weakref<br>a_set = {0,1}<br>wref = weakref.ref(a_set) # 建立弱引用<br>print(wref()) # {0,1}<br>a_set = {2, 3, 4} # 原来的a_set 引用计数为0，垃圾回收<br>print(wref()) # None # 所值对象被垃圾回收， 弱引用也消失为None<br>弱引用一般使用时weakref集合, weakref.WeakValueDictionary, weakref.WeakKeyDictionary两者的区别是一个是值进行弱引用，一个是可以进行弱引用；另外还有weakref.WeakSet</p><p>#4. 总结<br>本文描述python中引用相关的几个方面，希望对大家有帮助。总结如下：</p><p>对象赋值就完成引用，变量是地址引用式的变量</p><p>要时刻注意，所以引用可变对象对象的改变，是否导致共同引用的变量值得变化</p><p>函数会修改是可变对象的实参<br>浅拷贝只是copy顶层，如果存在内部嵌套可变对象，要注意，copy的还是引用</p><p>对象的引用计数为0时，就开始垃圾回收</p><p>弱引用为增加引用计数，与被所指对象共存亡，而不影响循环引用</p><p>完结撒花累死我了</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现在线聊天功能</title>
    <link href="/2021/01/10/Java%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/01/10/Java%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>##关键代码<br>创建Client.java</p><p>import java.io.IOException;<br>import java.net.Socket;<br>import java.net.UnknownHostException;</p><p>/**</p><ul><li><p>@author Lete</p></li><li><p>@乐特的程序永无BUG</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class Client {<br>  public static void main(String[] args) {</p><pre><code>  try &#123;      // 创建8888端口      Socket s = new Socket(&quot;127.0.0.1&quot;, 8888);      // 启动发送消息线程      new SendThread(s).start();      // 启动接受消息线程      new RecieveThread(s).start();  &#125; catch (UnknownHostException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }<br>}</p></li></ul><p>#创建Server.java</p><p>import java.io.IOException;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p><p>/**</p><ul><li><p>@author Lete</p></li><li><p>@乐特的程序永无BUG</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class Server {<br>  public static void main(String[] args) {</p><pre><code>  try &#123;      // 监听8888端口      ServerSocket ss = new ServerSocket(8888);      System.out.println(&quot;监听在端口号:8888&quot;);      Socket s = ss.accept();      //启动发送消息线程      new SendThread(s).start();      //启动接受消息线程      new RecieveThread(s).start();  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }<br>}</p></li></ul><p>#创建RecieveThread.java</p><p>import java.io.*;<br>import java.net.Socket;</p><p>/**</p><ul><li><p>@author Lete</p></li><li><p>@乐特的程序永无BUG</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class RecieveThread extends Thread {</p><p>  private Socket s;</p><p>  public RecieveThread(Socket s) {</p><pre><code>  this.s = s;</code></pre><p>  }</p><p>  public void run() {</p><pre><code>  try &#123;      // 接收对方输入的内容      InputStream is = s.getInputStream();      DataInputStream dis = new DataInputStream(is);      while (true) &#123;          String msg = dis.readUTF();          System.out.println(msg);      &#125;  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }</p></li></ul><p>}<br>#创建SendThread.java</p><p>import java.io.*;<br>import java.net.Socket;<br>import java.util.Scanner;</p><p>/**</p><ul><li><p>@author Lete</p></li><li><p>@乐特的程序永无BUG</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class SendThread extends Thread {</p><p>  private Socket s;</p><p>  public SendThread(Socket s) {</p><pre><code>  this.s = s;</code></pre><p>  }</p><p>  public void run() {</p><pre><code>  try &#123;      // 获取输入的内容      OutputStream os = s.getOutputStream();      DataOutputStream dos = new DataOutputStream(os);      while (true) &#123;          Scanner sc = new Scanner(System.in);          String str = sc.next();          dos.writeUTF(str);      &#125;  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }</p></li></ul><p>}<br>okok这样就可以起飞啦</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3悬停效果</title>
    <link href="/2021/01/10/CSS3%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C/"/>
    <url>/2021/01/10/CSS3%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>font awesome 图标使用方法参考网站：</p><p><a href="https://fontawesome.dashgame.com/">https://fontawesome.dashgame.com/</a></p><p>#HTML<br><!DOCTYPE html></p><html>    <head>        <meta charset="utf-8">        <title>鼠标悬停效果:微信公众号AlbertYang</title>        <link rel="stylesheet" type="text/css" href="cursor.css" />        <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">    </head>    <body>        <ul>            <li><a href="#"><i class="fa fa-address-card"></i></a></li>            <li><a href="#"><i class="fa fa-address-card"></i></a></li>            <li><a href="#"><i class="fa fa-drivers-license-o"></i></a></li>            <li><a href="#"><i class="fa fa-envelope-open-o"></i></a></li>            <li><a href="#"><i class="fa fa-ravelry"></i></a></li>            <li><a href="#"><i class="fa fa-snowflake-o"></i></a></li>            <div class="cursor"></div>        </ul>        <script>            const cursor = document.querySelector(".cursor");            document.addEventListener('mousemove', (e) => {                cursor.style.left = e.pageX + 'px';                cursor.style.top = e.pageY + 'px';            })        </script>    </body></html><p>#cursor.css</p><ul><li>{<br>  margin: 0;<br>  padding: 0;<br>}</li></ul><p>body {<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>    height: 100vh;<br>    background-color: azure;<br>}</p><p>ul {<br>    position: relative;<br>    display: flex;<br>}</p><p>ul li {<br>    list-style: none;<br>    margin: 0 30px;<br>}</p><p>ul li a {<br>    position: relative;<br>    display: inline-block;<br>    font-size: 2em;<br>    color: gray;<br>    transition: all 0.3s;<br>}</p><p>ul li:hover a {<br>    color: deepskyblue;<br>    transform: scale(1.5);<br>}</p><p>.cursor {<br>    position: fixed;<br>    width: 0;<br>    height: 0;<br>    border: 15px solid gray;<br>    border-radius: 50%;<br>    transform: translate(-50%, -50%);<br>    pointer-events: none;<br>    transition: width 0.3s, height 0.3s;<br>}</p><p>ul li:hover~.cursor {<br>    width: 80px;<br>    height: 80px;<br>    border: 3px solid deepskyblue;<br>}</p><p>由于本人能力和知识有限，如果有写的不对的地方，还请各位大佬批评指正</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5分钟用CSS实现毛玻璃效果</title>
    <link href="/2021/01/10/5%E5%88%86%E9%92%9F%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/"/>
    <url>/2021/01/10/5%E5%88%86%E9%92%9F%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>##实现思路</p><ol><li><p>定义三个box，布局方式都为absolute。</p></li><li><p>第一个box 放背景图片，第二个box实现模糊过滤，第三个box放要显示的图片。</p></li><li><p>通过监听鼠标移动，改变css 自定义属性值，通过calc()， var()函数获取计算自定义属性值实现移动效果。<br>#参考代码HTML</p><!DOCTYPE html><html><head> <meta charset="utf-8"> <title>毛玻璃效果:微信公众号AlbertYang</title></head><link rel="stylesheet" type="text/css" href="style.css" /><body> <section>   <div class="imgBx">     <h1>毛玻璃效果</h1>   </div>   <div class="box box1"></div>   <div class="box box2">     <h1>毛玻璃效果</h1>   </div> </section> <script>   const position = document.documentElement;   position.addEventListener('mousemove', e => {     position.style.setProperty('--x', e.pageX + 'px');     position.style.setProperty('--y', e.pageY + 'px');   })</script></body></html></li></ol><p>#CSS</p><ul><li>{<br>margin: 0;<br>padding: 0;<br>box-sizing: border-box;<br>}<br>section {<br>position: absolute;<br>top: 0;<br>left: 0;<br>width: 100%;<br>height: 100%;<br>overflow: hidden;<br>}<br>section .imgBx {<br>position: absolute;<br>top: 0;<br>left: 0;<br>width: 100%;<br>height: 100%;<br>display: flex;<br>justify-content: center;<br>align-items: center;<br>background: url(wbb.jpg);<br>background-size: 100%;<br>background-position: calc(var(–x)/5) calc(var(–y)/5);<br>}<br>section .box {<br>position: absolute;<br>top: 0;<br>left: 0;<br>width: 100%;<br>height: 100%;<br>display: flex;<br>justify-content: center;<br>align-items: center;<br>backdrop-filter: blur(10px);<br>}<br>section .box.box2 {<br>background: url(wbb.jpg);<br>background-size: 100%;<br>clip-path: circle(260px at center);<br>background-position: calc(var(–x)/5) calc(var(–y)/5);<br>}<br>section .box.box2::before {<br>content: “”;<br>position: absolute;<br>top: 50%;<br>left: 50%;<br>transform: translate(-50%, -50%);<br>width: 520px;<br>height: 520px;<br>box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);<br>z-index: 10;<br>border-radius: 50%;<br>}<br>section h1 {<br>position: absolute;<br>margin-top: 30%;<br>color: #fff;<br>font-size: 88px;<br>transform: translate(calc(var(–x)/5), calc(var(–y)/5));<br>}<br>由于本人能力和知识有限，如果有写的不对的地方，还请各位大佬批评指正</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript实现 - LeetCode刷题</title>
    <link href="/2021/01/10/JavaScript%E5%AE%9E%E7%8E%B0-LeetCode%E5%88%B7%E9%A2%98/"/>
    <url>/2021/01/10/JavaScript%E5%AE%9E%E7%8E%B0-LeetCode%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#解题步骤<br>1.广度优先遍历二叉树<br>2.遍历过程中，记录每个节点的层级，并将其添加到不同的数组中<br>#代码<br>/**</p><ul><li>Definition for a binary tree node.</li><li>function TreeNode(val) {</li><li><pre><code>this.val = val;</code></pre></li><li><pre><code>this.left = this.right = null;</code></pre></li><li>}</li><li>/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number[][]}</li><li>/<br>var levelOrder = function(root) {<br>if (!root) return [];<br>const q = [root];<br>const res = [];<br>while (q.length) {<br>  let len = q.length;<br>  res.push([]);<br>  // 下面这个while循环，每结束一次，里面就只是同一级的值，非常巧妙<br>  while (len–) {<pre><code>const n = q.shift();res[res.length - 1].push(n.val);if (n.left) q.push(n.left);if (n.right) q.push(n.right);</code></pre>  }<br>}<br>return res;<br>};</li></ul><p>哈哈，是不是很简单，你学会了吗</p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_多态</title>
    <link href="/2021/01/10/python-%E5%A4%9A%E6%80%81/"/>
    <url>/2021/01/10/python-%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1、什么多态：同一事物有多种形态"><a href="#1、什么多态：同一事物有多种形态" class="headerlink" title="1、什么多态：同一事物有多种形态"></a>1、什么多态：同一事物有多种形态</h1><h1 id="class-Animal"><a href="#class-Animal" class="headerlink" title="class Animal:"></a>class Animal:</h1><h1 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="class-People-Animal"><a href="#class-People-Animal" class="headerlink" title="class People(Animal):"></a>class People(Animal):</h1><h1 id="pass-1"><a href="#pass-1" class="headerlink" title="pass"></a>pass</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="class-Dog-Animal"><a href="#class-Dog-Animal" class="headerlink" title="class Dog(Animal):"></a>class Dog(Animal):</h1><h1 id="pass-2"><a href="#pass-2" class="headerlink" title="pass"></a>pass</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="class-Pig-Animal"><a href="#class-Pig-Animal" class="headerlink" title="class Pig(Animal):"></a>class Pig(Animal):</h1><h1 id="pass-3"><a href="#pass-3" class="headerlink" title="pass"></a>pass</h1><h1 id="2、为何要有多态-》多态会带来什么样的特性，多态性"><a href="#2、为何要有多态-》多态会带来什么样的特性，多态性" class="headerlink" title="2、为何要有多态=》多态会带来什么样的特性，多态性"></a>2、为何要有多态=》多态会带来什么样的特性，多态性</h1><h1 id="多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象"><a href="#多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象" class="headerlink" title="多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象"></a>多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象</h1><p>class Animal: # 统一所有子类的方法<br>    def say(self):<br>        print(‘动物基本的发声频率。。。’,end=’ ‘)</p><p>class People(Animal):<br>    def say(self):<br>        super().say()<br>        print(‘嘤嘤嘤嘤嘤嘤嘤’)</p><p>class Dog(Animal):<br>    def say(self):<br>        super().say()<br>        print(‘汪汪汪’)</p><p>class Pig(Animal):<br>    def say(self):<br>        super().say()<br>        print(‘哼哼哼’)</p><p>obj1=People()</p><h1 id="print-People-mro"><a href="#print-People-mro" class="headerlink" title="print(People.mro())"></a>print(People.mro())</h1><h1 id="obj2-Dog"><a href="#obj2-Dog" class="headerlink" title="obj2=Dog()"></a>obj2=Dog()</h1><h1 id="obj3-Pig"><a href="#obj3-Pig" class="headerlink" title="obj3=Pig()"></a>obj3=Pig()</h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="obj1-say"><a href="#obj1-say" class="headerlink" title="obj1.say()"></a>obj1.say()</h1><h1 id="obj2-say"><a href="#obj2-say" class="headerlink" title="obj2.say()"></a>obj2.say()</h1><h1 id="obj3-say"><a href="#obj3-say" class="headerlink" title="obj3.say()"></a>obj3.say()</h1><h1 id="定义统一的接口，接收传入的动物对象"><a href="#定义统一的接口，接收传入的动物对象" class="headerlink" title="定义统一的接口，接收传入的动物对象"></a>定义统一的接口，接收传入的动物对象</h1><h1 id="def-animal-say-animal"><a href="#def-animal-say-animal" class="headerlink" title="def animal_say(animal):"></a>def animal_say(animal):</h1><h1 id="animal-say"><a href="#animal-say" class="headerlink" title="animal.say()"></a>animal.say()</h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="animal-say-obj1"><a href="#animal-say-obj1" class="headerlink" title="animal_say(obj1)"></a>animal_say(obj1)</h1><h1 id="animal-say-obj2"><a href="#animal-say-obj2" class="headerlink" title="animal_say(obj2)"></a>animal_say(obj2)</h1><h1 id="animal-say-obj3"><a href="#animal-say-obj3" class="headerlink" title="animal_say(obj3)"></a>animal_say(obj3)</h1><h1 id="print-‘hello’-len"><a href="#print-‘hello’-len" class="headerlink" title="print(‘hello’.len())"></a>print(‘hello’.<strong>len</strong>())</h1><h1 id="print-1-2-3-len"><a href="#print-1-2-3-len" class="headerlink" title="print([1,2,3].len())"></a>print([1,2,3].<strong>len</strong>())</h1><h1 id="print-‘a’-1-’b’-2-len"><a href="#print-‘a’-1-’b’-2-len" class="headerlink" title="print({‘a’:1,’b’:2}.len())"></a>print({‘a’:1,’b’:2}.<strong>len</strong>())</h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="def-my-len-val"><a href="#def-my-len-val" class="headerlink" title="def my_len(val):"></a>def my_len(val):</h1><h1 id="return-val-len"><a href="#return-val-len" class="headerlink" title="return val.len()"></a>return val.<strong>len</strong>()</h1><h1 id="print-my-len-‘hello’"><a href="#print-my-len-‘hello’" class="headerlink" title="print(my_len(‘hello’))"></a>print(my_len(‘hello’))</h1><h1 id="print-my-len-1-2-3"><a href="#print-my-len-1-2-3" class="headerlink" title="print(my_len([1,2,3]))"></a>print(my_len([1,2,3]))</h1><h1 id="print-my-len-‘a’-1-’b’-2"><a href="#print-my-len-‘a’-1-’b’-2" class="headerlink" title="print(my_len({‘a’:1,’b’:2}))"></a>print(my_len({‘a’:1,’b’:2}))</h1><h1 id="len-‘hello’"><a href="#len-‘hello’" class="headerlink" title="len(‘hello’)"></a>len(‘hello’)</h1><h1 id="len-1-2-3"><a href="#len-1-2-3" class="headerlink" title="len([1,2,3])"></a>len([1,2,3])</h1><h1 id="len-‘a’-1-’b’-2"><a href="#len-‘a’-1-’b’-2" class="headerlink" title="len({‘a’:1,’b’:2})"></a>len({‘a’:1,’b’:2})</h1><h1 id="python推崇的是鸭子类型"><a href="#python推崇的是鸭子类型" class="headerlink" title="python推崇的是鸭子类型"></a>python推崇的是鸭子类型</h1><h1 id="class-Cpu"><a href="#class-Cpu" class="headerlink" title="class Cpu:"></a>class Cpu:</h1><h1 id="def-read-self"><a href="#def-read-self" class="headerlink" title="def read(self):"></a>def read(self):</h1><h1 id="print-‘cpu-read’"><a href="#print-‘cpu-read’" class="headerlink" title="print(‘cpu read’)"></a>print(‘cpu read’)</h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="def-write-self"><a href="#def-write-self" class="headerlink" title="def write(self):"></a>def write(self):</h1><h1 id="print-‘cpu-write’"><a href="#print-‘cpu-write’" class="headerlink" title="print(‘cpu write’)"></a>print(‘cpu write’)</h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="class-Mem"><a href="#class-Mem" class="headerlink" title="class Mem:"></a>class Mem:</h1><h1 id="def-read-self-1"><a href="#def-read-self-1" class="headerlink" title="def read(self):"></a>def read(self):</h1><h1 id="print-‘mem-read’"><a href="#print-‘mem-read’" class="headerlink" title="print(‘mem read’)"></a>print(‘mem read’)</h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><h1 id="def-write-self-1"><a href="#def-write-self-1" class="headerlink" title="def write(self):"></a>def write(self):</h1><h1 id="print-‘mem-write’"><a href="#print-‘mem-write’" class="headerlink" title="print(‘mem write’)"></a>print(‘mem write’)</h1><h1 id="-9"><a href="#-9" class="headerlink" title=""></a></h1><h1 id="-10"><a href="#-10" class="headerlink" title=""></a></h1><h1 id="class-Txt"><a href="#class-Txt" class="headerlink" title="class Txt:"></a>class Txt:</h1><h1 id="def-read-self-2"><a href="#def-read-self-2" class="headerlink" title="def read(self):"></a>def read(self):</h1><h1 id="print-‘txt-read’"><a href="#print-‘txt-read’" class="headerlink" title="print(‘txt read’)"></a>print(‘txt read’)</h1><h1 id="-11"><a href="#-11" class="headerlink" title=""></a></h1><h1 id="def-write-self-2"><a href="#def-write-self-2" class="headerlink" title="def write(self):"></a>def write(self):</h1><h1 id="print-‘txt-write’"><a href="#print-‘txt-write’" class="headerlink" title="print(‘txt write’)"></a>print(‘txt write’)</h1><h1 id="-12"><a href="#-12" class="headerlink" title=""></a></h1><h1 id="-13"><a href="#-13" class="headerlink" title=""></a></h1><h1 id="obj1-Cpu"><a href="#obj1-Cpu" class="headerlink" title="obj1=Cpu()"></a>obj1=Cpu()</h1><h1 id="obj2-Mem"><a href="#obj2-Mem" class="headerlink" title="obj2=Mem()"></a>obj2=Mem()</h1><h1 id="obj3-Txt"><a href="#obj3-Txt" class="headerlink" title="obj3=Txt()"></a>obj3=Txt()</h1><h1 id="-14"><a href="#-14" class="headerlink" title=""></a></h1><h1 id="obj1-read"><a href="#obj1-read" class="headerlink" title="obj1.read()"></a>obj1.read()</h1><h1 id="obj1-write"><a href="#obj1-write" class="headerlink" title="obj1.write()"></a>obj1.write()</h1><h1 id="-15"><a href="#-15" class="headerlink" title=""></a></h1><h1 id="obj2-read"><a href="#obj2-read" class="headerlink" title="obj2.read()"></a>obj2.read()</h1><h1 id="obj2-write"><a href="#obj2-write" class="headerlink" title="obj2.write()"></a>obj2.write()</h1><h1 id="-16"><a href="#-16" class="headerlink" title=""></a></h1><h1 id="obj3-read"><a href="#obj3-read" class="headerlink" title="obj3.read()"></a>obj3.read()</h1><h1 id="obj3-write"><a href="#obj3-write" class="headerlink" title="obj3.write()"></a>obj3.write()</h1><h1 id="了解："><a href="#了解：" class="headerlink" title="了解："></a>了解：</h1><p>import abc</p><p>class Animal(metaclass=abc.ABCMeta): # 统一所有子类的标准<br>    @abc.abstractmethod<br>    def say(self):<br>        pass</p><h1 id="obj-Animal-不能实例化抽象类自己"><a href="#obj-Animal-不能实例化抽象类自己" class="headerlink" title="obj=Animal() # 不能实例化抽象类自己"></a>obj=Animal() # 不能实例化抽象类自己</h1><p>class People(Animal):<br>    def say(self):<br>        pass</p><p>class Dog(Animal):<br>    def say(self):<br>        pass</p><p>class Pig(Animal):<br>    def say(self):<br>        pass</p><h1 id="-17"><a href="#-17" class="headerlink" title=""></a></h1><h1 id="obj1-People"><a href="#obj1-People" class="headerlink" title="obj1=People()"></a>obj1=People()</h1><h1 id="obj2-Dog-1"><a href="#obj2-Dog-1" class="headerlink" title="obj2=Dog()"></a>obj2=Dog()</h1><h1 id="obj3-Pig-1"><a href="#obj3-Pig-1" class="headerlink" title="obj3=Pig()"></a>obj3=Pig()</h1>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python读取Hbase静态数据并绘制多个Echarts图</title>
    <link href="/2021/01/10/Python%E8%AF%BB%E5%8F%96Hbase%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%88%B6%E5%A4%9A%E4%B8%AAEcharts%E5%9B%BE/"/>
    <url>/2021/01/10/Python%E8%AF%BB%E5%8F%96Hbase%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%88%B6%E5%A4%9A%E4%B8%AAEcharts%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>##开始sea<br>from pyecharts import Bar, Line, Scatter, EffectScatter, Grid, Pie</p><p>import happybase<br>import pyecharts<br>#bytes.decode(‘utf-8’)<br>#from pyecharts.charts import Bar<br>from pyecharts import Bar<br>conn=happybase.Connection(“localhost”,9090)<br>table=conn.table(“gdp1”)<br>row=table.row(“AnHui_Province”)<br>#print((row))<br>Anhui_x=[]<br>Anhui_y=[]<br>Anhui_x1=[]<br>#print (row[b’year:2015’].decode(‘utf-8’))<br>for i in range(2000,2015):<br>    Anhui_x.append(i)<br>    Anhui_x1.append(str(i))<br>    a=’year:’+str(i)<br>    a=bytes(a,encoding=’utf-8’)<br>    Anhui_y.append(int(row[a]))<br>    #print(row[a])</p><h1 id="print-Anhui-x"><a href="#print-Anhui-x" class="headerlink" title="print (Anhui_x)"></a>print (Anhui_x)</h1><h1 id="print-Anhui-y"><a href="#print-Anhui-y" class="headerlink" title="print (Anhui_y)"></a>print (Anhui_y)</h1><p>row=table.row(“JiangSu_Province”)<br>#print((row))<br>JS_x=[]<br>JS_y=[]<br>JS_x1=[]<br>#print (row[b’year:2015’].decode(‘utf-8’))<br>for i in range(2000,2015):<br>    JS_x.append(i)<br>    JS_x1.append(str(i))<br>    a=’year:’+str(i)<br>    a=bytes(a,encoding=’utf-8’)<br>    JS_y.append(int(row[a]))</p><h1 id="print-JS-y"><a href="#print-JS-y" class="headerlink" title="print(JS_y)"></a>print(JS_y)</h1><p>keys=[]<br>eco=[]<br>dic={}<br>scaner=table.scan()<br>for k,v in scaner:<br>    row = table.row(k)<br>    a = ‘year:2017’<br>    a = bytes(a, encoding=’utf-8’)<br>    eco.append(int(row[a]))<br>    #k = bytes(k, encoding=’utf-8’)<br>    k=k.decode(‘utf-8’)<br>    #bytes.decode(‘utf-8’)<br>    keys.append(k)<br>    dic[k]=int(row[a])<br>    # print(k)</p><h1 id="print-keys"><a href="#print-keys" class="headerlink" title="print(keys)"></a>print(keys)</h1><h1 id="print-eco"><a href="#print-eco" class="headerlink" title="print(eco)"></a>print(eco)</h1><h1 id="print-dic"><a href="#print-dic" class="headerlink" title="print(dic)"></a>print(dic)</h1><p>key=[]<br>va=[]<br>A=sorted(dic.items(),key=lambda dic:dic[1],reverse=True)<br>j=0<br>for i in A:<br>    key.append(i[0])<br>    va.append(i[1])<br>    j=j+1<br>    if j&gt;5:<br>        break</p><h1 id="print-key"><a href="#print-key" class="headerlink" title="print(key)"></a>print(key)</h1><h1 id="print-va"><a href="#print-va" class="headerlink" title="print(va)"></a>print(va)</h1><h1 id="single"><a href="#single" class="headerlink" title="single=[]"></a>single=[]</h1><p>year=[]<br>year_str=[]<br>all=[]<br>#全国总经济走势</p><p>for i in range(1999, 2018):<br>    # if i==1997:<br>    #     continue<br>    year_str.append(str(i))<br>    a = ‘year:’ + str(i)<br>    year.append(i-1998)<br>    a = bytes(a, encoding=’utf-8’)<br>    sum=0<br>    scaner = table.scan()<br>    for k,v in scaner:<br>        # print(k)</p><pre><code>    row = table.row(k)    #print(int(row[a]))    sum=sum+int(row[a])    # single.append(int(row[a]))all.append(sum)</code></pre><p>print(year)<br>print(all)</p><h1 id="print-table"><a href="#print-table" class="headerlink" title="print(table)"></a>print(table)</h1><p>‘’’<br>    Grid类：并行显示多个图表 TODO 第一个图需为 有 x/y 轴的图，即不能为 Pie，其他位置顺序任意。<br>‘’’<br>attr=Anhui_x</p><p>v1=Anhui_y<br>bar = Bar(“经济柱状图”, title_pos=”65%”)<br>bar.add(“山东”, attr, v1, is_stack=True)<br>bar.add(“滨州”, JS_x, JS_y, is_stack=True, legend_pos=”80%”)</p><p>line = Line(“经济折线图”)<br>attr=Anhui_x1<br>line.add(<br>    “山东”,<br>    attr,<br>    Anhui_y,<br>    mark_point=[“max”, “min”],<br>    mark_line=[“average”],<br>)<br>line.add(<br>    “滨州”,<br>    JS_x1,<br>    JS_y,<br>    mark_point=[“max”, “min”],<br>    mark_line=[“average”],<br>    legend_pos=”20%”,<br>)</p><p>v1 = year<br>v2 = all<br>scatter = Scatter(“全国总经济散点图”, title_top=”50%”, title_pos=”65%”)<br>scatter.add(“scatter”, v1, v2, legend_top=”50%”, legend_pos=”80%”,<br>           # min_=’dataMin’,<br>            )</p><p>x = key<br>y = va<br>pie = Pie(“2017年前六经济饼图”,title_top=”50%”,title_pos=”20”)<br>pie.add(<br>    “2017”,<br>    x,<br>    y,<br>    radius=[15,35],<br>    center=[25,80],<br>    legend_top=”70%”,<br>    legend_pos=”5%”,<br>    legend_orient=”vertical”,<br>)</p><h1 id="TODO-配置Grid类"><a href="#TODO-配置Grid类" class="headerlink" title="TODO 配置Grid类"></a>TODO 配置Grid类</h1><p>grid = Grid(）</p><p>grid.render(“./templates/index.html”)</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python2和python3的区别</title>
    <link href="/2021/01/10/python2%E5%92%8Cpython3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/01/10/python2%E5%92%8Cpython3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>#区别<br>  python的3.0版本，常被称为python3000，简称py3k。相对于python的早期版本，这是一个较大的升级为了不带入过多累赘，python3.0在设计的时候没有考虑向下相容。<br>  许多针对早期python版本设计的程序都无法在python3.0上正常执行。为了照顾现有程序，python2.6作为一个过渡版本，基本使用了python2.x的语法和库，同时考虑了向python3.0的迁移，允许使用部分python3.0的语法与函数。<br>  新的python程序建议使用python3.0版本的语法。除非执行环境无法安装python3.0或者程序本身使用了不支持python3.0的第三方库。目前不支持python的第三方库有Twisted，py2exe，PIL等。<br>大多数第三方库都正在努力的兼容python3.0版本。即使无法立即使用python3.0，也建议编写相容的3.0版本python程序，然后使用2.6，2.7来执行。<br>#一、python3.0的一些变化<br>1.print函数<br>  print语句没有了，取而代之的是print()函数。python2.6与python2.7部分的支持这种形式的print语法。在python2.6与2.7里面以下三种形式是等价的</p><p>print “我是菜鸟”<br>print (我是菜鸟) #注意print后边有个空格<br>print(“我是菜鸟”) #print()不能带有其他任何参数<br>然而python2.6实际上已经支持新的print()语法<br>from _future_import print_function<br>print(“我是个菜鸟”,”我好菜啊”,sep=’, ‘)<br>#2.Unicode<br>python2有ASCII str()类型，unicode()是单独的，不是byte类型。现在python3有了Unicode(utf-8)字符串，以及一个字节类：byte和bytearrays。由于python3.x源码文件默认使用utf-8编码，这就使得以下代码合法</p><p>我没女友=’I have no girlfriends’<br>print(我没女友)<br>#3.除法运算<br>ython中的除法相较于其他语言会高端一些有些很复杂的规则，python中的除法有/与//两个运算符。<br>首先说除法，python2.x和大多数语言一样，比如java和c，整数相除结果是一个整数，把小数部分完全忽略掉，浮点数的除法会保留小数点的部分得到的一个浮点数结果。<br>  python3.x中除法就不再这样做了，对于整数间的相除结果也会是浮点数。（这里可以用0/1来理解）<br>  而对于//除法，这种除法叫floor除法，会对除法的结果自动进行一个floor操作，在python2.x和3.x中是一致的。</p><p>#python2.x与3.x<br>-1//2 #输出值是-1<br>注意的是并不是舍弃小数部分，而是执行floor操作，如果要截取小数部分，那么就需要使用math模块的trunc函数。<br>#4.异常<br>在python3中处理异常也轻微改变了，在python3中，我们使用as作为关键词。捕获异常的语法由 except exc,var改为 except exc as var。<br>  使用语法except(exc1,exc2) as var可以同时捕获多种类别的异常。python2.6已经支持这两种语法。<br>·在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代只有继承BaseException的对象才可被抛出。<br>·2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩写法，直接调用构造函数抛出对象即可。<br>  在2.x时代，异常在代码中除了表示程序错误，还经常做一些普通控制结构应该做的事，在3.x中可以看出，设计者让异常变得更加专一，只有在错误发生的情况下才能用去用异常捕获语句来处理。<br>#5.xrange<br>在python2中xrange()创建迭代对象的用法是非常流行的。比如：for循环或者是列表/集合/字典推导式。<br>  这个表现十分像生成器(比如：“惰性求值”)。但是这个xrange-iterable是无穷的，意味着你可以无限遍历。<br>  由于它的惰性求值，如果你要遍历它多次，xrange()函数比range()函数更快（比如for循环）。尽管如此，对比迭代一次，不建议你迭代多次，因此生成器每次都从头开始。<br>  在python3中，range()是像xrange()那样实现，以至于一个专门的xrange()函数都不再存在（在python3中xrange()会抛出命名异常。<br>#6.八进制字面量表示<br>八进制必须写成0o777，原来的形式0777不能用了；二进制0b111。新增了一个bin()函数用于将一个整数转换成二进制字串。python2.6已经支持这两种语法<br>#7.不等运算符<br>python2.x中不等于 ！=和&lt;&gt;<br>python3.x中不等于只有！=<br>#8.去掉了repr表达式”<br>python2.x中反引号”相当于repr函数的作用<br>python3.x中去掉了”这种写法，只允许repr函数，感觉repr只有debug的时候才用，多数时候还是用str函数来用字符串描述对象。<br>#9.多个模块被改名(根据PEP8)<br>旧名字    新名字<br>_winreg    winreg<br>ConfigParser    configparser<br>copy_reg    copyreg<br>Queue    queue<br>SocketServer    socketserver<br>repr    reprlib<br>  StringIO模块现在被合并到新的io模组内new，md5，gopherlib等模块被删除 。python2.6已经支援新的io模组。<br>  httplibBase，HTTPServer，CGIHTTPServer，SimpleHTTPServer，Cookie，cookerlib被合并到http包内。取消了exec语句只剩下exec()函数。python2.6已经支援exec()函数。<br>#10.数据类型<br>python3.x去除了long类型，现在只有一种整型——int<br>  新增了bytes类型，对应于2.x版本的八位串，定义一个butes字面量方法如下</p><p>b=b’lalala’<br>type(b)<br>#输出&lt;type ‘bytes’&gt;<br>str对象和bytes对象可以使用encode()(str-&gt;bytes)or.decode()(bytes-&gt;str)方法互相转换。</p><p>s=b.decode()<br>b1=s.encode()<br>dict的.keys()、.items和.values()方法返回迭代器，而之前的iterkeys()等函数都被遗弃。同事去掉的还有dict.has_key()，用in替代它吧&gt;_&lt;。</p><p>##总结<br>总之一句话，用python3吧，不要再倔强了！<br>  才开始学习计算机不久，第一次写博客，如果有问题希望大家指正，希望我们能一起学习一起进步。共勉！</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解压一个目录包括子目录中的所有 zip 文件</title>
    <link href="/2021/01/10/%E8%A7%A3%E5%8E%8B%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E5%8C%85%E6%8B%AC%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-zip-%E6%96%87%E4%BB%B6/"/>
    <url>/2021/01/10/%E8%A7%A3%E5%8E%8B%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E5%8C%85%E6%8B%AC%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-zip-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>package unzip;</p><p>import java.io.<em>;<br>import java.nio.charset.Charset;<br>import java.util.</em>;<br>import java.util.concurrent.ConcurrentLinkedQueue;<br>import java.util.zip.ZipEntry;<br>import java.util.zip.ZipFile;</p><p>/**</p><ul><li>@author jeffrey</li><li>@ClassName: UnZip</li><li>@Description: 为偷懒而生，解压一个目录包括子目录中的所有 zip 文件</li><li>@date: 2021/1/9 12:38 上午</li><li>@version:</li><li>@since JDK 1.8</li><li>/</li></ul><p>public class UnZip {</p><pre><code>/** * 用于存放于 zip 文件的安全队列 */public final static ConcurrentLinkedQueue&lt;File&gt; ZIP_QUEUE = new ConcurrentLinkedQueue&lt;&gt;();/** * 如 t1 不存活并 zipQueue 为空则修改为 true */public static boolean isFlag = false;/** * 输入流 */private static final Scanner SCANNER = new Scanner(System.in);/** * 提供一个工作路径 */private static String workPath;/** * 在解压完成后是否删除源文件 *      使用 Boolean 包装类进行判断，True / true 为 true，False / false 为 false，其他依然为 false */public static String isDelete;/** * 在解压文件时发生异常的集合 *      Key：文件名 *      Value：异常对象 */public static final HashMap&lt;File, Exception&gt; unZipFailedMap = new HashMap&lt;&gt;();/** * 找到相关的文件数量 */public static int foundCount = 0;/** * 成功解压的文件数量 */public static int succeedCount = 0;/** * 解压失败的文件数量 */public static int unZipFailedCount = 0;/** * 删除失败的文件个数 */public static int deleteFailedCount = 0;/** * 删除失败的文件名 */public static final HashSet&lt;File&gt; deleteFailedNameList = new HashSet&lt;&gt;();public static void main(String[] args) &#123;    input();    if (new File(workPath).exists()) &#123;            Thread t1 = new Thread(new FindZipFile(new File(workPath)));            Thread t2 = new Thread(new UnZipFile(ZIP_QUEUE));            t1.start();            t2.start();            while (true) &#123;                if (!t1.isAlive() &amp;&amp; ZIP_QUEUE.isEmpty()) &#123;                    isFlag = true;                    if (!t2.isAlive()) &#123;                        System.out.println                        (                                &quot;\n\n\n&quot; +                                &quot;共找到了 &quot; + foundCount + &quot; 个文件\n&quot; +                                &quot;成功解压了 &quot; + succeedCount + &quot; 个文件\n&quot; +                                        unZipFailedCount + &quot; 个文件解压失败，以下是失败原因：&quot;                        );                        Set&lt;Map.Entry&lt;File, Exception&gt;&gt; failedElement = unZipFailedMap.entrySet();                        for (Map.Entry&lt;File, Exception&gt; fileExceptionEntry : failedElement) &#123;                            System.out.println(&quot;文件：&quot; + fileExceptionEntry.getKey() + &quot; 异常：&quot; + fileExceptionEntry.getValue());                        &#125;                        if (deleteFailedCount &gt; 0) &#123;                            System.out.println(&quot;另外，还有一些文件删除失败，可能是在解压过程中失败了导致它们不被删除，它们是：&quot;);                            for (File file : deleteFailedNameList) &#123;                                System.out.println(file);                            &#125;                        &#125;                        break;                    &#125;                &#125;        &#125;    &#125;else&#123;        System.out.println(&quot;提供的工作路径不准确&quot;);    &#125;&#125;private static void input() &#123;    System.out.println(&quot;提供一个工作路径：&quot;);    workPath = SCANNER.nextLine();    System.out.println(&quot;成功解压完成后是否删除源文件（true / false）：&quot;);    isDelete = SCANNER.nextLine();&#125;</code></pre><p>}</p><p>class UnZipFile extends Thread {<br>    private final ConcurrentLinkedQueue<File> zipQueue;<br>    private static final int  BUFFER_SIZE = 2 * 1024;</p><pre><code>public UnZipFile(ConcurrentLinkedQueue&lt;File&gt; zipQueue) &#123;    this.zipQueue = zipQueue;&#125;@Overridepublic void run() &#123;    do &#123;        if (!zipQueue.isEmpty()) &#123;            File file = zipQueue.poll();            String fileName = file.getName();            File destPathName = new File(file.getParent(), fileName.substring(0, fileName.indexOf(&quot;.&quot;)));            System.out.println(destPathName.mkdirs());            unZip(file, destPathName.toString());        &#125;    &#125; while (!UnZip.isFlag);&#125;public void unZip(File srcFile, String destDirPath) throws RuntimeException &#123;    long start = System.currentTimeMillis();    // 开始解压    ZipFile zipFile = null;    FileOutputStream fos = null;    InputStream is = null;    try &#123;        zipFile = new ZipFile(srcFile, Charset.forName(&quot;GBK&quot;));        Enumeration&lt;?&gt; entries = zipFile.entries();        while (entries.hasMoreElements()) &#123;            ZipEntry entry = (ZipEntry) entries.nextElement();            File unZipPathName = new File(entry.getName());            if (!unZipPathName.isDirectory())&#123;                if (unZipPathName.getName().contains(&quot;.zip&quot;)) &#123;                    zipQueue.add(new File(srcFile.getParentFile(), unZipPathName.toString()));                    System.out.println(&quot;俄罗斯套娃文件：&quot; + unZipPathName);                &#125;            &#125;            System.out.println(&quot;解压：&quot; + unZipPathName);            // 如果是文件夹，就创建个文件夹            if (entry.isDirectory()) &#123;                String dirPath = destDirPath + File.separator + entry.getName();                File dir = new File(dirPath);                if(dir.mkdirs())&#123;                    System.out.println(&quot;No need to create&quot;);                &#125;            &#125; else &#123;                // 如果是文件，就先创建一个文件，然后用io流把内容copy过去                File targetFile = new File(destDirPath + File.separator + entry.getName());                // 保证这个文件的父文件夹必须要存在                if(!targetFile.getParentFile().exists())&#123;                    if(targetFile.getParentFile().mkdirs())&#123;                        System.out.println(&quot;No need to create&quot;);                    &#125;                &#125;                if (targetFile.createNewFile())&#123;                    System.out.println(&quot;No need to create&quot;);                &#125;                // 将压缩文件内容写入到这个文件中                is = zipFile.getInputStream(entry);                fos = new FileOutputStream(targetFile);                int len;                byte[] buf = new byte[BUFFER_SIZE];                while ((len = is.read(buf)) != -1) &#123;                    fos.write(buf, 0, len);                &#125;                fos.flush();                if (Boolean.parseBoolean(UnZip.isDelete))&#123;                    if(srcFile.delete())&#123;                        System.out.println(&quot;成功删除：&quot; + srcFile);                    &#125;else&#123;                        UnZip.deleteFailedNameList.add(srcFile);                        UnZip.deleteFailedCount++;                    &#125;                &#125;            &#125;        &#125;        long end = System.currentTimeMillis();        UnZip.succeedCount++;        System.out.println(&quot;解压完成，耗时：&quot; + (end - start) +&quot; ms&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();        UnZip.unZipFailedCount++;        UnZip.unZipFailedMap.put(srcFile, e);    &#125; finally &#123;        if(zipFile != null)&#123;            try &#123;                zipFile.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (fos != null)&#123;            try &#123;                fos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (is != null)&#123;            try &#123;                is.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>}</p><p>class FindZipFile extends Thread {<br>    private final File file;</p><pre><code>public FindZipFile(File file) &#123;    this.file = file;&#125;@Overridepublic void run() &#123;    find(file);&#125;public void find(File path)&#123;    File[] files = path.listFiles();    if (files != null) &#123;        for (File file : files) &#123;            if (file.isDirectory())&#123;                find(file);            &#125;else&#123;                UnZip.foundCount++;                String absolutePath = file.getAbsolutePath();                String[] split = absolutePath.split(&quot;\\.&quot;);                if (&quot;zip&quot;.equalsIgnoreCase(split[split.length - 1]))&#123;                    UnZip.ZIP_QUEUE.add(file);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择结构 分支结构 循环结构 方法 数组 面向对象 关键字</title>
    <link href="/2021/01/10/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-%E6%96%B9%E6%B3%95-%E6%95%B0%E7%BB%84-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/01/10/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-%E6%96%B9%E6%B3%95-%E6%95%B0%E7%BB%84-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>##一、选择结构与分支结构<br>概念：<br>根据已知条件‘进行逻辑判断，满足条件后执行相应操作;<br>#1.1基本if选择结构<br>语法：if(布尔表达式){<br>//代码块<br>}<br>//后续代码…..<br>执行流程：<br>对布尔表达式进行判断；<br>结果为true，则先执行代码块，再执行后续代码；<br>结果为false，则跳过代码块，直接执行后续代码；<br>#1.2if else选择结构<br>if(布尔表达式){<br> //代码块1<br>}else{<br> //代码块2<br>}<br>执行流程：<br>对布尔表达式进行判断；<br>结果为true，则先执行代码块1，再退出整个结构，执行后续代码；<br>结构为false，则先执行代码块2，再退出整个结构，执行后续代码；<br>#1.3多重if选择结构<br>if(布尔表达式1){<br>//代码块1<br>}else if(布尔表达式2){<br>//代码块2<br>}else if(布尔表达式3){<br>//代码块3<br>}else{<br>//代码块4<br>}<br>执行流程：<br>表达式1为true时，则执行代码块1，再退出整个结构；<br>表达式2为true时，则执行代码块2，再退出整个结构；<br>表达式3为true时，则执行代码块3，再退出整个结构；<br>以上均为false时，则执行代码块4，再退出整个结构；<br>注意：<br>相互排斥，有一个为true，其它均不再执行，适用于区间判断（区间条件，遵循从大到小或从小到大）；<br>#1.4嵌套if选择结构<br>if(外层表达式){<br> if(内层表达式){<br>  //内层代码块1<br> }else{<br>  //内层代码块2<br> }<br>}else{<br>//外层代码块<br>}<br>执行流程：<br>当外层条件满足时，再判断内层条件；<br>注意：<br>一个选择结构中，可以嵌套另一个选择结构；<br>嵌套格式正确的情况下，支持任意组合；<br>#举例<br>需求:</p><ul><li><pre><code>     键盘录入三个数据,求最大值(int类型)</code></pre></li><li></li><li><pre><code>    两种方案</code></pre></li><li><pre><code>     1)使用三元运算符去完成</code></pre></li><li><pre><code>     2)使用if格式2的嵌套</code></pre></li></ul><p>import  java.util.Scanner ;<br>public class IfTest2 {<br>    public static void main(String[] args){</p><pre><code>    //创建键盘录入对象    Scanner sc = new Scanner(System.in);    //提示并录入数据    System.out.println(&quot;请您输入第一个数据:&quot;) ;    int a = sc.nextInt() ;    System.out.println(&quot;请您输入第二个数据:&quot;) ;    int b = sc.nextInt() ;    System.out.println(&quot;请您输入第三个数据:&quot;) ;    int c = sc.nextInt() ;     //方案1:    //三元运输符 (表达式)? 执行true的结果:执行false的结果    //使用中间变量    int temp = (a&gt; b) ? a: b ;    //定义结果变量    int max = (temp &gt; c)? temp :c ;    System.out.println (&quot;三个数据中的最大值是:&quot;+max) ;    System.out.println(&quot;---------------------------------------&quot;) ;    //方式2:if格式2的嵌套 (不推荐的)    //定义变量max2    int max2 ;    if(a &gt; b)&#123;        //使用a和c进行对比        if(a&gt; c)&#123;           max2 = a ;        &#125;else&#123;           max2 = c ;        &#125;    &#125;else &#123;        //b大        if(b &gt; c)&#123;            max2 = b ;        &#125;else&#123;            max2 = c ;        &#125;    &#125;    System.out.println(&quot;三个数据中的最大值是:&quot;+max2) ;&#125;</code></pre><p>}<br>#1.5switch分支结构<br>switch(变量|表达式){<br> case  值1:<br>  逻辑代码1;<br> case  值2:<br>  逻辑代码2;<br> case  值n:<br>  逻辑代码n;<br> default:<br>  未满足时的逻辑代码;<br>}</p><p>可判断的类型：<br>byte、short、int、char、String(JDK7+)<br>执行流程：<br>如果变量中的值等于值1，则执行逻辑代码1；<br>如果变量中的值等于值2，则执行逻辑代码2；<br>如果变量中的值等与值n，则执行逻辑代码n；<br>如果变量中的值没有匹配的case值时，执行default中的逻辑代码；</p><p>注意：</p><p>所有case的取值不可相同；<br>程序演示：</p><p>import  java.util.Scanner  ;<br>public class SwitchDemo {</p><pre><code>public static void main(String[] args)&#123;    //创建键盘录入数据    Scanner sc = new Scanner(System.in) ;    //提示并录入数据    System.out.println(&quot;请您输入一个int数据:&quot;);    int week = sc.nextInt() ;     switch (week)&#123;        case 1 :            System.out.println(&quot;星期一&quot;);            break ;        case 2 :            System.out.println(&quot;星期二&quot;);            break ;        case 3 :            System.out.println(&quot;星期三&quot;);            break ;        case 4 :            System.out.println(&quot;星期四&quot;);            break ;        case 5 :            System.out.println(&quot;星期五&quot;);            break ;        case 6 :            System.out.println(&quot;星期六&quot;);            break ;        case 7 :            System.out.println(&quot;星期日&quot;);            break ;        default:            System.out.println(&quot;您输入的数据不合法&quot;);            break ;    &#125;&#125;</code></pre><p>}<br>注意：<br>当匹配的case被执行后，并不会自动退出整个结构，而是继续向下执行；<br>break关键字可以在匹配的case执行后，直接跳出整个结构；<br>##二、循环结构<br>for(初始化语句;条件判断语句;步长语句(控制体语句)){</p><pre><code>  循环体语句;</code></pre><p>  }<br>   流程:<br>  1)先执行初始化语句对变量进行赋值(只执行一次)<br>  2)判断条件语句是否成立,如果成立,执行  循环体语句<br>  3)执行步长语句(++,–)<br>  4)继续判断条件是否成立,如果还成立, 执行  循环体语句<br>  5)继续执行步长语句(++,–)<br>  …<br>  …<br>  n)当前条件不成立,for循环结束<br>  举例<br>  需求:</p><ul><li> 1)控制台输出1-10之间的数据</li><li> 2)求出1-10之间和</li><li> 3)1-100之间的数据之和</li></ul><p>public class ForDemo {<br>    public static void main(String[] args){<br>for(int x = 1 ; x &lt;= 10 ; x ++){<br>    System.out.println(x) ;<br>       }<br>//1-10之间的数据获取<br>int sum = 0 ;<br>for(int x = 1 ; x &lt;= 10 ; x ++){<br>   sum += x ; //sum = sum + x ;</p><pre><code>  &#125;</code></pre><p>System.out.println(“1-10之间的数据和是:”+sum);<br>  }<br>}<br>#2.2while循环语句<br>  while(条件表达式){<br>          循环体语句;<br>          控制体/步长语句;<br>      }<br>      扩展格式：<br>初始化语句;<br>while(条件判断语句){<br>循环体语句;<br>控制体/步长语句;<br>}<br>流程:<br>初始化语句执行一次<br>判断条件是否成立,成立,则执行循环体,再依次执行步长语句;<br>…<br>如果不成立,while循环语句结束!<br>举例<br>//需求:键盘不断录入数据,玩猜数字小游戏! (1-100之间的数据)</p><p>//分析:<br>//1)使用Math类的 random方法产生一个1-100之间的随机数 (要猜的数据)<br>//2)创建键盘录入对象,录入数据<br>//3)录入的数据和当前产生的随机数据的进行比较,<br>//4)如果大了,提示大了<br>//小了,提示小了<br>//相等,猜中了</p><p>//break:switch语句中,循环语句中使用</p><p>//产生一个1-100之间的随机数<br>int num = (int)(Math.random()*100+1) ;</p><p>while(true){<br>    //导包<br>    //创建键盘录入对象<br>    Scanner sc = new Scanner(System.in) ;</p><pre><code>//提示并录入数据System.out.println(&quot;请您输入1-100之间的数字:&quot;) ;int guessNumber = sc.nextInt() ;if(guessNumber&gt; num)&#123;    System.out.println(&quot;您要猜的数字大了!&quot;);&#125;else if(guessNumber &lt; num)&#123;    System.out.println(&quot;您要猜的数字小了!&quot;) ;&#125;else&#123;    System.out.println(&quot;恭喜您,猜中了!&quot;) ;    break ; //中断循环,否则死循环...&#125;</code></pre><p>}<br>需求:</p><ul><li><pre><code>输出所有的水仙花数</code></pre></li><li><pre><code>统计所有的水仙花数</code></pre></li></ul><p>public class WhileDemo {</p><pre><code>public static void main(String[] args)&#123; //输出所有的水仙花数    //初始化语句    int j = 100 ;    while(j&lt;1000)&#123;        //定义三个变量:ge shi bai        int ge = j % 10 ;        int shi = j /10 % 10 ;        int bai = j /10 /10 % 10 ;        if(j == (ge*ge*ge+shi*shi*shi+bai*bai*bai))&#123;            //输出            System.out.println(j)  ;         &#125;        j ++ ;    &#125;    System.out.println(&quot;-----------------------------------&quot;) ;    //统计水仙花    //定义统计变量    int count = 0 ;    //初始化语句    int i = 100 ;    while(i&lt;=999)&#123;        //定义三个变量:ge shi bai        int ge = i % 10 ;        int shi = i /10 % 10 ;        int bai = i /10 /10 % 10 ;        if(i == (ge*ge*ge+shi*shi*shi+bai*bai*bai))&#123;            //统计变量++            count ++ ;        &#125;        //步长语句        i ++;    &#125;    System.out.println(&quot;水仙花是共有:&quot;+count+&quot;个&quot;);&#125;</code></pre><p>}</p><p>while和for的区别<br>1)格式不同<br>2) 并且从内存角度考虑:<br>for循环的 格式: for循环语句外面不能够访问变量的,因为它随着for循环执行完毕,main方法结束之后,变量就会被GC(垃圾回收器)回收掉这些变量<br>while循环的扩展格式:循环结束,依然可以访问变量; 在内存中占用资源空间大于for循环<br>3)如果明确循环次数,优先使用for<br>不明确循环次数,使用while循环<br>#2.4do-while循环<br>初始化语句;<br>do{<br>循环体语句;<br>步长语句/控制体语句;<br>}while(条件表达式) ;<br>流程:<br>初始化语句执行一次,对变量进行赋值<br>执行循环体语句,<br>执行步长语句(++或者–)<br>判断while后的条件是否成立,成立,继续执行循环体语句…<br>不成立,语句结束!</p><p>do-while循环和for循环以及while循环的最大的区别就是:循环体至少执行一次!<br>举例<br>public class DoWhileDemo {<br>    public static void main(String[] args){</p><pre><code>    //控制台输出5次&quot;helloworld&quot;   // int i = 1 ;    int i = 6 ;    do&#123;        System.out.println(&quot;helloworld&quot;) ;        i++;    &#125;while(i&lt;=5) ;&#125;</code></pre><p>}<br>#2.5forfor循环嵌套<br>for循环嵌套<br>      for(初始化语句;条件表达式;步长语句){</p><pre><code>      //内层循环是外层循环的循环体语句      for(初始化语句;条件表达式;步长语句)&#123;              循环体语句;      &#125;  &#125;  注意：</code></pre><p>将内层循环看成是外层循环的循环体语句;<br>举例<br>需求:<br>  控制台输出<em>形(4行5列的</em>)<br>      <strong><strong>*<br>      *</strong></strong><br>      <strong><strong>*<br>      *</strong></strong><br>public class ForForDemo {<br>    public static void main(String[] args){<br>  for(int x = 0; x &lt; 4 ; x ++ ){//x =0 ,1,2,3  //控制行数</p><pre><code>        for(int y = 0 ; y &lt; 5; y++)&#123;//y =0,1,2,3,4 //控制列数            System.out.print(&quot;*&quot;) ;        &#125;        System.out.println() ;    &#125;&#125;</code></pre><p>}</p><p>##三、方法<br>3.1.1有具体返回值(数据类型)的方法<br>                                                //  形式参数列表<br>权限修饰符 + 静态修饰符 + 具体的返回值类型 + 方法名(数据类型1 变量名1 ,<br>数据类型2 变量名2 ,….){<br>              //方法体<br>              return 结果;<br>        }<br> 3.1.2没有具体返回值类型的方法     </p><ul><li><pre><code>     权限修饰符+静态修饰符+返回值类型 +方法名(形参列表)&#123;</code></pre></li><li><pre><code>                  没有return 语句 ;</code></pre></li><li><pre><code>                  直接完成输出操作</code></pre></li><li></li><li><pre><code>     &#125;</code></pre>定义方法有两个明确:</li></ul><p>1.明确放回值类型<br>2.明确参数类型和个数<br>3.2如何调用方法<br>调用方法:<br>1)单独调用:(没有输出)没有意义<br>2)输出调用:输出:写死了,不利于值的进一步操作<br>3)赋值调用(推荐)<br>3.3方法的重载<br>概念：<br>多个方法的方法名相同,参数列表不同,与返回值无关 —将这些方法称为”方法重载”<br>参数列表不同有两种情况<br>1)参数个数不同 (参数类型一致)<br>2)参数类型不一致(参数个数一致)<br>         public static float sum(float a,float b) {}<br>         public static float sum(int a,float b){}<br>         public static int  sum(int a,int b){}<br>         public static double sum(double a,double b,double c)<br>         public static int add(int a,float b)<br>         public static int add(float a ,int b)</p><p>##四·数组<br>4.1数组概述<br>数组概念<br>数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。<br>数组既可以存储基本数据类型，也可以存储引用数据类型。<br>数组定义的格式</p><p>格式1：数据类型[] 数组名;<br>格式2：数据类型 数组名[];<br>4.2数组的初始化<br>数组初始化概述：<br>Java中的数组必须先初始化,然后才能使用。<br>所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。<br>数组的初始化方式：<br>动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。<br>静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。<br>动态初始化<br>动态初始化初始化时只指定数组长度，由系统为数组分配初始值<br>格式：<br>数据类型[] 数组名 = new 数据类型[数组长度];<br>数组长度其实就是数组中元素的个数。</p><p>int[] arr = new int[3];</p><p>解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值。<br>静态初始化<br>静态初始化初始化时指定每个数组元素的初始值，由系统决定数组长度。<br>格式：<br>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};</p><p>int[] arr = new int[]{1,2,3};<br>解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值，并且值分别是1,2,3。<br>其实这种写法还有一个简化的写法<br>int[] arr = {1,2,3};<br>便利数组<br>//给int[]a={15,20,25,56,78,89,65};进行遍历,格式优雅<br>public class Demo {<br>    public static void main(String[] args){<br>        int[] a={15,20,25,56,78,89,65};<br>        System.out.print(“[“);//先输出左中括号”[“不换行<br>         //将元素的内容先获取到<br>        for(int i=0;i&lt;a.length;i++){ //i:数组中角标值(索引值)<br>            //需要判断元素是否为最后一个<br>            if (i==a.length-1){// 如果是最大角标值 a.length-1<br>                System.out.println(a[i]+”]”);<br>            }else{//表示是中间的元素,拼接逗号和空格,不能换行<br>                System.out.print(a[i]+”, “);<br>            }<br>        }<br>    }<br>}</p><h2 id="求数组的最值问题"><a href="#求数组的最值问题" class="headerlink" title="求数组的最值问题```"></a>求数组的最值问题```</h2><p>```java<br>//定义一个数组,静态初始化 int[] arr = {12,87,69,24,65};<br>//使用方法得到最值<br>public class Demo1 {<br>   public static  void main(String[] args){<br>       int[] arr = {12,87,69,24,65};<br>       int max = max(arr);<br>        System.out.println(“最大值是:”+max);<br>        System.out.println(“———————“);<br>       int min = min(arr);<br>       System.out.println(“最小值是:”+min);</p><p>   }<br>    public static int max(int arr[]){<br>       int max=arr[0];<br>       for(int i=1;i&lt;arr.length;i++){<br>           if(arr[i]&gt;max){<br>            max = arr[i];<br>           }<br>       }<br>       return max;<br>    }<br>    public static int min(int arr[]){<br>        int min=arr[0];<br>        for(int i=1;i&lt;arr.length;i++){<br>            if(arr[i]&lt;min){<br>                min = arr[i];<br>            }<br>        }<br>        return min;<br>    }</p><p>}</p><p>数组的逆序</p><p>//给定一个数组，把这个数组中所有元素顺序进行颠倒。（静态初始化）int arr[]={66,78,95,5,68,105}<br>public class test2 {<br>    public static  void main(String[] args){<br>        int arr[]={66,78,95,5,68,105};</p><pre><code>    System.out.println(&quot;逆序前:&quot;);    zx(arr);    System.out.println(&quot;逆序后:&quot;);    nx(arr);    zx(arr);&#125;public static void zx(int arr[])&#123;    System.out.print(&quot;[&quot;);    for(int x = 0;x&lt;arr.length;x++)&#123;        if(x==arr.length-1)&#123;            System.out.println(arr[x]+&quot;]&quot;);        &#125;else &#123;            System.out.print(arr[x]+&quot;, &quot;);        &#125;    &#125;&#125;public static void nx(int arr[])&#123;    for (int start=0,end =arr.length-1;start&lt;end;start++,end--)&#123;        int temp = arr[start];        arr[start] = arr[end];        arr[end] = temp;    &#125;&#125;</code></pre><p>}<br>查询数组索引值<br>//int[] arr = {10,55,30,24,17} ;查询30这个元素第一次在数组中出现的索引,查询元素使用功能完成!<br>public class test4 {<br>    public static void main(String[] args){<br>        int[] arr = {10,55,30,24,17} ;<br>        int key=jb(arr,17);<br>        System.out.println(“角标是:”+key);</p><pre><code>&#125;public static int jb(int arr[],int key)&#123;    for(int x =0;x&lt;arr.length;x++)&#123;        if (key == arr[x])&#123;            return x;        &#125;    &#125;    return -1;&#125;</code></pre><p>}<br>数组之冒泡排序<br>public class tset1 {<br>    public static void main(String[] args){<br>    int arr[]={78,56,13,98,105};</p><pre><code>    System.out.println(&quot;排序前:&quot;);    bl(arr);//遍历    System.out.println(&quot;排序后:&quot;);    maopao(arr);//调用方法来排序    bl(arr);//遍历&#125;public static void maopao(int arr[])&#123;    for (int x=0;x&lt;arr.length-1;x++)&#123;//0,1,2,3循环的次数        for (int y=0;y&lt;arr.length-1-x;y++)&#123;//y是角标0,1,2,3,4            if(arr[y]&gt;arr[y+1])&#123;//判断:如果前面的元素比后面元素大,将大的元素往后放                int temp=arr[y];//交互元素----采用中间变量的方法                arr[y]=arr[y+1];                arr[y+1]=temp;            &#125;        &#125;    &#125;&#125;//遍历数组public static void bl(int arr[])&#123;    System.out.print(&quot;[&quot;);    for (int x=0;x&lt;arr.length;x++)&#123;        if (x==arr.length-1)&#123;            System.out.println(arr[x]+&quot;]&quot;);        &#125; else &#123;            System.out.print(arr[x]+&quot;, &quot;);        &#125;    &#125;&#125;</code></pre><p>}<br>##五、面向对象<br>面向对象思想概述以及特点<br>思想概述:<br>面向对象是基于面向过程的编程思想<br>特点：<br>1.是一种更符合我们思想习惯的思想<br>2. 可以将复杂的事情简单化<br>3. 将我们从执行者变成了指挥者角色发生了转换<br>Java语言的面向对象特征:<br>封装(encapsulation) 继承(inheritance) 多态(polymorphism)<br>5.1类与对象关系<br>类：是一组相关的属性和行为的集合<br>类—Java中的最基本单元</p><p>对象：是该类事物的具体体现(应该是指定的某个类中具体的事物)<br>类的定义<br>例如：现实世界的事物 属性 人的身高，体重等 行为 人可以学习，吃饭等Java中用class描述事物也是如此</p><p>成员变量: 就是事物的属性</p><p>成员方法: 就是事物的行为 定义类其实就是定义类的成员(成员变量和成员方法)<br>5.2匿名对象<br>匿名对象：就是没有名字的对象。<br>是对象的一种简化表示形式<br>匿名对象的两种使用情况<br>对象调用方法仅仅一次的时候<br>作为实际参数传递<br>5.3封装<br>Java提供一个关键字:private 封装<br>封装概述:是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。<br>封装原则：<br>将不需要对外提供的内容都隐藏起来。<br>把属性隐藏，提供公共方法对其访问。<br>##六、关键字<br>6.1private关键字<br>private关键字：<br>是一个权限修饰符。<br>可以修饰成员(成员变量和成员方法)<br>被private修饰的成员只在本类中才能访问。<br>private最常见的应用：<br>把成员变量用private修饰<br>提供对应的getXxx()/setXxx()方法<br>一个标准的案例的使用\</p><p>6.2this关键字<br>this:代表所在类的对象引用<br>记住：<br>方法被哪个对象调用，this就代表那个对象<br>什么时候使用this呢?<br>局部变量隐藏成员变量<br>举例<br>/*</p><ul><li>将下面的需求写完后进行测试！<br>  编写一个矩形类Rect，包含：<br>  矩形的宽width；矩形的高height。<br>  两个构造方法：<pre><code>  一个带有两个参数的构造方法，用于将width和height属性初化；  一个不带参数的构造方法，将矩形初始化为宽和高都为10。</code></pre>  两个方法：<pre><code>  求矩形面积的方法area()  求矩形周长的方法perimeter()</code></pre></li><li></li><li>*/</li></ul><p>//创建一个矩形类<br>class Rect{<br>    //定义成员变量,并封装private<br>    private int width;<br>    private int height;<br>    public void setWidth(int width){<br>        this.width=width;<br>    }<br>    public int getWidth(){<br>        return width;<br>    }<br>    public void setHeight(int height){<br>        this.height=height;<br>    }<br>    public int getHeight(){<br>        return height;<br>    }<br>    //定义构造方法<br>    public Rect(){//无参数构造</p><pre><code>&#125;public Rect(int width,int height)&#123;//有参数构造方法    this.width=width;    this.height=height;&#125;//创建成员方法public  int mainji(int width,int height)&#123;//计算面积    return width*height;&#125;public  int zhouchang(int width,int height)&#123;//计算周长    return (width+height)*2;&#125;</code></pre><p>}</p><p>//矩形方法测试区<br>public class RectTest {<br>    public static void main(String[] args){<br>        Rect r=new Rect(10,10);//创建一个矩形对象</p><pre><code>   int a= r.mainji(r.getWidth(),r.getHeight());//调用方法算面积    System.out.println(&quot;矩形的面积是:&quot;+a);//输出    int b=r.zhouchang(r.getWidth(),r.getHeight());//调用方法算周长    System.out.println(&quot;矩形的周长是:&quot;+b);//输出周长&#125;</code></pre><p>}</p><p>ok完结</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring boot小白第一天 spring概述和简述</title>
    <link href="/2021/01/10/Spring-boot%E5%B0%8F%E7%99%BD%E7%AC%AC%E4%B8%80%E5%A4%A9-spring%E6%A6%82%E8%BF%B0%E5%92%8C%E7%AE%80%E8%BF%B0/"/>
    <url>/2021/01/10/Spring-boot%E5%B0%8F%E7%99%BD%E7%AC%AC%E4%B8%80%E5%A4%A9-spring%E6%A6%82%E8%BF%B0%E5%92%8C%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>##SpringBoot第一天<br>欢迎使用Markdown编辑器-JHui<br>springboot总结<br>1.2 编写第一个springboot工程<br>1.2.1 使用maven工具构建一个maven项目<br>1.2.2 在pom文件中引入父级依赖(spring boot项目启动时自动配置 pom文件如下<br>  <parent><br>        <groupId>org.springframework.boot</groupId><br>        <artifactId>spring-boot-starter-parent</artifactId><br>        <version>2.0.1.RELEASE</version><br>    </parent><br> <img src="https://img-blog.csdnimg.cn/20210109194916801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="pom第一步"></p><p> 1.2.3 在pom文件引入web启动器<br>         <!--             web 启动器  spring的自动配置         --><br>         <dependency><br>             <groupId>org.springframework.boot</groupId><br>             <artifactId>spring-boot-starter-web</artifactId><br>         </dependency></p><p>  1.2.4编写一个controller<br>  <img src="https://img-blog.csdnimg.cn/20210109195040790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="controller"></p><p>  1.2.5 编写springboot的启动类 这项目为 App.class 启动类  启动springboot项目<br>  <img src="https://img-blog.csdnimg.cn/20210109195125862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="App.class"></p><p>  @SpringbootApplication<br>  public class App{<br>     public static void main(String[] args) {<br>            SpringApplication.run(App.class,args);<br>        }<br>  }</p><p>1.3 构建springboot项目需要哪些细节<br>1.3.1 parent标签里面到底定义了什么<br>spring-boot-starter-parent继承了 spring-boot-dependencies，在spring-boot-dependencies<br>定义了大量的第三方技术的依赖 并做了相应的版本控制，我们需要引入某个技术的启动器，如果这个启动器<br>在spring-boot-starter-parent里面存在，那么springboot项目在运行时，会进行对应启动器的<br>自动配置<br>1.3.2 spring-boot-starter-web里面定义了什么<br>json格式数据装换的依赖 ，springmvc的依赖 ，tomcat依赖。。。。<br>1.3.3 spring boot如何进行包扫描?<br> 在springboot启动器上@SpringBootApplication    有@ComponentScan<br> <img src="https://img-blog.csdnimg.cn/20210109195332487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="ComponentScan"></p><p> 注解专门进行包扫描的操作  扫描当前注解所在的类的包下的所有子包<br>#拓展<br>Integer 和 int 到底底层有什么区别</p><p>1、Integer是int的包装类，int则是java的一种基本数据类型</p><p>2、Integer变量必bai须实例化后才能使用，而int变量不需要</p><p>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。<br>4、Integer的默认值是null，int的默认值是0<br>#扩展资料：</p><p>integer，整数 / 整型数，与小数 / 浮点数相对，是编程语言的基本数据类型之一，用以指示变量的数据类型，有时也用于常量（变量、表达式）的强制数据类型转换。整型数据的长度及其取值范围并不固定，受编译环境影响。在不同的编程语言中做此类型声明时，具体实现方式也可能会有所区别。</p><p>Integer 一个整型数据用来存储整数，整数包括正整数，负整数和零。整型常量采用十进制整数表示。如 1991，0，-123等等都是整型常量。而52.0或131.4都不是整型常量。</p><p>Integer 变量存储为最接近编译环境的长度，例如在32位的编译环境下，Integer为32位，其范围为 -2^15 到 2^15-1 之间。VB中Integer 的类型声明字符是百分比符号 (%)。Pascal中就是integer。在C语言中被缩写成为int。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML,javaScript,JQuery中怎么自定义属性</title>
    <link href="/2021/01/10/HTML-javaScript-JQuery%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/01/10/HTML-javaScript-JQuery%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>有两种方式选择，第一种是使用【data-名称】来实现自定义属性，这种方式在浏览器查看源代码时在标签上是看不到属性的；第二种就是直接使用【名称】来实现。<br>#方式一：直接在HTML标签中使用data-名称来进行定义即可<br>eg:<span data-age="22">hello</span><br><span age="22">hello</span></p><p>Tips:!!!【data-名称】这种方式的自定义属性，在使用js取值时，一定要把名称小写，不然取不到值。<br>#方式二：使用JavaScript进行设置自定义属性<br>/**</p><ul><li><ol><li>原生JavaScript操作</li></ol></li><li>/<br>var obj = document.getElementById(“hello”);<br>//方式1：<br>obj.setAttribute(“age”,”123456”);<br>//方式2：<br>obj.attributes[“age”].nodeValue = “123456”;<br>Tips:<br>JavaScript设置的自定义属性，用户查看源码在标签上也是看不到的<br>#方式三：使用JQuery进行设置自定义属性<br>$(function () {<pre><code>/** * 方法一：attr() */// 设置值$(&quot;#hello&quot;).attr(&quot;info&quot;,&quot;你好&quot;);// 设置多个值$(&quot;#hello&quot;).attr(&#123; name: &quot;Tom&quot;, age: &quot;22&quot; &#125;);/** * 方法二：data() */$(&quot;#hello&quot;).data(&quot;hope&quot;, &quot;年薪100k&quot;);</code></pre>})<br>Tips: 两种方法在标签上都是看不到属性的。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html前端css实现霓虹按钮</title>
    <link href="/2021/01/10/html%E5%89%8D%E7%AB%AFcss%E5%AE%9E%E7%8E%B0%E9%9C%93%E8%99%B9%E6%8C%89%E9%92%AE/"/>
    <url>/2021/01/10/html%E5%89%8D%E7%AB%AFcss%E5%AE%9E%E7%8E%B0%E9%9C%93%E8%99%B9%E6%8C%89%E9%92%AE/</url>
    
    <content type="html"><![CDATA[<p>视频<br>视频链接：<a href="https://www.bilibili.com/video/BV1Zi4y1F7ut">https://www.bilibili.com/video/BV1Zi4y1F7ut</a></p><p>#HTML<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>sea海洋</title>    <link rel="stylesheet" href="style.css"></head><body>    <!-- 容器 -->    <div class="container">        <!-- 按钮 -->        <a href="#" style="--x:0"><span>sea</span></a>        <a href="#" style="--x:1"><span>sea</span></a>        <a href="#" style="--x:2"><span>sea</span></a>        <a href="#" style="--x:3"><span>点赞</span></a>        <a href="#" style="--x:4"><span>评论</span></a>        <a href="#" style="--x:5"><span>sea</span></a>    </div></body></html><p>#CSS<br>/* 清除浏览器默认边距，<br>使边框和内边距的值包含在元素的height和width内 */</p><ul><li>{<br>  margin: 0;<br>  padding: 0;<br>  box-sizing: border-box;<br>}<br>/* flex布局，让内容垂直和水平居中 <em>/<br>body {<br> display: flex;<br> justify-content: center;<br> align-items: center;<br> min-height: 100vh;<br> background: #000;<br>}<br>/</em> flex布局，让内容垂直和水平居中，超过的部分换行显示 <em>/<br>.container {<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>  flex-wrap: wrap;<br>}<br>/</em> 按钮的基本样式 */<br>.container a {<br>  position: relative;<br>  padding: 15px 30px;<br>  margin: 50px;<br>  border: 2px solid #0f0;<br>  font-size: 18px;<br>  font-weight: 600;<br>  text-decoration: none;<br>  letter-spacing: 5px;<br>  color: #fff;<br>  filter: hue-rotate(calc(var(–x) * 60deg));<br>  transition: 0.5s;<br>}<br>/* 鼠标经过时改变按钮样式 */<br>.container a:hover {<br>  transition-delay: 1.5s;<br>  color: #000;<br>  box-shadow: 0 0 10px #0f0,<pre><code>          0 0 20px #0f0,          0 0 40px #0f0,          0 0 80px #0f0,          0 0 160px #0f0,          0 0 320px #0f0;</code></pre>}<br>a span {<br>  position: relative;<br>  z-index: 10;<br>}<br>/* 通过伪元素::before实现按钮左边的线 */<br>.container a::before {<br>  content: “”;<br>  position: absolute;<br>  left: -20px;<br>  top: 50%;<br>  transform: translateY(-50%);<br>  background: #0f0;<br>  width: 20px;<br>  height: 2px;<br>  box-shadow: 5px -8px 0 #0f0,<pre><code>          5px 8px 0 #0f0;</code></pre>  transition: width 0.5s, height 0.5s, left 0.5s,<pre><code>           box-shadow 0.5s;</code></pre>  transition-delay: 0s, 1s, 0s, 0.5s;<br>}<br>/* 鼠标经过时改变线条的样式 */<br>.container a:hover::before {<br>  width: 60%;<br>  height: 100%;<br>  left: -2px;<br>  box-shadow: 0 0 0 #0f0,<pre><code>          0 0 0 #0f0;</code></pre>}<br>/* 通过伪元素::after实现按钮右边的线 */<br>.container a::after {<br>  content: “”;<br>  position: absolute;<br>  right: -20px;<br>  top: 50%;<br>  transform: translateY(-50%);<br>  background: #0f0;<br>  width: 20px;<br>  height: 2px;<br>  box-shadow: -5px -8px 0 #0f0,<pre><code>          -5px 8px 0 #0f0;</code></pre>  transition: width 0.5s, height 0.5s, right 0.5s,<pre><code>           box-shadow 0.5s;</code></pre>  transition-delay: 0s, 1s, 0s, 0.5s;<br>}<br>/* 鼠标经过时改变线条的样式 */<br>.container a:hover::after {<br>  width: 60%;<br>  height: 100%;<br>  right: -2px;<br>  box-shadow: 0 0 0 #0f0,<pre><code>          0 0 0 #0f0;</code></pre>}<br>今天的学习就到这里了，由于本人能力和知识有限，如果有写的不对的地方，还请各位大佬批评指正。有什么不明白的地方欢迎给我留言</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java知识体系总结</title>
    <link href="/2021/01/10/java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/10/java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>一、Java基础知识<br>1、基础知识<br>分类    内容    链接<br>Java基础<br>【Java知识点详解 1】缓存</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104557984">https://blog.csdn.net/guorui_java/article/details/104557984</a><br>Java基础<br>【Java知识点详解 2】动态代理</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108630273">https://blog.csdn.net/guorui_java/article/details/108630273</a><br>Java基础<br>【Java知识点详解 3】序列化与反序列化</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106996834">https://blog.csdn.net/guorui_java/article/details/106996834</a><br>Java基础<br>【Java知识点详解 4】泛型</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106808115">https://blog.csdn.net/guorui_java/article/details/106808115</a><br>Java基础<br>【Java知识点详解 5】枚举</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106789054">https://blog.csdn.net/guorui_java/article/details/106789054</a><br>Java基础<br>【Java知识点详解 6】注解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106658179">https://blog.csdn.net/guorui_java/article/details/106658179</a><br>Java基础<br>【Java知识点详解 7】线程池</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247853">https://blog.csdn.net/guorui_java/article/details/104247853</a><br>Java基础<br>【Java知识点详解 8】ThreadLocal</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106643383">https://blog.csdn.net/guorui_java/article/details/106643383</a><br>Java基础<br>【Java知识点详解 9】守护线程</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247772">https://blog.csdn.net/guorui_java/article/details/104247772</a><br>Java基础<br>【Java知识点详解 10】装箱和拆箱</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247762">https://blog.csdn.net/guorui_java/article/details/104247762</a><br>Java基础<br>【Java知识点详解 11】反射</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108351185">https://blog.csdn.net/guorui_java/article/details/108351185</a><br>Java8 新特性<br>【Java8 新特性 1】Lambda表达式总结（全栈最强，绝对豪横）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106996651">https://blog.csdn.net/guorui_java/article/details/106996651</a><br>Java8 新特性<br>【Java8 新特性 2】函数式接口 + Lamda表达式推导过程</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107085921">https://blog.csdn.net/guorui_java/article/details/107085921</a><br>Java8 新特性<br>【Java8 新特性 3】Supplier简介</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108009650">https://blog.csdn.net/guorui_java/article/details/108009650</a><br>Java8 新特性<br>【Java8 新特性 4】Optional</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109747645">https://blog.csdn.net/guorui_java/article/details/109747645</a><br>Java8 新特性    【Java8 新特性 5】Java8中最重磅的升级Stream    <a href="https://blog.csdn.net/guorui_java/article/details/112336449">https://blog.csdn.net/guorui_java/article/details/112336449</a><br>Java基础    JDK 和 JRE 、final 与 static 、堆和栈    <a href="https://blog.csdn.net/guorui_java/article/details/104247758">https://blog.csdn.net/guorui_java/article/details/104247758</a><br>Java基础<br>String拓展：intern()方法</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109787051">https://blog.csdn.net/guorui_java/article/details/109787051</a><br>Java基础<br>Java之StringUtils的常用方法</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109758957">https://blog.csdn.net/guorui_java/article/details/109758957</a><br>Java基础<br>深入理解Java String类</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109758824">https://blog.csdn.net/guorui_java/article/details/109758824</a><br>Java基础<br>Java内联函数</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109388173">https://blog.csdn.net/guorui_java/article/details/109388173</a><br>TCP/IP<br>BIO、NIO、AIO 介绍和适用场景分析（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107081776">https://blog.csdn.net/guorui_java/article/details/107081776</a><br>反射<br>Java 反射 getClass()</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112251144">https://blog.csdn.net/guorui_java/article/details/112251144</a><br>反射<br>Java反射之Method的invoke方法实现</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109632137">https://blog.csdn.net/guorui_java/article/details/109632137</a><br>重构<br>为什么阿里巴巴不建议在for循环中使用”+”进行字符串拼接</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109759292">https://blog.csdn.net/guorui_java/article/details/109759292</a><br>重构    【Java程序员必知必会的90个细节】1、创建和销毁对象    <a href="https://blog.csdn.net/guorui_java/article/details/107982208">https://blog.csdn.net/guorui_java/article/details/107982208</a><br>IO流<br>FileInputStream 类与 FileReader 类的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109604482">https://blog.csdn.net/guorui_java/article/details/109604482</a><br>2、集合<br>内容    链接<br>Java集合基础知识总结（绝对经典）    <a href="https://blog.csdn.net/guorui_java/article/details/106716234">https://blog.csdn.net/guorui_java/article/details/106716234</a><br>List＜T＞和List＜?＞的区别    <a href="https://blog.csdn.net/guorui_java/article/details/111363761">https://blog.csdn.net/guorui_java/article/details/111363761</a><br>List遍历删除元素remove()    <a href="https://blog.csdn.net/guorui_java/article/details/110098348">https://blog.csdn.net/guorui_java/article/details/110098348</a><br>HashMap转JavaBean</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108875459">https://blog.csdn.net/guorui_java/article/details/108875459</a><br>HashMap + 软引用进行缓存    <a href="https://blog.csdn.net/guorui_java/article/details/112389454">https://blog.csdn.net/guorui_java/article/details/112389454</a><br>Java队列Queue</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104109604">https://blog.csdn.net/guorui_java/article/details/104109604</a><br>3、多线程<br>内容    链接<br>Java多线程基础知识总结（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107599455">https://blog.csdn.net/guorui_java/article/details/107599455</a><br>Java常见的线程池</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107632310">https://blog.csdn.net/guorui_java/article/details/107632310</a><br>死锁、活锁、饿死和阻塞的个人理解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247787">https://blog.csdn.net/guorui_java/article/details/104247787</a><br>Java多线程之Executor框架</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018444">https://blog.csdn.net/guorui_java/article/details/104018444</a><br>4、怪味杂谈<br>内容    链接<br>利用百度语音识别技术实现文字转语音的应用（Java版附源码）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106825378">https://blog.csdn.net/guorui_java/article/details/106825378</a><br>Java性能优化的35个细节（珍藏版）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104107390">https://blog.csdn.net/guorui_java/article/details/104107390</a><br>tableExport导出 excel报表</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104027002">https://blog.csdn.net/guorui_java/article/details/104027002</a><br>二、Spring + SpringMVC + MyBatis<br>分类    内容    链接<br>Java框架<br>【全栈最全Java框架总结】SSH、SSM、Springboot</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018528">https://blog.csdn.net/guorui_java/article/details/104018528</a><br>JavaWeb<br>过滤器和拦截器的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111740613">https://blog.csdn.net/guorui_java/article/details/111740613</a><br>JavaWeb<br>GET和POST的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112294323">https://blog.csdn.net/guorui_java/article/details/112294323</a><br>Spring<br>使用JSR-303进行校验</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111828359">https://blog.csdn.net/guorui_java/article/details/111828359</a><br>Spring<br>Spring AOP基础知识总结</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107406542">https://blog.csdn.net/guorui_java/article/details/107406542</a><br>Spring<br>Spring常用注解（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107347754">https://blog.csdn.net/guorui_java/article/details/107347754</a><br>Spring<br>浅谈Spring事件机制</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106022134">https://blog.csdn.net/guorui_java/article/details/106022134</a><br>Spring    Spring JdbcTemplate简介    <a href="https://blog.csdn.net/guorui_java/article/details/104177211">https://blog.csdn.net/guorui_java/article/details/104177211</a><br>SpringMVC<br>SpringMVC中put和post如何选择</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109715075">https://blog.csdn.net/guorui_java/article/details/109715075</a><br>SpringMVC<br>@RequestParam、@ModelAttribute、@RequestBody的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112295474">https://blog.csdn.net/guorui_java/article/details/112295474</a><br>SpringMVC<br>HttpServletResponse response实现文件上传、下载</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111145510">https://blog.csdn.net/guorui_java/article/details/111145510</a><br>SpringMVC<br>ControllerAdvice的常用场景</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106883939">https://blog.csdn.net/guorui_java/article/details/106883939</a><br>MyBatis<br>MyBatis xml配置文件详解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109106704">https://blog.csdn.net/guorui_java/article/details/109106704</a><br>MyBatis<br>MyBatis常用标签和注解（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108875682">https://blog.csdn.net/guorui_java/article/details/108875682</a><br>MyBatis<br>【MyBatis 基础知识总结 1】SQL注入</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107220076">https://blog.csdn.net/guorui_java/article/details/107220076</a><br>MyBatis<br>【MyBatis 基础知识总结 2】MyBatis-Plus</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107219805">https://blog.csdn.net/guorui_java/article/details/107219805</a><br>SSM<br>Spring+SpringMVC+MyBatis整合</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105682019">https://blog.csdn.net/guorui_java/article/details/105682019</a><br>Hibernate<br>Hibernate基础知识总结（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106532795">https://blog.csdn.net/guorui_java/article/details/106532795</a><br>三、Spring Boot<br>内容    链接<br>超详细的springBoot学习笔记</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104137262">https://blog.csdn.net/guorui_java/article/details/104137262</a><br>【Spring Boot 1】入门篇</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104152433">https://blog.csdn.net/guorui_java/article/details/104152433</a><br>【Spring Boot 2】web应用开发，实现CRUD</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104181423">https://blog.csdn.net/guorui_java/article/details/104181423</a><br>【Spring Boot 3】Thymeleaf 使用详解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104231260">https://blog.csdn.net/guorui_java/article/details/104231260</a><br>【Spring Boot 4】如何优雅的使用 Mybatis</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104229009">https://blog.csdn.net/guorui_java/article/details/104229009</a><br>【Spring Boot 5】Spring Boot Jpa 的使用</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104241662">https://blog.csdn.net/guorui_java/article/details/104241662</a><br>【Spring Boot 6】自定义starter    <a href="https://blog.csdn.net/guorui_java/article/details/106867215">https://blog.csdn.net/guorui_java/article/details/106867215</a><br>【Spring Boot 7】RabbitMQ基础知识总结</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104261716">https://blog.csdn.net/guorui_java/article/details/104261716</a><br>【Spring Boot 8】Okhttp实现GitHub第三方登录</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104328355">https://blog.csdn.net/guorui_java/article/details/104328355</a><br>【Spring Boot 9】结合mybatis实现增删改查</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104352990">https://blog.csdn.net/guorui_java/article/details/104352990</a><br>【Spring Boot 10】Spring Boot + mybatis + Thymeleaf 分页示例（纯底层代码，不是pagehelper）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104408412">https://blog.csdn.net/guorui_java/article/details/104408412</a><br>【Spring Boot 11】如何测试打包部署</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104476691">https://blog.csdn.net/guorui_java/article/details/104476691</a><br>【Spring Boot 12】看完这篇，Redis你就入门了</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104277843">https://blog.csdn.net/guorui_java/article/details/104277843</a><br>【Spring Boot 13】实现热部署</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104496412">https://blog.csdn.net/guorui_java/article/details/104496412</a><br>【Spring Boot 14】原理篇</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104652332">https://blog.csdn.net/guorui_java/article/details/104652332</a><br>【Spring Boot 15】启动类原理解析</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104793766">https://blog.csdn.net/guorui_java/article/details/104793766</a><br>【Spring Boot 16】常用注解介绍及使用</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105070627">https://blog.csdn.net/guorui_java/article/details/105070627</a><br>【Spring Boot 17】浅谈分布式锁</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104277793">https://blog.csdn.net/guorui_java/article/details/104277793</a><br>【Spring Boot 18】Spring Boot + Vue 实现CRUD</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107010007">https://blog.csdn.net/guorui_java/article/details/107010007</a><br>【Spring Boot 19】Spring Boot整合阿里云OSS实现云存储</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107010852">https://blog.csdn.net/guorui_java/article/details/107010852</a><br>【Spring Boot 20】Spring Boot + Vue 整合阿里云视频点播</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107274455">https://blog.csdn.net/guorui_java/article/details/107274455</a><br>【Spring Boot 21】Spring Boot 项目如何部署</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108275920">https://blog.csdn.net/guorui_java/article/details/108275920</a><br>【Spring Boot 22】QueryMapper初探</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108596631">https://blog.csdn.net/guorui_java/article/details/108596631</a><br>【Spring Boot 23】MyBatis事务管理</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109088823">https://blog.csdn.net/guorui_java/article/details/109088823</a><br>【Spring Boot 24】MyBatis逆向工程（Example + Criteria简介）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/110311091">https://blog.csdn.net/guorui_java/article/details/110311091</a><br>【Spring Boot 25】JdbcTemplate配置类 + 事务控制 + API简介</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111936978">https://blog.csdn.net/guorui_java/article/details/111936978</a><br>【Spring Boot 26】分别在SpringBoot和Vue中解决跨域问题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109874891">https://blog.csdn.net/guorui_java/article/details/109874891</a><br>SpringBoot启动类中注入service</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108833612">https://blog.csdn.net/guorui_java/article/details/108833612</a><br>Spring Boot 谷粒学院、谷粒商城项目问题汇总</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106794847">https://blog.csdn.net/guorui_java/article/details/106794847</a><br>Spring Boot常用注解（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107379648">https://blog.csdn.net/guorui_java/article/details/107379648</a><br>四、SpringCloud<br>内容    链接<br>SpringCloud学习总纲</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112055672">https://blog.csdn.net/guorui_java/article/details/112055672</a><br>【Spring Cloud 1】分布式架构入门</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112056367">https://blog.csdn.net/guorui_java/article/details/112056367</a><br>【Spring Cloud 2】软件架构设计</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112093407">https://blog.csdn.net/guorui_java/article/details/112093407</a><br>【Spring Cloud 3】分布式架构下的高可用设计与可伸缩设计</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112102190">https://blog.csdn.net/guorui_java/article/details/112102190</a><br>【Spring Cloud 4】构建高性能的大型分布式网站</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112116728">https://blog.csdn.net/guorui_java/article/details/112116728</a><br>【Spring Cloud 5】SOA架构和微服务架构之间的关系</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112134533">https://blog.csdn.net/guorui_java/article/details/112134533</a></p><p>【Spring Cloud 6】注册中心Eureka</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106524578">https://blog.csdn.net/guorui_java/article/details/106524578</a><br>【Spring Cloud 7】限流、降级和熔断Hystrix</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107179147">https://blog.csdn.net/guorui_java/article/details/107179147</a><br>【Spring Cloud 8】熔断与限流Sentinel</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104551146">https://blog.csdn.net/guorui_java/article/details/104551146</a><br>【Spring Cloud 9】看完这篇，Docker你就入门了</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104213743">https://blog.csdn.net/guorui_java/article/details/104213743</a><br>微服务与SOA架构</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104496409">https://blog.csdn.net/guorui_java/article/details/104496409</a><br>如果你还不懂微服务，你就危险了！</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107634737">https://blog.csdn.net/guorui_java/article/details/107634737</a><br>RPC服务和HTTP服务对比</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107513214">https://blog.csdn.net/guorui_java/article/details/107513214</a><br>五、读书笔记<br>1、重构 改善既有代码的设计<br>内容    链接<br>重构，改善既有代码的设计</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018540">https://blog.csdn.net/guorui_java/article/details/104018540</a><br>《重构 改善既有代码的设计 1》重构原则</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111305499">https://blog.csdn.net/guorui_java/article/details/111305499</a><br>《重构 改善既有代码的设计 2》重新组织函数、数据</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111434891">https://blog.csdn.net/guorui_java/article/details/111434891</a><br>《重构 改善既有代码的设计 3》代码的可理解性应该是我们虔诚追求的目标</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111742701">https://blog.csdn.net/guorui_java/article/details/111742701</a><br>2、【编写高质量代码：改善Java程序的151个建议】<br>内容    链接<br>第1章：Java开发中通用的方法和准则___建议1~13</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247675">https://blog.csdn.net/guorui_java/article/details/104247675</a><br>第1章：Java开发中通用的方法和准则___建议14~20</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247792">https://blog.csdn.net/guorui_java/article/details/104247792</a><br>第2章:基本类型___建议21~30</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247793">https://blog.csdn.net/guorui_java/article/details/104247793</a><br>第3章:类、对象及方法___建议31~51</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247797">https://blog.csdn.net/guorui_java/article/details/104247797</a><br>第4章:字符串___建议52~59</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247800">https://blog.csdn.net/guorui_java/article/details/104247800</a><br>第5章:数组和集合___建议60~66</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247804">https://blog.csdn.net/guorui_java/article/details/104247804</a></p><p>第5章:数组和集合___建议67~82</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247810">https://blog.csdn.net/guorui_java/article/details/104247810</a><br>第6章:枚举和注解___建议83~92</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247824">https://blog.csdn.net/guorui_java/article/details/104247824</a><br>第7章:泛型和反射___建议93~100</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247834">https://blog.csdn.net/guorui_java/article/details/104247834</a><br>第7章:泛型和反射___建议101~109</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247868">https://blog.csdn.net/guorui_java/article/details/104247868</a><br>第8章:异常___建议110~117</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247839">https://blog.csdn.net/guorui_java/article/details/104247839</a><br>第9章:多线程和并发___建议118~124</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247845">https://blog.csdn.net/guorui_java/article/details/104247845</a><br>第9章:多线程和并发___建议125~131</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247855">https://blog.csdn.net/guorui_java/article/details/104247855</a><br>第10章:性能和效率，第11章:开源世界，第12章:思想为源___建议132~151</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247858">https://blog.csdn.net/guorui_java/article/details/104247858</a><br>3、深入理解Java虚拟机<br>内容    链接<br>《深入理解Java虚拟机 1》Java内存区域与内存分配策略</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018475">https://blog.csdn.net/guorui_java/article/details/104018475</a><br>《深入理解Java虚拟机 2》性能监控与调优</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104026992">https://blog.csdn.net/guorui_java/article/details/104026992</a><br>《深入理解Java虚拟机 3》类加载机制与字节码执行引擎</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104026995">https://blog.csdn.net/guorui_java/article/details/104026995</a><br>类加载与执行子系统的案例与实战</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104038430">https://blog.csdn.net/guorui_java/article/details/104038430</a><br>【JVM】HotSpot VM GC 的种类</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104036507">https://blog.csdn.net/guorui_java/article/details/104036507</a><br>【JVM】内存调优</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104036501">https://blog.csdn.net/guorui_java/article/details/104036501</a><br>【JVM】Eclipse运行速度调优</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104036482">https://blog.csdn.net/guorui_java/article/details/104036482</a><br>JVM堆内存详解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109437377">https://blog.csdn.net/guorui_java/article/details/109437377</a><br>说一下 jvm 有哪些垃圾回收器？</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108405844">https://blog.csdn.net/guorui_java/article/details/108405844</a><br>六、高频面试题<br>内容    链接<br>Java面试题总结（附答案）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107803283">https://blog.csdn.net/guorui_java/article/details/107803283</a><br>Java基础知识面试题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108153368">https://blog.csdn.net/guorui_java/article/details/108153368</a><br>如果当时这12道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-7-14）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107343135">https://blog.csdn.net/guorui_java/article/details/107343135</a><br>如果当时这15道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-7-20）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107477924">https://blog.csdn.net/guorui_java/article/details/107477924</a><br>如果当时这15道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-7-23）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107547386">https://blog.csdn.net/guorui_java/article/details/107547386</a><br>如果当时这20道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-8-27）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108197232">https://blog.csdn.net/guorui_java/article/details/108197232</a><br>如果当时这16道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-9-9）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108503215">https://blog.csdn.net/guorui_java/article/details/108503215</a><br>Java面试题总结（乱序版，2020-08-17）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108049191">https://blog.csdn.net/guorui_java/article/details/108049191</a><br>Java面试题总结（乱序版，2020-08-18）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108076036">https://blog.csdn.net/guorui_java/article/details/108076036</a><br>Java面试题总结（乱序版，2020-08-20）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108121583">https://blog.csdn.net/guorui_java/article/details/108121583</a><br>Java面试题总结（乱序版，2020-08-31）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108151596">https://blog.csdn.net/guorui_java/article/details/108151596</a><br>Java面试题总结（乱序版，2020-09-03）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108381144">https://blog.csdn.net/guorui_java/article/details/108381144</a><br>Java面试题总结（乱序版，2020-09-19）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108689349">https://blog.csdn.net/guorui_java/article/details/108689349</a><br>Java面试题总结（乱序版，2020-09-29）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108876169">https://blog.csdn.net/guorui_java/article/details/108876169</a><br>Java面试题总结（基础面试题完结版，2020-10-13）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109043769">https://blog.csdn.net/guorui_java/article/details/109043769</a><br>Spring面试题整理</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105987495">https://blog.csdn.net/guorui_java/article/details/105987495</a><br>七、数据结构与算法<br>内容    链接<br>常见数据结构与算法整理总结</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106217472">https://blog.csdn.net/guorui_java/article/details/106217472</a><br>【数据结构与算法 1】稀疏数组</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106050189">https://blog.csdn.net/guorui_java/article/details/106050189</a><br>【数据结构与算法 2】循环队列</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106092804">https://blog.csdn.net/guorui_java/article/details/106092804</a><br>【数据结构与算法 3】单链表</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106096006">https://blog.csdn.net/guorui_java/article/details/106096006</a><br>【数据结构与算法 4】单链表面试题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106101884">https://blog.csdn.net/guorui_java/article/details/106101884</a><br>【数据结构与算法 5】环形链表解决约瑟夫问题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106155636">https://blog.csdn.net/guorui_java/article/details/106155636</a><br>【数据结构与算法 6】栈实现综合计算器</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106193563">https://blog.csdn.net/guorui_java/article/details/106193563</a><br>【数据结构与算法 7】中缀表达式转为后缀表达式，实现逆波兰计算器</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106215643">https://blog.csdn.net/guorui_java/article/details/106215643</a><br>【数据结构与算法 8】递归之迷宫问题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106230186">https://blog.csdn.net/guorui_java/article/details/106230186</a><br>【数据结构与算法 9】谁发明的八皇后，本宫赐你一丈红</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106235887">https://blog.csdn.net/guorui_java/article/details/106235887</a><br>【数据结构与算法 10】算法的时间复杂度和空间复杂度</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105925046">https://blog.csdn.net/guorui_java/article/details/105925046</a><br>【数据结构与算法 11】常见的7种排序算法</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106270186">https://blog.csdn.net/guorui_java/article/details/106270186</a><br>【数据结构与算法 12】二分查找、插值查找、斐波那契查找</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106341658">https://blog.csdn.net/guorui_java/article/details/106341658</a><br>【数据结构与算法 13】二叉树</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106398737">https://blog.csdn.net/guorui_java/article/details/106398737</a><br>八、设计模式<br>内容    链接<br>Java设计模式：23种设计模式全面解析（超级详细）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104026988">https://blog.csdn.net/guorui_java/article/details/104026988</a><br>【源码分析设计模式 1】JDK中的单例模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106585965">https://blog.csdn.net/guorui_java/article/details/106585965</a><br>【源码分析设计模式 2】JDK中的抽象工厂模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106535411">https://blog.csdn.net/guorui_java/article/details/106535411</a><br>【源码分析设计模式 3】JDK中的工厂模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105087806">https://blog.csdn.net/guorui_java/article/details/105087806</a><br>【源码分析设计模式 4】JDK中的原型模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106544941">https://blog.csdn.net/guorui_java/article/details/106544941</a><br>【源码分析设计模式 5】Java I/O系统中的装饰器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106613220">https://blog.csdn.net/guorui_java/article/details/106613220</a><br>【源码分析设计模式 6】Mybatis中的组合模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106617887">https://blog.csdn.net/guorui_java/article/details/106617887</a><br>【源码分析设计模式 7】Integer中的享元模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106640489">https://blog.csdn.net/guorui_java/article/details/106640489</a><br>【源码分析设计模式 8】mybatis中的代理模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106665200">https://blog.csdn.net/guorui_java/article/details/106665200</a><br>【源码分析设计模式 9】SpringIOC中的模板方法模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106677554">https://blog.csdn.net/guorui_java/article/details/106677554</a><br>【源码分析设计模式 10】SpringMVC中的适配器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106584559">https://blog.csdn.net/guorui_java/article/details/106584559</a><br>【源码分析设计模式 11】SpringMVC中的策略模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104039882">https://blog.csdn.net/guorui_java/article/details/104039882</a><br>【源码分析设计模式 12】JDBC中的桥接模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106688252">https://blog.csdn.net/guorui_java/article/details/106688252</a><br>【源码分析设计模式 13】命令模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106718457">https://blog.csdn.net/guorui_java/article/details/106718457</a><br>浅谈Visitor访问者模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247935">https://blog.csdn.net/guorui_java/article/details/104247935</a><br>浅谈Facade外观模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247938">https://blog.csdn.net/guorui_java/article/details/104247938</a><br>浅谈Observer观察者模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247965">https://blog.csdn.net/guorui_java/article/details/104247965</a><br>浅谈Mediator仲裁者模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247966">https://blog.csdn.net/guorui_java/article/details/104247966</a><br>浅谈Interpreter解释器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247972">https://blog.csdn.net/guorui_java/article/details/104247972</a><br>浅谈Memento备忘录模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247969">https://blog.csdn.net/guorui_java/article/details/104247969</a><br>浅谈State状态模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247975">https://blog.csdn.net/guorui_java/article/details/104247975</a><br>浅谈（chain of responsibility）责任链模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247978">https://blog.csdn.net/guorui_java/article/details/104247978</a><br>浅谈Iterator迭代器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247911">https://blog.csdn.net/guorui_java/article/details/104247911</a><br>单一职责、接口隔离、依赖倒转、里氏替换、开闭原则、迪米特、合成复用</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106469226">https://blog.csdn.net/guorui_java/article/details/106469226</a></p><p>以上来自csdn</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬虫自动化</title>
    <link href="/2021/01/10/python%E7%88%AC%E8%99%AB%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2021/01/10/python%E7%88%AC%E8%99%AB%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>导入需要用到的库</p><p>import requests<br>import pandas as pd<br>from random import choice<br>from lxml import etree<br>import openpyxl<br>import logging<br>基本配置参数</p><h1 id="日志输出的基本配置"><a href="#日志输出的基本配置" class="headerlink" title="日志输出的基本配置"></a>日志输出的基本配置</h1><p>logging.basicConfig(level=logging.INFO, format=’%(asctime)s - %(levelname)s: %(message)s’)<br>wb = openpyxl.Workbook()    # 创建工作簿对象<br>sheet = wb.active    # 获取活动的工作表<br>sheet.append([‘学校名称’, ‘中文简称’, ‘学校名称（英文）’, ‘描述’, ‘百度百科链接’])   # 添加第一行列名</p><h1 id="产生随机请求头用于切换"><a href="#产生随机请求头用于切换" class="headerlink" title="产生随机请求头用于切换"></a>产生随机请求头用于切换</h1><p>user_agent = [<br>    “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1”,<br>    “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6”,<br>……<br>    “Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24”<br>    ]<br>读取数据、爬取网页</p><h1 id="读取已有的学校名称数据"><a href="#读取已有的学校名称数据" class="headerlink" title="读取已有的学校名称数据"></a>读取已有的学校名称数据</h1><p>df = pd.read_excel(‘学校名称.xlsx’)[‘学校名称’]<br>items = df.values</p><h1 id="遍历-获取每所学校名称"><a href="#遍历-获取每所学校名称" class="headerlink" title="遍历  获取每所学校名称"></a>遍历  获取每所学校名称</h1><p>for item in items:<br>    try:<br>        # 随机生成请求头<br>        headers = {<br>            ‘User-Agent’:choice(user_agent)<br>        }<br>        # 构造url<br>        url = f’<a href="https://baike.baidu.com/item/%7Bitem%7D&#39;">https://baike.baidu.com/item/{item}&#39;</a><br>        # 发送请求   获取响应<br>        rep = requests.get(url, headers=headers)<br>        # Xpath解析提取数据<br>        html = etree.HTML(rep.text)<br>        # 描述<br>        description = ‘’.join(html.xpath(‘/html/head/meta[4]/@content’))<br>        # 外文名<br>        en_name = ‘，’.join(html.xpath(‘//dl[@class=”basicInfo-block basicInfo-left”]/dd[2]/text()’)).strip()<br>        # 中文简称  有的话  是在dd[3]标签下<br>        simple_name = ‘’.join(html.xpath(‘//dl[@class=”basicInfo-block basicInfo-left”]/dd[3]/text()’)).strip()<br>        sheet.append([item, simple_name, en_name, url])<br>        logging.info([item, simple_name, en_name, description, url])</p><pre><code>except Exception as e:    logging.info(e.args)    pass</code></pre><h1 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h1><p>wb.save(‘成果.xlsx’)<br>程序运行一会儿，数据就全部爬取下来啦。</p><p>因为开多线程，爬取的顺序会打乱，按照学姐给的学校名称的表格里的顺序排列好，就可以交付了。</p><h1 id="程序中记录一下它原本的序号-一起写入Excel"><a href="#程序中记录一下它原本的序号-一起写入Excel" class="headerlink" title="程序中记录一下它原本的序号   一起写入Excel"></a>程序中记录一下它原本的序号   一起写入Excel</h1><p> sort_num = items.index(item)<br>import pandas as pd</p><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>df = pd.read_excel(‘成果.xlsx’)</p><h1 id="按原始序号排序"><a href="#按原始序号排序" class="headerlink" title="按原始序号排序"></a>按原始序号排序</h1><p>df1 = df.sort_values(by=’原始序号’)</p><h1 id="查看排序后的数据"><a href="#查看排序后的数据" class="headerlink" title="查看排序后的数据"></a>查看排序后的数据</h1><p>df1.head(8)</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我对自己的认识</title>
    <link href="/2021/01/03/%E6%88%91%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <url>/2021/01/03/%E6%88%91%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>总觉得自己是一个无趣且内向的人。好像从小到大身边的所有人都在告诉我，你要学会变得活泼开朗，多说话，脚下的路才会特别好走。</p><p>小时候和家人出门，路上碰见熟人，我不知道该怎么开口打招呼，也分不清该叫什么敬称，逢年过节时也不知道怎么开口说些祝福的话。<br>于是被家人视为不懂事的孩子，总是被说，看别人家的孩子嘴那么甜，多讨人欢心。后来慢慢长大，到了中学，班级里的各种聚餐活动也都通通避之。<br>中学是开始学习编程，每天早上都看一两眼书，有异性坐到了自己身侧，于是一直头死死的盯着窗外，根本不敢看对方一眼。<br>这种内向浸透到我身体里的每一个角落，只喜欢下班后自己一个人待着，无趣的重复着每天的。。<br>生活。也曾尝试着让自己去适应去改变，每次很不情愿地交流后，都会觉得难受无比，也很疲惫，总是在进退两难中纠结，本来就很不开心，慢慢变得更不开心了。<br>你快乐吗，长大后与这个世界的诸多交手。或许大部分人的答案都是否定的吧。<br>我们原本想要更加痛快地生活，可那股杀<br>伐决断的勇气去哪了，被生活消磨殆尽了吗<br>很遗憾，我们终究没有为更自由的未来，冲锋陷阵过。<br>就像我们期待遇见鲸鱼，却从没有出海，甚至没有涉足野生的湖泊<br>周围人的人都在笑，他们始终不相信语言能杀人，用冰冷的语言戳别人的痛处来取乐<br>这些都像一些玻璃渣子，支离破碎，句句伤人<br>也不是每一个家庭都是避风港，我羡慕在温室里的孩子，他们骨子里发出来的自信，是我这辈子学不来的<br>我的父亲没有散文集，他的日记本里，只有给别人干活的日期<br>我的母亲脸上手上已经有了许多皱印<br>从前不理解父亲，为什么不能赚大钱，为什么不能让一家人过上更好的日子，长大后才明白为了我已经拼尽全力了<br>同级的同学不断地秀着爸妈的转账纪律和高端生活，我承认我羡慕了，但我忘不了我之前的时候恨过我父亲没有钱<br>我认为我这个15岁出头的人，应当谦卑一些，<br>每当想要评价什么人的时候切记这个世界上的人并非都具备你禀有的条件。</p><p>以上纯属我一个15岁的孩子个人主观认为，有问题也很正常，毕竟我只有这么大，对于社会经验和家庭问题所能理解的非常有限</p>]]></content>
    
    
    
    <tags>
      
      <tag>情感诉讼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于父母</title>
    <link href="/2021/01/03/%E5%85%B3%E4%BA%8E%E7%88%B6%E6%AF%8D/"/>
    <url>/2021/01/03/%E5%85%B3%E4%BA%8E%E7%88%B6%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>匿名用户</p><p>434 人赞同了该回答</p><p>好讨厌这样的自己，我也是有时候对着父母莫名其妙的控制不住情绪，知道父母很爱自己，但是聊着天就会加重语气，甚至因为很小的事情争吵，其实我觉得基本上每次都是我的错的，所以事后心里超后悔。</p><p>有次我生日，爸爸打电话跟我说：生日快乐，等下发个红包给你贺贺。</p><p>我一口就说不用了，不知道是出于什么心态，可能是想着能不向父母要钱就不要伸手拿钱（但是天知道我现在的一切都是父母给我的）</p><p>我爸爸一听，声音低下去了，他说：要的，你在外面读书过生日发个红包也是要有的。</p><p>然后我就开始控制不住自己的情绪，很急躁的回答：都说不用就不用了啦，没空了，我先挂了。</p><p>其实我觉得这个时候的我是个人渣，电话打通还不够30秒我就挂电话了，而且电话那头的人还是我爸爸在跟我说生日快乐。我一挂完电话我就开始懊恼，我为什么这么过分，明明是家人的一片心意却被我这样糟蹋，越想越后悔，我就赶紧回拨给爸爸，但是我觉得我是一个表面很冷但是内心有点感性的人（就像我对着父母说不出我爱你这几个字），所以我假装刚忙完再打电话回去给他的，然而电话正在通话中，我就想我肯定是伤到老爸的心了，所以我爸可能打电话给我大姐倾诉了（我爸爸对于我们姐妹对他的态度那些觉得有什么委屈或者烦恼的都会跟我大姐倾诉，比如经常打电话给手机调静音的我，由于经常没人接，所以很少打电话给我这些），</p><p>然后我再次回拨老爸电话时，通了，这个时候手机收到了几条信息，但是我没来得及看，就继续跟我爸说：不要发红包给我了，今天有同学已经发过红包给我了，你先把钱留着，我没钱用了再找你，</p><p>我爸坚持要发，说：这是心意，生日总要有生日的样子嘛，接受心意是种礼貌，</p><p>然后我就不想推脱了，说好吧，我爸就挂了电话急忙要发红包给我，</p><p>这时候我一打开手机看到了几个二姐发来的红包，我瞬间泪崩了，这时候我觉得我是个恶魔，因为我二姐是不记得我的生日的，每年都是我爸爸提醒她们才记得的，所以也就是说在我跟我爸通了第一通不够30秒的电话被我挂了电话的情况下，我爸爸接着打电话告诉我二姐我今天生日，不管我的语气多恶劣，爸爸好像完全忘记了我刚刚所做的那些过分的事情一样，还是继续付出着他对我的好，而我却这样子对待父母对女儿的心意，糟蹋了这些，我真的瞬间觉得用恶魔来形容我都是糟蹋了恶魔这个词了，</p><p>接着我爸爸跟我妈妈都发了一个红包给我，因为他们不会打字，但是还是一个字一个字地写了一大段祝福我的话发给我，好像希望最好的都可以加在我身上一样，那一刻我真的是无比懊悔，懊悔到想死，我是多人渣才能对父母的爱做出如此回应，我不知道我要做多少才能弥补我对父母的爱，但是我觉得我不能这样对待自己的父母，这样的我才是真正的恶魔。</p><p>我想改变，我想控制自己的情绪去对待生活中爱自己的每个人，愿他们开开心心健健康康地陪伴在自己身边。</p><p>知乎首答，忏悔和想改变。</p><p>以上来自知乎，如有侵权请联系站长</p>]]></content>
    
    
    
    <tags>
      
      <tag>情感诉讼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人matter优化</title>
    <link href="/2021/01/03/%E4%B8%AA%E4%BA%BAmatter%E4%BC%98%E5%8C%96/"/>
    <url>/2021/01/03/%E4%B8%AA%E4%BA%BAmatter%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题，点击 这里 可以查看示例效果。点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到 Hexo 的 themes 文件夹中即可。</p><p>切换主题<br>修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery</p><p>_config.yml 文件的其它修改建议:<br>请修改 _config.yml 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io)./">http://xxx.github.io）。</a><br>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。<br>如果是中文用户，则建议修改 language 的值为 zh-CN。<br>新建分类 categories 页<br>categories 页是用来展示所有分类的页面，如果 source 目录下还没有 categories/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “categories”<br>1<br>编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容：</p><hr><p>title: categories<br>date: 2018-09-30 17:25:30<br>type: “categories”<br>layout: “categories”</p><hr><p>1<br>2<br>3<br>4<br>5<br>6<br>新建标签 tags 页<br>tags 页是用来展示所有标签的页面，如果 source 目录下还没有 tags/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “tags”<br>1<br>编辑刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容：</p><hr><p>title: tags<br>date: 2018-09-30 18:23:38<br>type: “tags”<br>layout: “tags”</p><hr><p>1<br>2<br>3<br>4<br>5<br>6<br>新建关于我 about 页<br>about 页是用来展示关于我和我的博客信息的页面，如果 source 目录下还没有 about/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “about”<br>1<br>编辑刚刚新建的页面文件 /source/about/index.md，至少需要以下内容：</p><hr><p>title: about<br>date: 2018-09-30 17:25:30<br>type: “about”<br>layout: “about”</p><hr><p>新建友情连接 friends 页（可选的）<br>friends 页是用来展示友情连接信息的页面，如果 source 目录下还没有 friends/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “friends”<br>1<br>编辑刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容：</p><hr><p>title: friends<br>date: 2018-12-12 21:25:30<br>type: “friends”<br>layout: “friends”</p><hr><p>同时，在 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示：</p><p>[{<br>    “avatar”: “<a href="https://www.lixl.cn/medias/avatar.jpg&quot;">https://www.lixl.cn/medias/avatar.jpg&quot;</a>,<br>    “name”: “悟尘记”,<br>    “introduction”: “人生就是一场修行，上善若水，厚德载物。”,<br>    “url”: “<a href="https://www.lixl.cn/&quot;">https://www.lixl.cn/&quot;</a>,<br>    “title”: “前去参观”<br>}, {<br>    “avatar”: “<a href="https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2&quot;">https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2&quot;</a>,<br>    “name”: “Fabric”,<br>    “introduction”: “A Blockchain Platform for the Enterprise”,<br>    “url”: “<a href="https://hyperledger-fabric.readthedocs.io/en/master/&quot;">https://hyperledger-fabric.readthedocs.io/en/master/&quot;</a>,<br>    “title”: “前去学习”<br>}, {<br>    “avatar”: “<a href="https://www.bootcdn.cn/assets/img/maoyun.svg&quot;">https://www.bootcdn.cn/assets/img/maoyun.svg&quot;</a>,<br>    “name”: “BootCDN”,<br>    “introduction”: “稳定、快速、免费的前端开源项目 CDN 加速服务。”,<br>    “url”: “<a href="https://www.bootcdn.cn/&quot;">https://www.bootcdn.cn/&quot;</a>,<br>    “title”: “前去加速”<br>}]</p><p>代码高亮<br>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：</p><p>npm i -S hexo-prism-plugin<br>1<br>然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：</p><p>highlight:<br>  enable: false</p><p>prism_plugin:<br>  mode: ‘preprocess’    # realtime/preprocess<br>  theme: ‘tomorrow’<br>  line_number: false    # default false<br>  custom_css:<br>搜索<br>本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：</p><p>npm install hexo-generator-search –save<br>1<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>search:<br>  path: search.xml<br>  field: post<br>1<br>2<br>3<br>修改页脚<br>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。</p><p>修改社交链接<br>在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">    <i class="fa fa-github"></i></a>123其中，社交图标（如：fa-github）可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供参考：<p>Facebook: fa-facebook<br>Twitter: fa-twitter<br>Google-plus: fa-google-plus<br>Linkedin: fa-linkedin<br>Tumblr: fa-tumblr<br>Medium: fa-medium<br>Slack: fa-slack<br>新浪微博: fa-weibo<br>微信: fa-wechat<br>QQ: fa-qq<br>修改打赏的二维码图片<br>在主题文件的 source/medias/reward 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><p>一键部署<br>通过 hexo-deployer-git 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：</p><p>npm install hexo-deployer-git –save<br>1<br>修改 Hexo 根目录下的 _config.yml 文件中的如下内容:</p><h2 id="Docs-https-hexo-io-docs-deployment-html"><a href="#Docs-https-hexo-io-docs-deployment-html" class="headerlink" title="Docs: https://hexo.io/docs/deployment.html"></a>Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a></h2><p>deploy:</p><ul><li>type: git<br>repo: <a href="https://github.com/lxl80/blog.git">https://github.com/lxl80/blog.git</a><br>branch: gh-pages<br>ignore_hidden: false</li><li>type: git<br>repo: <a href="https://gitee.com/lxl80/lxl80.git">https://gitee.com/lxl80/lxl80.git</a><br>branch: master<br>ignore_hidden: false<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>也可以如本站一样，采用 hexo-deployer-cos-enhanced 插件将静态内容部署到腾讯云对象存储服务中，在DNS配置中将境内线路解析到腾讯云CDN地址，实现加速。部署完成后会自动刷新被更新文件的CDN缓存。</li></ul><p>安装：</p><p>npm install hexo-deployer-cos-enhanced –save<br>1<br>_config.yml 配置如下:</p><p>deploy:</p><ul><li>type: git<br>repo: <a href="https://github.com/lxl80/blog.git">https://github.com/lxl80/blog.git</a><br>branch: gh-pages<br>ignore_hidden: false</li><li>type: cos<br>bucket: lxl80-130****<br>region: ap-beijing<br>secretId: AKIDh9**<strong>F8FvL<br>secretKey: Z3IGiur**</strong>QZR3PgjXmlVg<br>cdnConfig:<br>  enable: true<br>  cdnUrl: <a href="https://static.lixl.cn/">https://static.lixl.cn</a><br>  bucket: static-130****<br>  region: ap-beijing<br>  folder: static<br>  secretId: AKIDh9**<strong>F8FvL<br>  secretKey: Z3IGiur**</strong>QZR3PgjXmlVg<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>然后通过 hexo g -d 即可实现一键发布，并更新CDN缓存。</li></ul><p>文章链接转静态短地址（建议安装）<br>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件生成文章时生成中文拼音的永久链接，或者用hexo-abbrlink 生成静态文章链接。以下结合hexo-abbrlink生成类似 /yyyy/mmdd+随机数.html 的文章链接地址。</p><p>安装命令如下：</p><p>npm install hexo-abbrlink –save<br>1<br>在 Hexo 根目录下的 _config.yml 文件中，修改 permalink: ，并在文件末尾新增 abbrlink:配置项：</p><p>permalink: :year/:month:day:abbrlink.html</p><p>abbrlink:<br>  alg: crc16 #算法选项：crc16丨crc32<br>  rep: dec #输出进制：dec为十进制，hex为十六进制<br>1<br>2<br>3<br>4<br>5<br>CND加速（建议启用）<br>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。也可以选择主流云服务商提供的对象存储+CDN来获得更快速及稳定的访问效果，费用低到几乎可忽略。</p><p>用法：</p><p><a href="https://cdn.jsdelivr.net/gh/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D@%E5%8F%91%E5%B8%83%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a><br>1<br>例如：</p><p><a href="https://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg">https://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg</a><br>1<br>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源。</p><p>还可以配合 PicGo图床上传工具的自定义域名前缀来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章: 使用Typora+iPic/PicGo图床+CDN实现高效Markdown创作</p><p>文章字数统计插件（可选的）<br>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><p>安装命令如下：</p><p>npm i –save hexo-wordcount<br>1<br>然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可：</p><p>wordCount:<br>  enable: false # 将这个值设置为 true 即可.<br>  postWordCount: true<br>  min2read: true<br>  totalCount: true<br>1<br>2<br>3<br>4<br>5<br>添加 RSS 订阅支持（可选的）<br>本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：</p><p>npm install hexo-generator-feed –save<br>1<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>feed:<br>  type: atom<br>  path: atom.xml<br>  limit: 20<br>  hub:<br>  content:<br>  content_limit: 140<br>  content_limit_delim: ‘ ‘<br>  order_by: -date<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明已经安装成功了。</p><p>自定制修改<br>在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分：</p><p>菜单<br>我的梦想<br>首页的音乐播放器和视频播放器配置<br>是否显示推荐文章名称和按钮配置<br>favicon 和 Logo<br>个人信息<br>TOC 目录<br>文章打赏信息<br>复制文章内容时追加版权信息<br>MathJax<br>文章字数统计、阅读时长<br>点击页面的’爱心’效果<br>我的项目<br>我的技能<br>我的相册<br>Gitalk、Gitment、Valine 和 disqus 评论配置<br>不蒜子统计和谷歌分析（Google Analytics）<br>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图<br>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><p>修改主题颜色<br>在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色：</p><p>/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */<br>.bg-color {<br>    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);<br>}</p><p>@-webkit-keyframes rainbow {<br>   /* 动态切换背景颜色. */<br>}</p><p>@keyframes rainbow {<br>    /* 动态切换背景颜色. */<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>修改 banner 图和文章特色图<br>可以直接在 /source/medias/banner 文件夹中更换喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果会 JavaScript 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 <script></script> 代码中：</p><p>$(‘.bg-cover’).css(‘background-image’, ‘url(/medias/banner/‘ + new Date().getDay() + ‘.jpg)’);<br>1<br>在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。</p><p>文章 Front-matter 介绍<br>Front-matter 选项详解<br>Front-matter 选项中的所有内容均为非必填的。但仍然建议至少填写 title 和 date 的值。</p><p>配置选项    默认值    描述<br>title    Markdown 的文件标题    文章标题，强烈建议填写此选项<br>date    文件创建时的日期时间    发布时间，强烈建议填写此选项，且最好保证全局唯一<br>author    根 _config.yml 中的 author    文章作者<br>img    featureImages 中的某个值    文章特征图<br>top    true    推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章<br>cover    false    表示该文章是否需要加入到首页轮播封面中<br>coverImg    无    表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片<br>password    无    文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项<br>toc    true    是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项<br>mathjax    false    是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行<br>summary    无    文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<br>categories    无    文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类<br>tags    无    文章标签，一篇文章可以多个标签<br>注意:</p><p>如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。<br>date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。<br>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供使用：开源中国在线工具、chahuo、站长工具。<br>以下为文章的 Front-matter 示例。</p><h2 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h2><p>title: 基于Hexo的hexo-theme-matery主题搭建博客并优化<br>date: 2019-10-03 14:25:00</p><hr><p>1<br>2<br>3<br>4<br>最全示例</p><hr><p>title: 基于Hexo的hexo-theme-matery主题搭建博客并优化<br>date: 2019-10-03 14:25:00<br>author: 悟尘<br>img: /source/images/xxx.jpg<br>top: true<br>cover: true<br>coverImg: /images/1.jpg<br>password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<br>toc: false<br>mathjax: false<br>summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<br>categories: 工具<br>tags:</p><ul><li>blog</li><li>hexo</li></ul><hr><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>SEO优化<br>搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（GitHub不允许百度的Spider爬取GitHub上的内容）。</p><p>百度优化<br>登录百度搜索资源平台， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击添加网站，按提示操作。</p><p>![](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjEzMzAyLnBuZy93MTI4MA?x-oss-process=image/format,png">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjEzMzAyLnBuZy93MTI4MA?x-oss-process=image/format,png</a> =50)</p><p>提示：由于百度的spider是爬取不到GitHub的内容的，所以在第三步验证网站的时候，建议选择CNAME验证的方式。</p><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。hexo-theme-matery主题已经内置了 自动推送 的方式， 检查 themes/hexo-theme-matery/_config.yml 文件中如下配置:</p><h1 id="百度搜索资源平台提交链接"><a href="#百度搜索资源平台提交链接" class="headerlink" title="百度搜索资源平台提交链接"></a>百度搜索资源平台提交链接</h1><p>baiduPush: true<br>1<br>2<br>自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。</p><p>谷歌优化<br>登录 Google Search Console，点击添加资源，输入自己的域名，按提示操作。</p><p>提示：需要进行DNS验证，进入DNS域名解析设置页面，按提示增加TXT记录，如下图:</p><p>验证成功后，需要提交站点地图。通过安装sitemap插件生成站点地图文件:</p><p>npm install hexo-generator-sitemap –save<br>npm install hexo-generator-baidu-sitemap –save  #百度专用，可选<br>1<br>2<br>安装后直接执行 hexo cl&amp;&amp;hexo g -d 命令，就会在网站根目录生成 sitemap.xml 文件。参照下图提交，等待收录。</p><p>注意：hexo配置文件中的url一定要输入正确的域名，插件是根据url生成站点地图的。</p><p>常用命令<br>指令说明<br>hexo server #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p>hexo server -s #以静态模式启动</p><p>hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)</p><p>hexo server -i IP地址 #自定义 IP</p><p>hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p><p>hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)</p><p>hexo d #自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)</p><p>hexo init 文件夹名称 #初始化XX文件夹名称</p><p>npm update hexo -g#升级</p><p>npm install hexo -g #安装</p><p>node-v #查看node.js版本号</p><p>npm -v #查看npm版本号</p><p>git –version #查看git版本号</p><p>hexo -v #查看hexo版本号</p><p>简写指令<br>hexo n “我的第一篇文章” 等价于 hexo new “我的第一篇文章” 还等价于 hexo new post “我的第一篇文章”</p><p>hexo p 等价于 hexo publish</p><p>hexo g 等价于 hexo generate</p><p>hexo s等价于 hexo server</p><p>hexo d 等价于 hexo deploy</p><p>hexo g -d等价于hexo generate –deploy</p><p>注: hexo clean 没有 简写, git –version 没有简写</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用github搭建静态网站</title>
    <link href="/2021/01/02/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    <url>/2021/01/02/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>1.nodejs，Git环境搭建：nodejs搭建教程:注意了，像Git这种服务器在国外的东西，它的官网下载这个软件会非常慢，建议直接在百度上搜索git下载与安装，各种软件园都能直接快速下载，留一下版本最好不要太旧就行。git搭建教程：补充参考文档（可能你会用到）：配置淘宝云<br>2.注册GitHub账号并创建仓库1. 注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度的，太简单了）2. 格式要求：xxx.github.io<br>3. 下面两个东西选其一我在里面没有演示，因为我早已经弄好了，你们看着弄。<br>4. 参考文档（可能用到）——GitHub的ssh密匙添加：<br>5. 参考文档（可能用到）——Gitee的ssh密匙添加：<br>3.快速利用hexo搭建博客：1. 脚本教程2. matery主题安装及优化matery主题官网：博客搭建完成我的博客工具自行下载vs code</p><p>另外检测 node hoxe 代码奉上<br>source install.sh test_node<br>如果出现了如图的情况证明环境变量是配置成功的<br>(出现了版本号和成功的提示信息代表配置成功)<br>source install.sh test_git<br> 一般情况下安装git工具后git环境是会自动配置的,可以无需检测git环境.此脚本可以用于linux系统,出现版本号信息则配置为成功.<br>source install.sh hexo_win<br> 提示:此时你可以去来一杯卡布奇诺,大约两分钟的时间,博客即可自动安装完成,如图:<br> 当您看到出现<code>Please run hexo s to check it out!</code>的提示,证明您已经安装成功,此时你可以运行hexo s 然后查看你的博客<br> cd hexoblog<br>hexo s<br>注意:要先cd到hexoblog目录哦!执行以上命令即可<br>可以看到出现了一段地址:<a href="http://localhost:4000/">http://localhost:4000</a><br>在浏览器访问:<a href="http://localhost:4000/">http://localhost:4000</a> ,你就可以在本地预览了<br>一键生成SSH秘钥<br>部署hexo博客的必要之物<br>git_ssh的使用<br>您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><p>./install.sh git_ssh<br>可以看到会有四条可执行命令,输入对应数字可以执行对应的命令<br>1)Key<br>2)SSH<br>3)Verify-github<br>4)Verify-coding<br>1)Key 执行1后可以一键生成秘钥<br>如果你的电脑已经存在秘钥,程序将会自动退出<br>2)SSH 执行2后可以查看你电脑中已生成的秘钥]<br>3)Verify-github 执行3后可以检查秘钥是否配置github成功<br>4)Verify-coding 执行4后可以检查秘钥是否配置coding成功<br>生成秘钥后别忘记将秘钥添加到账号里,否则秘钥不会配置成功</p><p>最后配置及部署<br>deploy:<br>  type: git<br>  repo: 这里填你的仓库地址,建议使用SSH地址,它是以git开头的<br>  branch: master<br>在1.3版本的[heox-script]后你无需自己安装上传插件,但如果报出了not found git的错误证明上传插件没有安装成功,你需要执行以下命令<br>cnpm install hexo-deployer-git –save<br>或者是npm install hexo-deployer-git –save<br>hexo g<br>就可以看到您的博客了最后关于博客主题问题<br>我会斟酌以后出一个优化教程<br>seaQQ：2021672898</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>����github���̬��վ</title>
    <link href="/2021/01/02/%E5%85%B3%E4%BA%8E%E7%88%B1%E4%B8%80%E4%B8%AA%E4%BA%BA/"/>
    <url>/2021/01/02/%E5%85%B3%E4%BA%8E%E7%88%B1%E4%B8%80%E4%B8%AA%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p>��ȷʵ����Ҫ��ȥѧϰ�ģ�������������Ǽ���ʹ��ġ��ܶ�������Զѧ����ģ���Ϊ��ֻ������һ���������úܳ�����Ȼ��һ����������̣����������Լ��ܲ�������ࡣ</p><p>��Ҫѧ�ᰮ���ͱ���֪������ʲô�������������ҪѧӢ�ѧ����ѧС����һ���ģ����Ƕ�֪����Щ����ʲô���ӣ�ѧ������һ��ʲô���ĸ��</p><p>���ǰ����������������˵�����̫��������ˣ����һ���˲���֪������ʲô���������԰���������ȫ�������壬��ô����ν�İ����ˣ���νѧϰ��ô����Ҳ���Ǵ��ű��������ġ�</p><p>������Ҫѧ��ȥ������ô����Ҫ������Ϊ��׼��Ȼ���ð��ı�׼ȥ�������ǵ������ֹ��˼ά��ʽ��������Щ��Ϊ��˼ά���ǰ�Ӧ���еı��֣����Ǿ���Ҫȥ˼�������������Ҫ��Ҫ���������뷨Ҫ��Ҫ���ڡ�</p><p>����������У����ǻ������ܶ��ʹ������飬��ǡǡ�������������ѵ�ĥ���£����Ƕ�û�ж�ҡ�����ᶨ���԰��ı�׼Ҫ�����Լ������ǲſ���ѧ�ᰮ��</p><p>����һ����������һ��죬����Ҫͨ������˼����ѧϰ�Ķ�������ʵ˵������ĺܼ򵥣���������ѧ��Ӿ��ѧ����һ������������Ҫ����սʤ�Լ���һֱ����һ��Ŀ�겻����ǰ�����ܿ˷����Ѻ�����Ĺ��̡�</p><p>����Ȼ��һ�����������벻�������ǿ����Լ����ҿ��ģ����밮�㣬�Ҳ����ģ��Ҳ��밮�㣬��Ư���Ұ��㣬�㲻Ư����Ҳ���԰��㡣�Ҷ�֪����һ˵���㲻Ư����Ҳ���԰��㣬���Ͼͻ������룺�⻰���Ƿ�ƨ��</p><p>�ҿ���ȥ��һ����Ư����Ů�ˣ��ҿ��ܲ��������һ��Ҫ���ף�Ҫ��������Ϊ�Ҳ�ϲ��������Ϊ�Ҷ������ҿ��԰�������Ҳ���Լ���</p>]]></content>
    
    
    
    <tags>
      
      <tag>��</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/20/hello-world/"/>
    <url>/2020/12/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
