<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【每日一知】主观验证 （巴纳姆效应）</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E4%B8%BB%E8%A7%82%E9%AA%8C%E8%AF%81-%EF%BC%88%E5%B7%B4%E7%BA%B3%E5%A7%86%E6%95%88%E5%BA%94%EF%BC%89/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E4%B8%BB%E8%A7%82%E9%AA%8C%E8%AF%81-%EF%BC%88%E5%B7%B4%E7%BA%B3%E5%A7%86%E6%95%88%E5%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="主观验证-（巴纳姆效应）"><a href="#主观验证-（巴纳姆效应）" class="headerlink" title="主观验证 （巴纳姆效应）"></a>主观验证 （巴纳姆效应）</h2><p><img src="https://www.go176.net/content/uploadfile/202010/4a471602735163.png" alt="sea"><br>“你很需要别人的喜欢并尊重你。你有自我批判的倾向。</p><p>你有许多可以成为你优势的能力没有发挥出来，同时你也有一些缺点，不过你一般可以克服它们。</p><p>你与异性交往有些困难，尽管外表上显得很从容，其实你内心焦躁不安。你有时会怀疑自己所做的决定或所做的事是否正确。</p><p>你喜欢生活有些变化，厌恶被人限制。你以自己能独立思考而自豪，别人的建议如果没有充分的证据你不会接受。</p><p>你认为在别人面前过于坦率地表露自己是不明智的。你有时外向、亲切、好交际，而有时则内向、谨慎、沉默。你的有些抱负往往很不现实。”</p><p>是否觉得这段话对自己的形容很贴切?这其实是一段放在任何人身上都适合的话。人们常常会认为一种笼统的，一般性的人格描述十分准确地揭示了自己的特点，实际上这是对人性和人格粗略的概括，这种倾向被成为巴纳姆效应。  </p><h3 id="主观验证（英语：Subjective-Validation），有时也称为个人验证效应，是一种认知偏误，即某人由于一项表述或信息对其具有个人意义或较为重要，而认为该表述或信息是正确的。1-换言之，观点被主观验证所影响的人会认为两个无关的事件（即巧合）相互关联，是因为他们的个人信念需要两者相关。主观验证与巴纳姆效应具有密切联系，是冷读法的一个重要原理。该效应也被认为是大多数超自然现象报告的主要原因。2-鲍勃·卡罗尔（英语：Robert-Todd-Carroll）认为，心理学家雷伊·海曼是主观验证和冷读的顶级专家。"><a href="#主观验证（英语：Subjective-Validation），有时也称为个人验证效应，是一种认知偏误，即某人由于一项表述或信息对其具有个人意义或较为重要，而认为该表述或信息是正确的。1-换言之，观点被主观验证所影响的人会认为两个无关的事件（即巧合）相互关联，是因为他们的个人信念需要两者相关。主观验证与巴纳姆效应具有密切联系，是冷读法的一个重要原理。该效应也被认为是大多数超自然现象报告的主要原因。2-鲍勃·卡罗尔（英语：Robert-Todd-Carroll）认为，心理学家雷伊·海曼是主观验证和冷读的顶级专家。" class="headerlink" title="主观验证（英语：Subjective Validation），有时也称为个人验证效应，是一种认知偏误，即某人由于一项表述或信息对其具有个人意义或较为重要，而认为该表述或信息是正确的。1 换言之，观点被主观验证所影响的人会认为两个无关的事件（即巧合）相互关联，是因为他们的个人信念需要两者相关。主观验证与巴纳姆效应具有密切联系，是冷读法的一个重要原理。该效应也被认为是大多数超自然现象报告的主要原因。2 鲍勃·卡罗尔（英语：Robert Todd Carroll）认为，心理学家雷伊·海曼是主观验证和冷读的顶级专家。"></a>主观验证（英语：Subjective Validation），有时也称为个人验证效应，是一种认知偏误，即某人由于一项表述或信息对其具有个人意义或较为重要，而认为该表述或信息是正确的。1 换言之，观点被主观验证所影响的人会认为两个无关的事件（即巧合）相互关联，是因为他们的个人信念需要两者相关。主观验证与巴纳姆效应具有密切联系，是冷读法的一个重要原理。该效应也被认为是大多数超自然现象报告的主要原因。2 鲍勃·卡罗尔（英语：Robert Todd Carroll）认为，心理学家雷伊·海曼是主观验证和冷读的顶级专家。</h3><p>一位名叫肖曼·巴纳姆的著名魔术师在评价自己的表演时说，他之所以很受欢迎是因为节目中包含了每个人都喜欢的成分，所以他使得”每一分钟都有人上当受骗”。人们常常认为一种笼统的、一般性的人格描述十分准确地揭示了自己的特点，心理学上将这种倾向称为”巴纳姆效应”。</p><p>有位心理学家给一群人做完明尼苏打多相人格检查表（MMPI）后，拿出两份结果让参加者判断哪一份是自己的结果。事实上，一份是参加者自己的结果，另一份是多数人的回答平均起来的结果。参加者竟然认为后者更准确地表达了自己的人格特征。</p><p>巴纳姆效应在生活中十分普遍。拿算命来说，很多人请教过算命先生后都认为算命先生说的”很准”。其实，那些求助算命的人本身就有易受暗示的特点。当人的情绪处于低落、失意的时候，对生活失去控制感，于是，安全感也受到影响。一个缺乏安全感的人，心理的依赖性也大大增强，受暗示性就比平时更强了。加上算命先生善于揣摩人的内心感受，稍微能够理解求助者的感受，求助者立刻会感到一种精神安慰。算命先生接下来再说一段一般的、无关痛痒的话便会使求助者深信不疑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>主观验证 （巴纳姆效应）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】对等式网络（peer-to-peer，P2P）</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E5%AF%B9%E7%AD%89%E5%BC%8F%E7%BD%91%E7%BB%9C%EF%BC%88peer-to-peer%EF%BC%8CP2P%EF%BC%89/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E5%AF%B9%E7%AD%89%E5%BC%8F%E7%BD%91%E7%BB%9C%EF%BC%88peer-to-peer%EF%BC%8CP2P%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="对等式网络（peer-to-peer，P2P）"><a href="#对等式网络（peer-to-peer，P2P）" class="headerlink" title="对等式网络（peer-to-peer，P2P）"></a>对等式网络（peer-to-peer，P2P）</h2><p> 　对等式网络又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网络传输中的节点，以降低数据丢失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。</p><p>P2P节点能遍布整个互联网，也给包括开发者在内的任何人、组织、或政府带来监控难题。P2P在网络隐私要求高和文件共享领域中，得到了广泛的应用。<br><img src="https://www.go176.net/content/uploadfile/202007/396e1595625372.png" alt="sea"><br>P2P网络的一个重要的目标就是让所有的客户端都能提供资源，包括带宽，存储空间和计算能力。因此，当有节点加入且对系统请求增多，整个系统的容量也增大。这是具有一组固定服务器的Client-Server结构不能实现的，因为在上述这种结构中，客户端的增加意味着所有用户更慢的数据传输。</p><p>P2P网络的分布特性通过在多节点上复制数据，也增加了防故障的健壮性，并且在纯P2P网络中，节点不需要依靠一个中心索引服务器来发现数据。在后一种情况下，系统也不会出现单点崩溃。</p><p>当用P2P来描述Napster 网络时，对等协议被认为是重要的，但是，实际中，Napster 网络获取的成就是对等节点（就像网络的末枝）联合一个中心索引来实现。这可以使它能快速并且高效的定位可用的内容。对等协议只是一种通用的方法来实现这一点。</p><p>分类</p><h3 id="根据中央化程度"><a href="#根据中央化程度" class="headerlink" title="根据中央化程度"></a>根据中央化程度</h3><p>一般型P2P<br>节点同时作为客户端和服务器端。<br>没有中心服务器。<br>没有中心路由器。<br>如Gnutella。</p><h3 id="特殊型P2P"><a href="#特殊型P2P" class="headerlink" title="特殊型P2P"></a>特殊型P2P</h3><p>有一个中心服务器保存节点的信息并对请求这些信息的要求做出响应。<br>节点负责发布这些信息（因为中心服务器并不保存文件），让中心服务器知道它们想共享什么文件，让需要它的节点下载其可共享的资源。<br>路由终端使用地址，通过被一组索引引用来获取绝对地址。<br>如最原始的Napster。</p><h3 id="混合型P2P"><a href="#混合型P2P" class="headerlink" title="混合型P2P"></a>混合型P2P</h3><p>同时含有一般型P2P和特殊型P2P的特点。<br>如Skype。<br>根据网路拓扑结构<br>结构P2P<br>点对点之间互有链接资讯，彼此形成特定规则拓扑结构。<br>需要请求某资源时，依该拓扑结构规则寻找，若存在则一定找得到。<br>如Chord、YaCy、Kademlia。</p><h3 id="无结构P2P"><a href="#无结构P2P" class="headerlink" title="无结构P2P"></a>无结构P2P</h3><p>点对点之间互有链接资讯，彼此形成无规则网状拓扑结构。<br>需要请求某资源节点时，以广播方式寻找，通常会设TTL，即使存在也不一定找得到。<br>如Gnutella。</p><h2 id="松散结构P2P"><a href="#松散结构P2P" class="headerlink" title="松散结构P2P"></a>松散结构P2P</h2><p>点对点之间互有链接资讯，彼此形成无规则网状拓扑结构。<br>需要请求某资源时，依现有资讯推测寻找，介于结构P2P和无结构P2P之间。<br>如Freenet。<br>对等式网络的优缺点</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>拥有较佳的并发处理能力。<br>运用内存来管理交换数据，大幅度提高性能。<br>不用投资大量金钱在服务器的软、硬件设备。<br>适用于小规模的网络，维护容易。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>架设较为复杂，除了要有开发服务器端，还要有专用的客户端。<br>用在大规模的网络，资源分享紊乱、管理较难、安全性较低。</p>]]></content>
    
    
    
    <tags>
      
      <tag>对等式网络（peer-to-peer，P2P）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】反物质 (anti matter)</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E5%8F%8D%E7%89%A9%E8%B4%A8-anti-matter/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E5%8F%8D%E7%89%A9%E8%B4%A8-anti-matter/</url>
    
    <content type="html"><![CDATA[<h2 id="反物质-anti-matter"><a href="#反物质-anti-matter" class="headerlink" title="反物质 (anti matter)"></a>反物质 (anti matter)</h2><p><img src="https://www.go176.net/content/uploadfile/202007/d18c1594273413.jpg" alt="sea"><br>反物质（英语：antimatter）在粒子物理学中是反粒子概念的延伸<br>正电子、负质子都是反粒子，它们跟通常所说的电子、质子相比较，电量相等但电性相反。科学家设想在宇宙中可能存在完全由反粒子构成的物质，也就是反物质。<br>当正反物质相遇时，双方就会相互湮灭抵消，发生爆炸并产生巨大能量。如同普通物质是由普通粒子所构成的。例如一颗反质子和一颗反电子〈正电子〉能形成一个反氢原子，如同电子和质子形成一般物质的氢原子。<br>此外，物质与反物质的结合，会如同粒子与反粒子结合一般，导致两者湮灭，且因而释放出高能光子（伽马射线）或是其他能量较低的正反粒子对。正反物质湮灭所造成的粒子，赋予的动能等同于原始正反物质对的动能，加上原物质静止质量与生成粒子静质量的差，后者通常占大部分。（爱因斯坦相对论指出，质量与能量是等价的。）<br>历史</p><p>1927年12月，英国物理学家保罗·狄拉克提出了电子的相对论方程，即即狄拉克方程。</p><p>有趣的是，等式中发现除了一般正能量之外的负能量结果。这显示出一个问题，当电子趋向于朝着最低可能的能级跃迁时；</p><p>负无限大的能量是毫无意义的。但为了要弥补这条件，狄拉克提出真空状态中是充满了负能量电子的“海”，称作狄拉克之海。任何真实的电子因此会填补这些海中具有正能量的部分。</p><p>“狄拉克之海简单说就是量子真空的零点能组成的负能量的粒子海。尽管这些粒子是不可观察的，但它们决不是虚幻的，如果用足够的能量就可以形成，哪里有物质，哪里就有狄拉克之海，想象观察到的宇宙就好像漂浮在其表面上。”</p><p>衍伸这个想法，狄拉克发现海中的这些“洞”则具有正电荷。起初他认为这是质子，但赫尔曼·外尔指出这些洞应该是具有和电子相同的质量。</p><p>1932年由美国物理学家卡尔·安德森在实验中证实了正电子的存在。在此期间，反物质有时也常被称作“反地物质”。虽然狄拉克自己没有使用反物质这个术语，但是后来的科学家将反质子等粒子称呼为反物质。完整的反物质元素周期表由查尔斯·珍妮特（Charles Janet）于1929年完成。</p><p>1995年欧洲核子研究中心的科学家在实验室中制造出了世界上第一批反物质——反氢原子。1996年，美国的费米国立加速器实验室成功制造出7个反氢原子。</p><p>1997年4月，美国天文学家宣布他们利用伽马射线探测卫星发现，在银河系上方约3500光年处有一个不断喷射反物质的反物质源，它喷射出的反物质形成了一个高达2940光年的“反物质喷泉”。由于我国参与了这项研究，因此新闻媒体曾热心地宣传过它。美国著名华裔科学家丁肇中也正致力于此。</p><p>1998年6月2日，美国发现号航天飞机携带阿尔法磁谱仪发射升空。阿尔法磁谱仪是专门设计用来寻找宇宙中的反物质的仪器。然而这次飞行并没有发现反物质，但采集了大量富有价值的数据。</p><p>2000年9月18日，欧洲核子研究中心宣布他们已经成功制造出约5万个低能状态的反氢原子，这是人类首次在实验室条件下制造出大批量的反物质。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>反质子、反中子和反电子如果像质子、中子、电子那样结合起来就形成了反原子。</p><p>反物质和物质一旦相遇，就相互吸引、碰撞并完全转化为光并释放出的巨大的能量，这个过程叫做湮灭。湮灭过程会释放出正、反物质中蕴涵的所有静质量能，根据爱因斯坦著名的质能关系式──E=mc²，一种在科学界受到普遍认同的理论认为，宇宙大爆炸早期曾产生了数量相当的物质和反物质，随后发生的物质和反物质的湮灭消耗掉了绝大部分的正、反物质，遗留下的少部分正物质构成了现如今的物质世界。理论上宇宙大爆炸时所产生的粒子与反粒子应该数量相同，但是为什么现今所遗留下来的绝大多数都是正粒子，这即所谓的“正反物质对称性破坏”（对称破缺），虽然在几个粒子对撞试验中，都发现了正粒子与反粒子的衰变略有不同，即所谓的电荷宇称不守恒（CP破坏），但在数量上仍不足以解释为何现今反物质消失的问题，这在粒子物理学上仍是一大未解决的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>反物质 (anti matter)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】拒绝服务攻击</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h2><p>拒绝服务攻击（英语：denial-of-service attack，简称DoS攻击）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。<br><img src="https://www.go176.net/content/uploadfile/202004/31eb1588079559.jpg" alt="sea"><br>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，简称DDoS攻击）。据2014年统计，被确认为大规模DDoS的攻击已达平均每小时28次。[1]DDoS发起者一般针对重要服务和知名网站进行攻击，如银行、信用卡支付网关、甚至根域名服务器等。</p><h3 id="攻击现像"><a href="#攻击现像" class="headerlink" title="攻击现像"></a>攻击现像</h3><p>1、网络异常缓慢（打开文件或访问网站）<br>2、特定网站无法访问<br>3、无法访问任何网站<br>4、垃圾邮件的数量急剧增加<br>5、无线或有线网络连接异常断开<br>6、长时间尝试访问网站或任何互联网服务时被拒绝<br>7、服务器容易断线、卡顿</p><p>拒绝服务的攻击也可能会导致目标计算机同一网络中的其他计算机被攻击，互联网和局域网之间的带宽会被攻击导致大量消耗，不但影响目标计算机，同时也影响局域网中的其他电脑。如果攻击的规模较大，整个地区的网络连接都可能会受到影响。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>DDoS攻击可以具体分成两种形式：带宽消耗型以及资源消耗型。它们都是透过大量合法或伪造的请求占用大量网络以及器材资源，以达到瘫痪网络以及系统的目的。<br>宽带消耗型攻击<br>DDoS宽带消耗攻击可以分为两个不同的层次；洪泛攻击或放大攻击。洪泛攻击的特点是利用僵尸程序发送大量流量至受损的受害者系统，目的在于堵塞其宽带。放大攻击与其类似，是通过恶意放大流量限制受害者系统的宽带；其特点是利用僵尸程序通过伪造的源IP(即攻击目标IP)向某些存在漏洞的服务器发送请求，服务器在处理请求后向伪造的源IP发送应答，由于这些服务的特殊性导致应答包比请求包更长，因此使用少量的宽带就能使服务器发送大量的应答到目标主机上。<br>UDP洪水攻击（User Datagram Protocol floods）<br>UDP（用户数据报协议）是一种无连接协议，当数据包通过UDP发送时，所有的数据包在发送和接收时不需要进行握手验证。当大量UDP数据包发送给受害系统时，可能会导致带宽饱和从而使得合法服务无法请求访问受害系统。遭受DDoS UDP洪泛攻击时，UDP数据包的目的端口可能是随机或指定的端口，受害系统将尝试处理接收到的数据包以确定本地运行的服务。如果没有应用程序在目标端口运行，受害系统将对源IP发出ICMP数据包，表明“目标端口不可达”。某些情况下，攻击者会伪造源IP地址以隐藏自己，这样从受害系统返回的数据包不会直接回到僵尸主机，而是被发送到被伪造地址的主机。有时UDP洪泛攻击也可能影响受害系统周围的网络连接，这可能导致受害系统附近的正常系统遇到问题。然而，这取决于网络体系结构和线速。<br>ICMP洪水攻击（ICMP floods）<br>ICMP（互联网控制消息协议）洪水攻击是通过向未良好设置的路由器发送广播信息占用系统资源的做法。</p><p>死亡之Ping（ping of death）<br>死亡之Ping是产生超过IP协议能容忍的数据包数，若系统没有检查机制，就会死机。<br>泪滴攻击<br>每个数据要发送前，该数据包都会经过切割，每个小切割都会记录位移的信息，以便重组，但此攻击模式就是捏造位移信息，造成重组时发生问题，造成错误。</p><p>资源消耗型攻击<br>协议分析攻击（SYN flood，SYN洪水）<br>传送控制协议（TCP）同步（SYN）攻击。TCP进程通常包括发送者和接受者之间在数据包发送之前创建的完全信号交换。启动系统发送一个SYN请求，接收系统返回一个带有自己SYN请求的ACK（确认）作为交换。发送系统接着传回自己的ACK来授权两个系统间的通讯。若接收系统发送了SYN数据包，但没接收到ACK，接受者经过一段时间后会再次发送新的SYN数据包。接受系统中的处理器和内存资源将存储该TCP SYN的请求直至超时。DDoS TCP SYN攻击也被称为“资源耗尽攻击”，它利用TCP功能将僵尸程序伪装的TCP SYN请求发送给受害服务器，从而饱和服务处理器资源并阻止其有效地处理合法请求。它专门利用发送系统和接收系统间的三向信号交换来发送大量欺骗性的原IP地址TCP SYN数据包给受害系统。最终，大量TCP SYN攻击请求反复发送，导致受害系统内存和处理器资源耗尽，致使其无法处理任何合法用户的请求。<br>LAND攻击<br>这种攻击方式与SYN floods类似，不过在LAND攻击包中的原地址和目标地址都是攻击对象的IP。这种攻击会导致被攻击的机器死循环，最终耗尽资源而死机。<br>CC攻击（Distributed HTTP flood，分布式HTTP洪水攻击）<br>CC攻击使用代理服务器向受害服务器发送大量貌似合法的请求（通常为HTTP GET)。攻击者创造性地使用代理，利用广泛可用的免费代理服务器发动DDoS攻击。许多免费代理服务器支持匿名，这使追踪变得非常困难。<br>2004年，一位匿名为KiKi的中国黑客开发了一种用于发送HTTP请求的DDoS攻击工具以攻击名为“Collapsar”的NSFOCUS防火墙，因此该黑客工具被称为“Challenge Collapsar”（挑战黑洞，简称CC），这类攻击被称作“CC攻击”。</p><h2 id="僵尸网络攻击"><a href="#僵尸网络攻击" class="headerlink" title="僵尸网络攻击"></a>僵尸网络攻击</h2><p>僵尸网络是指大量被命令与控制（C&amp;C）服务器所控制的互联网主机群。攻击者传播恶意软件并组成自己的僵尸网络。僵尸网络难于检测的原因是，僵尸主机只有在执行特定指令时才会与服务器进行通讯，使得它们隐蔽且不易察觉。僵尸网络根据网络通讯协议的不同分为IRC、HTTP或P2P类等。</p><h2 id="应用程序级洪水攻击（Application-level-floods）"><a href="#应用程序级洪水攻击（Application-level-floods）" class="headerlink" title="应用程序级洪水攻击（Application level floods）"></a>应用程序级洪水攻击（Application level floods）</h2><p>与前面叙说的攻击方式不同，应用程序级洪水攻击主要是针对应用软件层的，也就是高于OSI的。它同样是以大量消耗系统资源为目的，通过向IIS这样的网络服务程序提出无节制的资源申请来破坏正常的网络服务。</p><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><p>拒绝服务攻击的防御方式通常为入侵检测，流量过滤和多重验证，旨在堵塞网络带宽的流量将被过滤，而正常的流量可正常通过。</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙可以设置规则，例如允许或拒绝特定通讯协议，端口或IP地址。当攻击从少数不正常的IP地址发出时，可以简单的使用拒绝规则阻止一切从攻击源IP发出的通信。</p><p>复杂攻击难以用简单规则来阻止，例如80端口（网页服务）遭受攻击时不可能拒绝端口所有的通信，因为其同时会阻止合法流量。此外，防火墙可能处于网络架构中过后的位置，路由器可能在恶意流量达到防火墙前即被攻击影响。然而，防火墙能有效地防止用户从启动防火墙后的计算机发起攻击。<br>交换机<br>大多数交换机有一定的速度限制和访问控制能力。有些交换机提供自动速度限制、流量整形、后期连接、深度包检测和假IP过滤功能，可以检测并过滤拒绝服务攻击。例如SYN洪水攻击可以通过后期连接加以预防。基于内容的攻击可以利用深度包检测阻止。</p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>和交换机类似，路由器也有一定的速度限制和访问控制能力，而大多数路由器很容易受到攻击影响。<br>黑洞引导<br>黑洞引导指将所有受攻击计算机的通信全部发送至一个“黑洞”（空接口或不存在的计算机地址）或者有足够能力处理洪流的网络设备商，以避免网络受到较大影响。</p><h2 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h2><p>当流量被送到DDoS防护清洗中心时，通过采用抗DDoS软件处理，将正常流量和恶意流量区分开。正常的流量则回注回客户网站。这样一来可站点能够保持正常的运作，处理真实用户访问网站带来的合法流量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>拒绝服务攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】费曼学习法</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><p>费曼学习法是由加拿大物理学家费曼所发明的一种高效的学习方法，费曼本身是一个天才，13 岁自学微积分，24 岁加入曼哈顿计划（核武器计划）；而 Google 创始人谢尔盖布林都在使用的学习方法，比尔盖茨、乔布斯、拉里佩奇都是费曼学习法的拥戴者。</p><p>什么是费曼学习法<br>费曼学习法的灵感源于诺贝尔物理奖获得者理查德•费曼（Richard Feynman），运用费曼技巧,你只需花上20分钟就能深入理解知识点,而且记忆深刻,难以遗忘。知识有两种类型，我们绝大多数人关注的都是错误的那类。第一类知识注重了解某个事物的名称。第二类知识注重了解某件事物。这可不是一回事儿。著名的诺贝尔物理学家理查德·费曼（Richard Feynman）能够理解这二者间的差别，这也是他成功最重要的原因之一。事实上，他创造了一种学习方法，确保他会比别人对事物了解的更透彻。<br><img src="https://www.go176.net/content/uploadfile/202003/7a371583800983.png" alt="sea"><br>费曼学习法可以简化为四个单词：Concept （概念）、Teach （教给别人）、Review （评价）、Simplify （简化）。</p><p>费曼学习法的四个步骤<br>该技巧主要包含四步：</p><h5 id="第一步：把它教给一个小孩子。"><a href="#第一步：把它教给一个小孩子。" class="headerlink" title="第一步：把它教给一个小孩子。"></a>第一步：把它教给一个小孩子。</h5><p>拿出一张白纸，在上方写下你想要学习的主题。想一下，如果你要把它教给一个孩子，你会讲哪些，并写下来。这里你的教授对象不是你自己那些聪明的成年朋友，而是一个8岁的孩子，他的词汇量和注意力刚好能够理解基本概念和关系。</p><p>许多人会倾向于使用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们只在糊弄自己，因为我们不知道自己也不明白。另外，使用行话会隐藏周围人对我们的误解。</p><p>当你自始至终都用孩子可以理解的简单的语言写出一个想法（提示：只用最常见的单词），那么你便迫使自己在更深层次上理解了该概念，并简化了观点之间的关系和联系。如果你努力，就会清楚地知道自己在哪里还有不明白的地方。这种紧张状态很好——预示着学习的机会到来了。</p><h5 id="第二步：回顾。"><a href="#第二步：回顾。" class="headerlink" title="第二步：回顾。"></a>第二步：回顾。</h5><p>在第一步中，你不可避免地会卡壳，忘记重要的点，不能解释，或者说不能将重要的概念联系起来。</p><p>这一反馈相当宝贵，因为你已经发现了自己知识的边缘。懂得自己能力的界限也是一种能力，你刚刚就确定了一个！</p><p>这是学习开始的地方。现在你知道自己在哪里卡住了，那么就回到原始材料，重新学习，直到你可以用基本的术语解释这一概念。</p><p>认定自己知识的界限，会限制你可能犯的错误，并且在应用该知识时，可以增加成功的几率。</p><h5 id="第三步：将语言条理化，简化。"><a href="#第三步：将语言条理化，简化。" class="headerlink" title="第三步：将语言条理化，简化。"></a>第三步：将语言条理化，简化。</h5><p>现在你手上有一套自己手写笔记，检查一下确保自己没有从原材料中借用任何行话。将这些笔记用简单的语言组织成一个流畅的故事。</p><p>将这个故事大声读出来，如果这些解释不够简单，或者听起来比较混乱，很好，这意味着你想要理解该领域，还需要做一些工作。</p><h5 id="第四步（可选）：传授"><a href="#第四步（可选）：传授" class="headerlink" title="第四步（可选）：传授"></a>第四步（可选）：传授</h5><p>如果你真的想确保你的理解没什么问题，就把它教给另一个人（理想状态下，这个人应该对这个话题知之甚少，或者就找个 8 岁的孩子）。检测知识最终的途径是你能有能力把它传播给另一个人。</p><p>这不仅是学习的妙方，还是窥探不同思维方式的窗口，它让你将想法撕开揉碎，从头重组。这种学习方法会让你对观点和概念有更为深入的理解。重要的是，以这种方式解决问题，你可以在别人不知道他们自己在说什么的情况下，理解这个问题。</p><p>费曼的方法直观地认为智力是一个增长的过程，这与 Carol Dweck 的研究非常吻合，Carol Dweck 精确地描述了停滞型思维（fixed mindset）和成长型思维（growth mindset）之间的区别。</p>]]></content>
    
    
    
    <tags>
      
      <tag>费曼学习法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】罗森塔尔效应</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E7%BD%97%E6%A3%AE%E5%A1%94%E5%B0%94%E6%95%88%E5%BA%94/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E7%BD%97%E6%A3%AE%E5%A1%94%E5%B0%94%E6%95%88%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.go176.net/content/uploadfile/202002/4a471581975716.png" alt="sea"><br>皮格马利翁效应，又称毕马龙效应、罗森塔尔效应或期待效应，是指人（通常是指孩童或学生）在被赋予更高期望以后，他们会表现的更好的一种现象。</p><p>皮格马利翁效应的命名取自希腊神话故事里面的一位名为皮格马利翁的雕刻家，他爱上了自己用象牙雕刻出来的女神雕像，由于他每天对着雕像说话，最后那座女神雕像变成一位真正的女神。皮格马利翁效应是一个自我应验预言发展。</p><p>以此观点，内心常常带着负面期望的人们将会失败；而内心常常带着正面期望的人们将会成功。在社会学，这个效应经常被引用与教育或社会阶级有关。</p><h4 id="罗森塔尔效应实验"><a href="#罗森塔尔效应实验" class="headerlink" title="罗森塔尔效应实验"></a>罗森塔尔效应实验</h4><p>罗森塔尔效应实验发生在1968年，罗森塔尔带助手们来到一所乡村小学，从一到六年级各选了三个班，对这18个班的学生进行了一个未来发展趋势测验，测验结束之后，他把一份最有发展前途者的名单给了方，并且还叮嘱他们要保密啊，免得影响实验的正确性。这个名单占了学生总数的20%，但其实校长和学生们都不知道的是，这份名单上的学生都是随机挑选的，罗森塔尔根本就没有去看这个测验的成绩，唉，奇妙的是8个月之后情况果然有一些变化，在针对这18个班学生的测验中发现上了名单的那部分学生，成绩普遍有了显著的提高，而且性格更外向，自信心和求知欲都变得更强烈了，面对这个结果，罗森塔尔提出了一个词叫做权威性谎言，他认为他对于校方来说是权威，而校方对于学生来说也是权威，将你最有发展前途的这句谎言传递到那些作为实验对象的学生身上，最终这些学生果然变成了这样的人啊有意思的事，这些学生并没有得到明确的语言信息来告知自己是最有发展前途的人，是老师们通过情绪和态度影响了他们。</p><h4 id="权威性作用"><a href="#权威性作用" class="headerlink" title="权威性作用"></a>权威性作用</h4><p>在罗森塔尔的实验中都是权威的期待发挥了力量，那么什么是权威呢，就是有权利有威望有资源的那一方，饲养员对小白鼠有巨大权威，因为他们可以决定小白鼠的饮食甚至是生死，而在学校实验里，校长和老师对学生有巨大权威，因为他们可以评判一个学生的资质。</p><h4 id="罗森塔尔和雅各布森的研究"><a href="#罗森塔尔和雅各布森的研究" class="headerlink" title="罗森塔尔和雅各布森的研究"></a>罗森塔尔和雅各布森的研究</h4><p>美国心理学家罗伯特·罗森塔尔，与雷诺尔·雅各布森对皮格马利翁效应做篇幅的发表和讨论。在他们的研究中发现，假使老师对学生的期望加强，学生的表现也会相对加强。也正是因为罗森塔尔对该效应在小学教学上予以验证提出，皮格马利翁效应也被称为“罗森塔尔效应”。</p><p>这个实验的目地是用来支持现实层面是可以受到他人的期望而影响的假设。这种影响是有效的，主要是单看给予特定的个人正面或负面的期望。</p><p>观察者期望效应，在真实生活中，被观察者无察觉的情况下给与期望，并观察结果。罗森塔尔断言这样的期望可以实质上去影响并且完成自我实现的预言。</p><p>在这个实验中，罗森塔尔预测当告诉一位小学老师某几位学生比其他学生聪明，这位老师可能会潜意识去帮助和鼓励这几位学生成功。1911年由一位心理学家所做名为聪明的汉斯的实验指出表面上看起来有一匹懂得算术和做出各式各样惊奇技能的马，事实上是靠训练员和观察者无意识下给予的暗示（例如：表情、姿势）而得出正确答案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>罗森塔尔效应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】奶头乐理论</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E5%A5%B6%E5%A4%B4%E4%B9%90%E7%90%86%E8%AE%BA/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E5%A5%B6%E5%A4%B4%E4%B9%90%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="奶头乐理论"><a href="#奶头乐理论" class="headerlink" title="奶头乐理论"></a>奶头乐理论</h2><p>奶头乐（英语：tittytainment），又译为奶头娱乐或奶嘴娱乐，是一个合成词，来自于英文「titty」（奶头）与「entertainment」（娱乐 ）两词的组合<br>据称是由美国前国家安全顾问布热津斯基创造的，特别泛指那一类能让人着迷、又低成本、能够使人满足的低俗娱乐内容。 用来描述一个设想：由于生产力的不断上升，世界上的一大部分人口将会不用也无法积极参与产品和服务的生产。 为了安慰这些人，他们的生活应该被大量的娱乐活动（比如网络、电视和游戏）填满。 社会动荡的主要因素之一是阶层之间的利益冲突。 那要如何避免少数得益者与大多数的底层人民间的冲突呢？<br>方法之(一)是给其「奶头」，转移其注意力和不满情绪，让他们更能接受自己的境遇。 可以通过观察社会现象而窥探一;<br>方法之(二)，主要表现在媒体的泛娱乐化、大众对于娱乐和游戏产业的高度关注和追随等。</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容:"></a>内容:</h4><p>政府通常会对有争议的内容实施管控，然而在奶头娱乐的体制中，只要不会撼动利益，就可以见到其对于低俗内容的放松，尽管有些夸张，但是确实指出贫富分化的差距。 最基本例如发泄型娱乐：开放色情产业、热闹选战造势、无休止的口水战、暴力网络游戏。 或者是如满足型，报导无聊小事（可爱动物、明星丑闻）、廉价品牌横行（自产品牌或引进山寨手机、白牌服饰）、商品优惠活动（例如饰品、旅游签证）、视听娱乐大众化（偶像剧、动画、好莱坞）等。 这类娱乐十分受欢迎，由于生活辛苦的大众对于此需求有所提升，使得不知不觉中，自然发生他们乐不思蜀、丧失思考能力。 因此社会对于不正统的通俗文化也就变得十分宽容。 而商人、政府高层们也乐见其成，透过如同一般民众「吸奶头」的方式，使社会中下阶层着迷其中、而无心挑战现有的统治阶级。 奶头乐一方面也是社会压力大的反照。 尽管如此，许多娱乐发达的国家，人民也是乐在其中而不反思。</p><p>会发生上述结果则在于全球化世界会导致贫富差距快速拉大，80%（以上）的人将落入失败方且无任何方法避免此一结果，处置边缘化人口的最佳办法只有「围堵」（containment）。 要使全球80%“边缘化”的人安分守己，20%搭上全球化快车的人可以高枕无忧，就需要采取对色情宽容、麻醉除罪化、放宽交通违规、枪枝泛滥等用低成本半满足的办法，解除被“边缘化”的人的精力与不满情绪。 </p><h4 id="奶头乐理论的前提："><a href="#奶头乐理论的前提：" class="headerlink" title="奶头乐理论的前提："></a>奶头乐理论的前提：</h4><p>社会动荡的主要因素之一是阶层之间的利益冲突。</p><h4 id="奶头乐理论的描述："><a href="#奶头乐理论的描述：" class="headerlink" title="奶头乐理论的描述："></a>奶头乐理论的描述：</h4><p>由于生产力的不断上升，世界上的一大部分人口将不必也无法积极参与产品和服务的生产。为了安慰这些“被遗弃”的人，避免阶级冲突，方法之一就是制造“奶头”、喂之以“奶头”——使令人陶醉的消遺娱乐和充满感官刺激的产品（比如网络、电视和游戏）填满人们的生活、转移其注意力和不满情绪，令其沉浸在“快乐”中不知不觉丧失思考能力、无心挑战现有的统治阶级。</p><h4 id="“奶头”的形式有两种："><a href="#“奶头”的形式有两种：" class="headerlink" title="“奶头”的形式有两种："></a>“奶头”的形式有两种：</h4><p>一种是发泄性娱乐，比如开放色情行业、鼓励暴力网络游戏、鼓动口水战；</p><p>一种是满足性游戏，比如拍摄大量的肥皂剧和偶像剧，大量报道明星丑闻，播放真人秀等大众娱乐节目。<br>奶头乐理论的来源<br>这一概念来自美国前总统国家安全事务助理布热津斯基。</p><p>美国旧金山曾于1995年举行过一个集合全球500名经济界、政治界精英的会议，与会者包括萨切尔、老布什、美国有线电视新闻网（CNN）、惠普、Sun微系统的老板等等，该会议的主旨在于为全球化的世界进行分析与规划。会议上，与会者一致认为全球化的高度、快速、激烈的竞争将使全球80%人口”边缘化”，而这80%“边缘化”人口与20%搭上全球化快车的人口之间的冲突将成为今后的主要问题。</p><p>在此基础上，Sun微系统的老板格基表示，届时将是一个“要么吃人、要么被吃”的世界。布热津斯基也及时献计献策，创造了一个新词汇——tittytainment“奶头乐”，英文titty“奶头”与entertainment “娱乐”的组合，意指要使彼80%的人安分守己，此20%的人高枕无忧，就得采取温情、麻醉、低成本、半满足的办法卸除“边缘化人口”的不满。</p><p>奶头乐理论在中国<br>在中国，更适合Titty Tainment的翻译或许是“肥宅乐”，“肥宅”是一群只满足于待在家中，用电子游戏、虚拟社交或者膨化食品、碳酸饮料麻痹自己的人，他们抵触现实社交与工作，宁愿一个人孤独终老。大多集中在20-30岁的年轻群体。</p><p>注意：奶头乐理论存在争议，请中立、平和看待；争议例如：<a href="https://www.huxiu.com/article/262614.html">https://www.huxiu.com/article/262614.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】社会工程学</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h2><p>社会工程学（Social Engineering，又被翻译为：社交工程学；在网络上也被称之为 社工、人肉）在上世纪60年代左右作为正式的学科出现，历史上，社会工程学是隶属于社会学，不过其影响他人心理的效果引起了计算机安全专家的注意。</p><p>在计算机科学中，社会工程学指的是通过与他人的合法地交流，来使其心理受到影响，做出某些动作或者是透露一些机密信息的方式。这通常被认为是一种欺诈他人以收集信息、行骗和入侵计算机系统的行为。这一行为一般是被认作侵犯隐私权的。</p><p>而在网络中，大多为已收集信息，并且对信息 理解、猜测、黑客等手段进行达到某种目的;其中也可以对于相关关系进行交流已套取信息。<br>目前，安全行业已对“高级用户”增加社会工程学，社会工程学越来越行业化。<br>有关电影：<br><img src="https://www.go176.net/content/uploadfile/202002/f4741581253105.jpg" alt="sea"><br>特别人物：</p><p>美国前头号黑客凯文·米特尼克被认为是社会工程学的大师和开山鼻祖，著有安全著作《欺骗的艺术》。<br><img src="https://www.go176.net/content/uploadfile/202002/c32a1581253255.jpg" alt="sea"><br>《反欺骗的艺术》中曾提到，人为因素才是安全的软肋。很多企业、公司在信息安全上投入大量的资金，最终导致数据泄露的原因，往往却是发生在人本身。你们可能永远都想象不到，对于黑客们来说，通过一个用户名、一串数字、一串英文代码，社会工程师就可以通过这么几条的线索，通过社工攻击手段，加以筛选、整理，就能把你的所有个人情况信息、家庭状况、兴趣爱好、婚姻状况、你在网上留下的一切痕迹等个人信息全部掌握得一清二楚。虽然这个可能是最不起眼，而且还是最麻烦的方法。一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。</p><p>内容摘自：百度百科、维基百科因为内容实时性，保留较为永久内容；如果发现不妥请联系<a href="mailto:&#50;&#x30;&#50;&#49;&#x36;&#x37;&#50;&#x38;&#x39;&#x38;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#50;&#x30;&#50;&#49;&#x36;&#x37;&#50;&#x38;&#x39;&#x38;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>社会工程学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】DNS over TLS</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91DNS-over-TLS/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91DNS-over-TLS/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS-over-TLS"><a href="#DNS-over-TLS" class="headerlink" title="DNS over TLS"></a>DNS over TLS</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2016年，RFC添加了DNS-over-TLS的标准，正式提出了DNS报文明文导致隐私问题。DNS-over-TLS，顾名思义类似于HTTP-over-TLS（HTTPS）。因此DNS-over-TLS其实就是“DNSS”，一种基于TLS来进行报文加密的DNS请求交互。区别于DNS传统的安全扩展标准DNSSEC，DNS-over-TLS更侧重于DNS交互报文的加密性，而DNSSEC更侧重于DNS交互报文的完整一致性。<br>RFC7858提出了DNS隐私的相关问题：</p><p>Prior work has addressed some aspects of DNS security, but until<br>recently, there has been little work on privacy between a DNS<br>client and server.</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DNS over TLS  是一项安全协议，它可以强制所有和DNS服务器相关的链接使用TLS。也就是说他可以让ISP（即DNS提供商）无法窥探访问数据信息。</p><h4 id="什么是DNS-over-TLS？"><a href="#什么是DNS-over-TLS？" class="headerlink" title="什么是DNS over TLS？"></a>什么是DNS over TLS？</h4><p>TLS（传输层安全协议）的前身为SSL（安全套接层），从SSL3.0开始全面升级为TLS。TLS用于在两个通信应用程序之间提供保密性和数据完整性，最著名的用途即我们常见的HTTPS。<br><img src="https://www.go176.net/content/uploadfile/202011/d49d1605938542.jpg" alt="sea"><br>整个TLS传输的过程如下：<br>(1）TCP三次握手<br>(2）SSL的ClientHello和ServerHello和对应的秘钥交换KeyExchange<br>(3）Client和Server互相ChangeCipherSpec通知进入加密模式，此时可以进入数据传输状态<br>(4）应用数据传输过程<br>(5）应用数据传输完成，TCP两次挥手<br>抛开TCP连接和数据包文传输的部分，TLS握手部分将使用2个RTT。</p><p>因此，从RFC文档来看，DNS-over-TLS和HTTPS类似，使用了 TCP 853 作为传输端口来完成TLS握手，再执行普通的DNS请求/应答。因此在DNS-over-TLS的整个过程中，将使用至少4次RTT，这也将导致DNS的查询延时放大4倍。</p><p>DNS-over-TLS在技术上并没有特别领先的概念，只是把相对通用的传输层TLS协议用在了DNS上，这样做确实确保了数据的加密和一致性，但是对于DNS的性能也带来了很大的挑战。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DNS over TLS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一知】数据中心安全</title>
    <link href="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%AE%89%E5%85%A8/"/>
    <url>/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E7%9F%A5%E3%80%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="数据中心安全"><a href="#数据中心安全" class="headerlink" title="数据中心安全"></a>数据中心安全</h2><p><img src="https://www.go176.net/content/uploadfile/202101/7bfa1610436357.webp" alt="sea"><br>数据中心安全用于保护数据中心免受外部威胁和攻击的物理措施和软件防护技术。</p><p>数据中心是存储IT基础设施的设施，由网络服务器和存储组成，用于处理和存储大量数据。数据中心可以降低运行自己的集中式计算网络和服务器的成本。<br>数据中心提供数据存储、备份和恢复、数据管理和网络等服务。由于数据中心保存着敏感或专有信息，因此需要物理上保证安全。</p><p>如何保护数据中心的安全<br>数据中心是复杂的，其安全可以分为物理安全和软件安全。<br>物理安全包括用于防止外部干扰流程及策略。<br>软件安全为了防止网络犯罪分子通过绕过防火墙、破解密码或通过其他漏洞进入网络。</p><p>物理安全<br>数据中心大楼最明显的安全特征与设计和布局有关。<br>数据中心建筑通常建在远离主要道路的地方，以建立由景观和防撞屏障组合而成的缓冲区。<br>进入数据中心设施的通道相当有限。大多数据中心没有外窗。<br>大楼内的保安人员利用安装在的监控摄像头的录像监控。访客可以使用双因素认证进入大楼，包括扫描个人身份验证卡（PIV）和输入个人密码。也可使用员工胸牌阅读器和生物识别系统，如指纹阅读器、虹膜扫描器和面部识别系统，以允许访客进入大楼。</p><p>软件安全<br>安全信息和事件管理工具(SIEM)可提供数据中心安全态势的实时视图。SIEM有助于提供从访问和报警系统以及周边围栏上的传感器等一切的可视性和控制。<br>在网络中创建安全区域是将安全分层到数据中心的一种方法。</p><p>管理员可以将网络划分为三个区域：具有很大灵活性的测试区、环境稍显严格的开发区和只允许生产设备的生产区。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据中心安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StrokesPlu鼠标手势 安装版&amp;便携版</title>
    <link href="/2021/01/30/StrokesPlu%E9%BC%A0%E6%A0%87%E6%89%8B%E5%8A%BF-%E5%AE%89%E8%A3%85%E7%89%88-%E4%BE%BF%E6%90%BA%E7%89%88/"/>
    <url>/2021/01/30/StrokesPlu%E9%BC%A0%E6%A0%87%E6%89%8B%E5%8A%BF-%E5%AE%89%E8%A3%85%E7%89%88-%E4%BE%BF%E6%90%BA%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="StrokesPlu鼠标手势-安装版-amp-便携版"><a href="#StrokesPlu鼠标手势-安装版-amp-便携版" class="headerlink" title="StrokesPlu鼠标手势 安装版&amp;便携版"></a>StrokesPlu鼠标手势 安装版&amp;便携版</h2><p><img src="https://www.shanezy.com/uploads/allimg/201123/1606100084303199.jpg" alt="sea"><br>更新日志</p><p>-在内部参数列表中添加了stopIssued和floater以将其从Loop Step参数中隐藏</p><p>-更新了DisplayChange / reload逻辑，以在显示更改完成后重新挂钩WinEventHook</p><p>修复S +无法正确重新启用自身的问题</p><p>-修复了ExecutePreviousScript的错字导致其无法正常工作的情况</p><p>-修复了历史记录脚本匹配正则表达式</p><p>-更新了内部类可见性</p><p>-添加日语翻译（尚未完成）</p><h2 id="下载链接奉上："><a href="#下载链接奉上：" class="headerlink" title="下载链接奉上："></a>下载链接奉上：</h2><p><a href="https://seapit.lanzous.com/iLsRnl3sk3a">https://seapit.lanzous.com/iLsRnl3sk3a</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优启通 EasyU v3.6.2020.1111 VIP无广告版</title>
    <link href="/2021/01/30/%E4%BC%98%E5%90%AF%E9%80%9A-EasyU-v3-6-2020-1111-VIP%E6%97%A0%E5%B9%BF%E5%91%8A%E7%89%88/"/>
    <url>/2021/01/30/%E4%BC%98%E5%90%AF%E9%80%9A-EasyU-v3-6-2020-1111-VIP%E6%97%A0%E5%B9%BF%E5%91%8A%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优启通-EasyU-v3-6-2020-1111-VIP无广告版"><a href="#优启通-EasyU-v3-6-2020-1111-VIP无广告版" class="headerlink" title="优启通 EasyU v3.6.2020.1111 VIP无广告版"></a>优启通 EasyU v3.6.2020.1111 VIP无广告版</h2><p>优启通（EasyU，简称EU）是IT天空打造的一款专业U盘启动盘制作工具，采用U盘三分区方案，支持BIOS（Legacy）与UEFI双启动模式，在支持主流硬件基础上，同时兼容早期多数旧硬件。整合各种装机必备工具，并结合IT天空数款自研软件，有效提高系统安装效率。U盘PE所在分区于系统下自动隐藏，PE区与数据区分别独立，便于使用者对数据的各项操作。优启通定位于一线装机技术员、系统工程师和系统维护人员。<br><img src="https://www.shanezy.com/uploads/allimg/201217/1608199782764873.png" alt="sea"><br><img src="https://www.shanezy.com/uploads/allimg/201217/1608199785111202.png" alt="sea"><br><img src="https://www.shanezy.com/uploads/allimg/201217/1608199789719851.png" alt="sea"><br>优启通简要说明</p><p>（1）U盘模式：一键全新制作，支持免格升级、UD/EFI分区（可选PETools/Dlc扩展包）、个性化启动菜单、模拟测试；</p><p>（2）本地模式：将PE写入当前系统盘符，可选支持BLOS/UEFI引导、可选安装PETools/Dlc扩展包</p><p>（3）生成ISO：生成PE的ISO镜像，可用于量产、虚拟机等；可选UDF格式/PETools/Dlc扩展包，可选引导菜单样式；</p><p>（4）分区管理：这是个辅助功能，用于检查及修复U盘，创建磁盘分区操作、文件信息，如：UD区信息，安装信息等；</p><p>（5）高级选项：UD/EFI分区、本地模式、ISO-BLOS/EFI、Win2003PE/Win10PE、各种加载命令、磁盘检测模式等；</p><h2 id="最后下载链接奉上："><a href="#最后下载链接奉上：" class="headerlink" title="最后下载链接奉上："></a>最后下载链接奉上：</h2><p>链接: <a href="https://pan.baidu.com/s/1AIvcqH9oARUOaUTDhxniDQ">https://pan.baidu.com/s/1AIvcqH9oARUOaUTDhxniDQ</a> 提取码: 5zyi</p>]]></content>
    
    
    
    <tags>
      
      <tag>系统工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinHex v20.1绿色单文件版</title>
    <link href="/2021/01/30/WinHex-v20-1%E7%BB%BF%E8%89%B2%E5%8D%95%E6%96%87%E4%BB%B6%E7%89%88/"/>
    <url>/2021/01/30/WinHex-v20-1%E7%BB%BF%E8%89%B2%E5%8D%95%E6%96%87%E4%BB%B6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="inHex-v20-1绿色单文件"><a href="#inHex-v20-1绿色单文件" class="headerlink" title="inHex-v20-1绿色单文件"></a>inHex-v20-1绿色单文件</h1><p>X-Ways WinHex，全球知名的计算机取证及数据恢复软件，十六进制编辑器和磁盘编辑器。这款专业十六进制编辑器，用于取证搜集、数据恢复、文件分析和编辑、底层数据处理和安全领域收集文件报告。使用它可以检查修复各种文件、硬盘及内存卡等损坏造成的数据丢失等问题，编辑修改Hex与ASCII编码，多文件搜索与替换，磁盘扇区 (支持FAT16、FAT32和NTFS）自动搜索编辑，文件比对和分析，RAM编辑工具等。<br><img src="https://www.shanezy.com/uploads/allimg/210125/1611545884825222.png" alt="sea"><br><img src="https://www.shanezy.com/uploads/allimg/210125/1611545887701707.png" alt="sea"><br>版本特点</p><p>反汇编处理，解锁专家版，集成注册信息，专业工具可用</p><p>补充翻译了简体中文语言，删除多国语言文件及帮助文档</p><p>预设配置，默认启动简体中文，重置选项临时路径</p><p>7zSFX手工打包，支持传递参数，可拖拽打开文件</p><p>单文件多开时可以创建互斥，避免重复解压和误删</p><h2 id="下载链接奉上："><a href="#下载链接奉上：" class="headerlink" title="下载链接奉上："></a>下载链接奉上：</h2><p><a href="https://seapit.lanzous.com/iW8gjl3sahe">https://seapit.lanzous.com/iW8gjl3sahe</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>应用软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Passper for PDF v3.6.1.1</title>
    <link href="/2021/01/30/Passper-for-PDF-v3-6-1-1/"/>
    <url>/2021/01/30/Passper-for-PDF-v3-6-1-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Passper-for-PDF-v3-6-1-1"><a href="#Passper-for-PDF-v3-6-1-1" class="headerlink" title="Passper for PDF v3.6.1.1"></a>Passper for PDF v3.6.1.1</h1><p>Passper for PDF 是国外Passper团队开发的一款PDF文件密码破解恢复和去除限制工具，只需要简单的操作步骤，软件会使用高级算法高速破解PDF文件密码，涵盖所有类型的密码保护。<br><img src="https://www.shanezy.com/uploads/allimg/210129/1611900133702548.gif" alt="sea"><br><img src="https://www.shanezy.com/uploads/allimg/210129/1611900136333317.png" alt="sea"><br>软件特点</p><p>4种破解方法，成功恢复PDF文件</p><p>组合破解 字典破解将尝试列表上所有字符的组合，直到找到您的密码为止。Passper提供了默认词典。</p><p>字典破解 尝试选择所有字符组合以找到正确的密码。</p><p>掩码破解 如果您知道一些有关密码的信息，则使用掩码破解可以非常快速地恢复密码。</p><p>暴力破解 暴力破解会尝试所有字符的所有组合，直到找到您的密码。此方法需要更长的时间。</p><p>高效快速的一键去除PDF文件限制</p><p>成功率最高 通过智能算法，Passper可以恢复大多数加密的PDF文件的密码。</p><p>恢复速度快 基于CPU和GPU加速技术，Passper可以更快地恢复密码。</p><p>立即删除限制 只需1到2秒钟即可消除对PDF文件的限制。</p><p>保存恢复进度 您可以停止并保存进度，然后在下一次继续恢复密码。</p><p>使用方法</p><p>破解恢复密码</p><p>选择“恢复密码”：在主界面上单击“恢复密码”。</p><p>选择文件和恢复方法：添加受保护的文件，然后选择所需的恢复方法。</p><p>找回密码：软件会在屏幕上显示找到的密码。</p><p>删除去除限制</p><p>选择“删除限制”：点击主屏幕上的“删除限制”。</p><p>选择一个文件：导入要解锁的PDF文件。</p><p>删除对PDF文件的限制：解锁您的PDF文件将需要几秒钟。</p><h2 id="下载链接奉上："><a href="#下载链接奉上：" class="headerlink" title="下载链接奉上："></a>下载链接奉上：</h2><p><a href="https://seapit.lanzous.com/iYVM6l3s67a">https://seapit.lanzous.com/iYVM6l3s67a</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>应用软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uTools(效率工具集) v1.3.5</title>
    <link href="/2021/01/17/uTools-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E9%9B%86-v1-3-5/"/>
    <url>/2021/01/17/uTools-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E9%9B%86-v1-3-5/</url>
    
    <content type="html"><![CDATA[<h2 id="uTools-是什么？"><a href="#uTools-是什么？" class="headerlink" title="uTools 是什么？"></a>uTools 是什么？</h2><p>uTools 是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。<br><img src="https://u.tools/docs/assets/img/utools.6e9342c2.png" alt="sea"><br>通过快捷键（默认 alt + space ）就可以快速呼出这个搜索框。它相当聪明，你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，能够处理此内容的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。</p><p>一旦你熟悉它后，除了能够为你节约大量时间，不中断、无干扰，让你可以更加专注地改变世界。</p><h2 id="uTools-能做什么？"><a href="#uTools-能做什么？" class="headerlink" title="uTools 能做什么？"></a>uTools 能做什么？</h2><p>最简单的，uTools 可以作为一个程序快速启动器，支持英文、英文驼峰、中文拼音、拼音首字母来打开你的本地程序。除程序外， win10 和 macOS 用户还可以快速搜索并打开「控制面板」内的细项。总之，你只要还记得一个大概的名字，直接输入基本都能找到。<br>启动已安装的程序仅仅是最基础的功能，uTools 最大的特点就是拥有强大的插件系统。</p><p>现在已有 100+ 的插件供你选择，每个插件解决一个具体场景的问题，简洁美观、即用即走。</p><p>输入 插件中心 进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最称手的工具合集，为各种日常操作提供便利，不断产生的新插件，也将为你带来无限可能。<br><img src="https://u.tools/docs/assets/img/plugin1.8097c910.png" alt="sea"><br>可以通过鼠标右键/中键（可配置），快速打开 uTools 超级面板，uTools 会根据当前选择的内容（文本、截图、文件、文件夹）自动匹配已安装的插件供你选择。与平时使用右键类似的习惯，uTools 超级面板却能为你带来完全不一样的内容及体验。</p><h1 id="非常推荐！！"><a href="#非常推荐！！" class="headerlink" title="非常推荐！！"></a>非常推荐！！</h1><h2 id="最后下载链接奉上："><a href="#最后下载链接奉上：" class="headerlink" title="最后下载链接奉上："></a>最后下载链接奉上：</h2><p><a href="https://seapit.lanzous.com/iYBpFkibk2b">https://seapit.lanzous.com/iYBpFkibk2b</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷歌seabox魔改插件原作者大侠</title>
    <link href="/2021/01/17/%E8%B0%B7%E6%AD%8Cseabox%E9%AD%94%E6%94%B9%E6%8F%92%E4%BB%B6%E5%8E%9F%E4%BD%9C%E8%80%85%E5%A4%A7%E4%BE%A0/"/>
    <url>/2021/01/17/%E8%B0%B7%E6%AD%8Cseabox%E9%AD%94%E6%94%B9%E6%8F%92%E4%BB%B6%E5%8E%9F%E4%BD%9C%E8%80%85%E5%A4%A7%E4%BE%A0/</url>
    
    <content type="html"><![CDATA[<p>如今，几乎所有的影视都需要vip才能观看，甚至还有一些是需要vip再次进行购买才能免费观看，非常的烦人，为此小编带来了一款超级实用的浏览器插件：sea助手，有了它，你就可以免费观看各大平台的蓝光影视，且完全不需要登录，非常方便。该插件与市面上其他的解析插件不同的是，自动免除了广告，且所有影视都是蓝光资源，画质绝佳，不仅支持企鹅视频、爱奇艺、芒果、优酷等所有VIP视频观看，还能够支持多家浏览器进行安装，喜欢追剧的小伙伴们还在等什么呢，快快下载使用起来吧。<br>支持企鹅视频、爱奇艺、芒果、优酷所有VIP视频观看<br>支持多家浏览器安装插件 最合适是谷歌浏览器<br>不需要登陆，直接打开客户端选择播放即可<br>支持超多平台自动免除广告和去VIP播放视频<br>使用方法<br><img src="https://www.kjsv.com/download/image/2021/01/16/20210116231704_575455.jpg" alt="sea"><br>等到拓展程序和右上角显示了图标就说明插件安装成功了；<br>提示：其他浏览器也是同理<br>打开视频网站，如腾讯视频，找到想看的资源，选择Vip集数，不是会员则显示需要登录；<br><img src="https://www.kjsv.com/download/image/2021/01/16/20210116231807_236013.jpg" alt="sea"><br>点击右上角的图标或者切换几次VIP集数即可免费观看啦；<br>再以爱奇艺为例，同样的方式也可以免费观看Vip集数；<br>有需要的小伙伴们快来下载试试吧。</p><h2 id="下载链接奉上："><a href="#下载链接奉上：" class="headerlink" title="下载链接奉上："></a>下载链接奉上：</h2><p><a href="https://seapit.lanzous.com/ibKu5kiba9i">https://seapit.lanzous.com/ibKu5kiba9i</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>影音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓 WPS Office v12.9.0 解锁</title>
    <link href="/2021/01/17/%E5%AE%89%E5%8D%93-WPS-Office-v12-9-0-%E8%A7%A3%E9%94%81/"/>
    <url>/2021/01/17/%E5%AE%89%E5%8D%93-WPS-Office-v12-9-0-%E8%A7%A3%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>WPS Office for Android，金山WPS移动版，使用人数最多的移动办公软件套件。独有手机阅读模式，字体清晰翻页流畅；完美支持文字，表格，演示，PDF等51种文档格式；新版本具有海量精美模版及高级功能。<br><img src="https://www.qiyuzy.com/uploads/allimg/c201015/1602K3CbB50-13M9.jpg" alt="sea"><br>解锁高级版（注意：需要任意账户登陆才能解锁）</p><p>免广告，所有高级功能及在线高级模板免费用</p><p>PDF工具：PDF编辑、PDF签名、PDF提取等</p><p>PDF转Word、图片转PDF、保存为长图片</p><p>OCR、添加水印、合并文档、文档瘦身等</p><p>免升级，无检测升级弹窗（因为是谷歌版）</p><h2 id="下载地址奉上："><a href="#下载地址奉上：" class="headerlink" title="下载地址奉上："></a>下载地址奉上：</h2><p><a href="https://seapit.lanzous.com/ia3Tnkiaeyb">https://seapit.lanzous.com/ia3Tnkiaeyb</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>安卓玩机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI作文助手v1.0</title>
    <link href="/2021/01/17/AI%E4%BD%9C%E6%96%87%E5%8A%A9%E6%89%8Bv1-0/"/>
    <url>/2021/01/17/AI%E4%BD%9C%E6%96%87%E5%8A%A9%E6%89%8Bv1-0/</url>
    
    <content type="html"><![CDATA[<p>还在为写作开不了好头而烦恼吗？还在为没有素材写作而郁闷吗？还在为辅导孩子写作儿头痛吗？AI作文助手帮你快速找到对应素材金句，快速引导，告别写作难，开头难的问题。<br><img src="https://www.qiyuzy.com/uploads/allimg/c210116/1610P32KB120-11623.jpg" alt="sea"></p><h2 id="下载链接奉上："><a href="#下载链接奉上：" class="headerlink" title="下载链接奉上："></a>下载链接奉上：</h2><p><a href="https://seapit.lanzous.com/iIg8Okiadde">https://seapit.lanzous.com/iIg8Okiadde</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小妖精美化V5.4.1.1解锁vip</title>
    <link href="/2021/01/17/%E5%B0%8F%E5%A6%96%E7%B2%BE%E7%BE%8E%E5%8C%96V5-4-1-1%E8%A7%A3%E9%94%81vip/"/>
    <url>/2021/01/17/%E5%B0%8F%E5%A6%96%E7%B2%BE%E7%BE%8E%E5%8C%96V5-4-1-1%E8%A7%A3%E9%94%81vip/</url>
    
    <content type="html"><![CDATA[<p>软件介绍:</p><p>超级强大的手机个性美化APP DIY主题：手机桌面锁屏美化黑科技 倒计时：情侣恋爱纪念日、生日、高考中考 网名头像：个性名片表情包情侣个签 动态壁纸：超火素材资源 功能介绍手机桌面DIY黑科技 -随心定制主题桌面 -个性电量流光文字快捷图标消息歌词倒计时插件统统摆在桌面上 -超过500名专业美化作者都已入驻投稿，主题库资源丰富 *资料卡背景网名全套 -热门神器：支持一键生成套图素材 -增加扩列功能：作者投稿时可填扩列信息 *创意透明壁纸 -自己聊天背景主题自己定 *美化素材库 -几十万个头像壁纸素材，总有一款适合你！支持全局搜索，快速找到你要的头像壁纸 -提供精美头像，包括女生头像，男生头像，情侣头像，动漫头像，可爱头像，唯美头像，90后和00后更换头像 </p><p>特别说明:解锁VIP（手机登录，如果提示手机号未注册，请下载正版微信或QQ登录后绑定手机号码后在进行手机登录）<br><img src="https://www.ziyuanba.com/uploads/images/210109/1610191694909849.png" alt="sea"><br>最后</p><h2 id="下载地址奉上："><a href="#下载地址奉上：" class="headerlink" title="下载地址奉上："></a>下载地址奉上：</h2><p><a href="https://seapit.lanzous.com/iNszKkiabed">https://seapit.lanzous.com/iNszKkiabed</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicsArt美易照片编辑v15.9.57</title>
    <link href="/2021/01/17/PicsArt%E7%BE%8E%E6%98%93%E7%85%A7%E7%89%87%E7%BC%96%E8%BE%91v15-9-57/"/>
    <url>/2021/01/17/PicsArt%E7%BE%8E%E6%98%93%E7%85%A7%E7%89%87%E7%BC%96%E8%BE%91v15-9-57/</url>
    
    <content type="html"><![CDATA[<p>软件介绍:</p><p>PicsArt - Photo Studio是一款功能非常全面的图片处理软件。</p><p>特色亮点：</p><p>1、【PicsArt美易照片编辑】专为爱美图的你打造！全新体验的超火爆修图软件来啦，全球超过4.5亿次下载，3000多种编辑功能、特效和超过1000万个开源素材，更有多达300万个自由编辑社区贴纸，尽在PicsArt美易照片编辑。</p><p>场景相机、百款滤镜、花式拼图、手绘合成，让你的朋友圈为之惊叹，爱到停不下来。</p><p>2、【全面的编辑功能】汇集千种编辑功能，我的强大超乎你想象。</p><p>3、【细致的局部调节】所有工具都可以用画笔和橡皮擦进行局部调节。</p><p>4、【新颖的双重曝光功能】两个画面，一个世界，统统融为一体。</p><p>5、【随心所欲的场景相机】自由选择场景+装饰品+潮流贴纸，随手拍大片。</p><p>6、【数目众多的贴纸&amp;贴纸自制工具】拥有超过300万个自由编辑社区贴纸，简单几步就可以创造出个性贴纸。 </p><p>7、【创意多多的图片拼接】数百万个免费模板尽情使用，给你带来创作新灵感。</p><p>只要脑洞够大，这里就是你的舞台，我们不仅有颜值，还有才华和创意！还在等什么？</p><p>立即下载并创建一张巨作吧。 </p><p>软件功能：</p><p>1、图片编辑器：拼贴，框架，贴纸，文字特效，剪贴画图形，裁剪，旋转，调整颜色和添加艺术效果；</p><p>2、魔法效果：如Stenciler，Cartoonizer，草绘，奥顿，LOMO，复古，跨进程，HDR，法塔勒，铅笔，Holgaart和更多的艺术照片；</p><p>3、绘画功能：许多绘图效果，绘制贴纸模式，标注，艺术画笔和文字样式！画上你的Facebook朋友的照片，并与世界分享您的作品。</p><p>特别说明:</p><p>解锁VIP会员</p><p>去除登录<br><img src="https://www.ziyuanba.com/uploads/images/210116/1610783870758988.png" alt="sea"></p><h2 id="下载地址奉上："><a href="#下载地址奉上：" class="headerlink" title="下载地址奉上："></a>下载地址奉上：</h2><p><a href="https://seapit.lanzous.com/ib2IKkia7yj">https://seapit.lanzous.com/ib2IKkia7yj</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ps软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES文件浏览</title>
    <link href="/2021/01/17/ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88/"/>
    <url>/2021/01/17/ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ES文件浏览器v4-2-4-2解锁VIP版"><a href="#ES文件浏览器v4-2-4-2解锁VIP版" class="headerlink" title="ES文件浏览器v4.2.4.2解锁VIP版"></a>ES文件浏览器v4.2.4.2解锁VIP版</h1><p><img src="https://www.678cn.com/content/uploadfile/202101/c8691610343502.png" alt="sea"><br>ES文件浏览器（ES File Explorer File Manager）号称安卓第一文件管理器，全球下载次数超过3亿次。它是功能强大本地和网络文件管理器，想更方便的管理你的手机、平板、电脑和网盘？点击就能播放音乐，点击就能播放视频、查看图片、阅读文档、安装应用、查看压缩、进行搜索、还有海量网盘空间存放数据。</p><p>新版特性</p><p>4pda.ru/forum/index.php?showtopic=138744</p><p>2020.01.15 v4.4.2.0</p><ul><li>自动备份功能增加了备份到SMB、FTP、WebDav的选项；</li></ul><p>近期更新：</p><ul><li>支持调用内置ES媒体播放器观看百度网盘视频</li><li>新增支持截图谷歌翻译</li><li>优化快速传输功能，支持使用ES iOS进行文件传输</li><li>解决无法通过QQ分享多个文件的问题</li><li>自动备份支持本地音视频/图片/文件夹备份到云端</li></ul><p>版本特点</p><ul><li>解锁永久VIP会员，无广告，免登陆，全部会员特权可用：<br>﹂无广告（启动广告、首页活动横幅、锁屏体验、赞助横幅）<br>﹂主题皮肤、首页侧边栏管理、高级文本编辑、隐藏系统文件；<br>﹂查看.nomedia、视频剪切、视频拼接、视频转GIF等等功能；</li></ul><p>by lfqy（没被百度收购前的旧版修改作者）<br>1、去除程序主页的推广应用的工具箱选项。<br>2、去除收藏列表的与百度相关的广告行为。<br>3、去除任务管理器以及应用锁的下载弹窗。<br>4、去除多余选项内容如使用帮助反馈问题。<br>5、调整根目录零散文件到同一数据文件夹。<br>6、禁止程序检测升级应用市场无更新提示。<br>7、精简大量多余的语言文件仅保留简繁英。<br>8、优化其他一些细节内容及界面选项菜单。</p><p>2021年1月17日15:30:44 已更新</p><h2 id="最后下载地址奉上："><a href="#最后下载地址奉上：" class="headerlink" title="最后下载地址奉上："></a>最后下载地址奉上：</h2><p><a href="https://seapit.lanzous.com/if1dMki9j0b">https://seapit.lanzous.com/if1dMki9j0b</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeatReader_v6.0.8</title>
    <link href="/2021/01/17/NeatReader-v6-0-8/"/>
    <url>/2021/01/17/NeatReader-v6-0-8/</url>
    
    <content type="html"><![CDATA[<p>软件介绍 </p><p>Neat Reader 是一款用于阅读epub文件的阅读器；其拥有强大的解析引擎，完美支持 ePub 2和 ePub 3，无论是任何类型的图书，都能完美展现，提供最佳阅读效果，简单易用的 EPUB 笔记系统，让你在学习时效率倍增，充分体验电子化学习的乐趣。当然，您还可以导出笔记，存在任何地方，方便日后查阅，在云端存储文件、笔记、进度，以及所有你能想到的一切！永远不用担心数据丢失，只需打开应用，轻轻一点，继续享受阅读。 </p><p>软件截图<br><img src="https://www.xd0.com/upload/1/146486/images/20210111/20210111105866956695.jpg" alt="sea"><br><img src="https://www.xd0.com/upload/1/146486/images/20210111/20210111105899459945.jpg" alt="sea"><br>版本特点 </p><p>去除所有广告 </p><p>解除会员的使用限制 </p><p>去除所有联网功能（包括云同步等） </p><p>移除所有需要联网的废弃按钮</p><h1 id="最后下载链接奉上："><a href="#最后下载链接奉上：" class="headerlink" title="最后下载链接奉上："></a>最后下载链接奉上：</h1><p><a href="https://seapit.lanzous.com/i11Eakhtmbe">https://seapit.lanzous.com/i11Eakhtmbe</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tiebao可破解e盾，可可，易游</title>
    <link href="/2021/01/16/Tiebao%E5%8F%AF%E7%A0%B4%E8%A7%A3e%E7%9B%BE%EF%BC%8C%E5%8F%AF%E5%8F%AF%EF%BC%8C%E6%98%93%E6%B8%B8/"/>
    <url>/2021/01/16/Tiebao%E5%8F%AF%E7%A0%B4%E8%A7%A3e%E7%9B%BE%EF%BC%8C%E5%8F%AF%E5%8F%AF%EF%BC%8C%E6%98%93%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.shuishuzy.com/content/uploadfile/202101/57d81609481870.jpg" alt="sea"><br>打开助手点击试用即可登录，软件列表里面的辅助都可以破解，方法看说明！</p><h1 id="下载地址奉上："><a href="#下载地址奉上：" class="headerlink" title="下载地址奉上："></a>下载地址奉上：</h1><p><a href="https://seapit.lanzous.com/isrCEkhcqej">https://seapit.lanzous.com/isrCEkhcqej</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回答各位的一些问题</title>
    <link href="/2021/01/16/%E5%9B%9E%E7%AD%94%E5%90%84%E4%BD%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/16/%E5%9B%9E%E7%AD%94%E5%90%84%E4%BD%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="怎么谈恋爱：不知道"><a href="#怎么谈恋爱：不知道" class="headerlink" title="怎么谈恋爱：不知道"></a>怎么谈恋爱：不知道</h1><h1 id="怎么哄女孩子开心：不知道"><a href="#怎么哄女孩子开心：不知道" class="headerlink" title="怎么哄女孩子开心：不知道"></a>怎么哄女孩子开心：不知道</h1><h1 id="怎么和女的交朋友：不知道"><a href="#怎么和女的交朋友：不知道" class="headerlink" title="怎么和女的交朋友：不知道"></a>怎么和女的交朋友：不知道</h1><h1 id="你会修电脑吗？"><a href="#你会修电脑吗？" class="headerlink" title="你会修电脑吗？"></a>你会修电脑吗？</h1><h2 id="不会"><a href="#不会" class="headerlink" title="不会"></a>不会</h2><h1 id="你会盗号吗？"><a href="#你会盗号吗？" class="headerlink" title="你会盗号吗？"></a>你会盗号吗？</h1><h2 id="我不会，你想学建议去医院挂个神经科"><a href="#我不会，你想学建议去医院挂个神经科" class="headerlink" title="我不会，你想学建议去医院挂个神经科"></a>我不会，你想学建议去医院挂个神经科</h2><h1 id="你知道怎么当黑客吗？"><a href="#你知道怎么当黑客吗？" class="headerlink" title="你知道怎么当黑客吗？"></a>你知道怎么当黑客吗？</h1><h2 id="不知道"><a href="#不知道" class="headerlink" title="不知道"></a>不知道</h2><h1 id="你长大要当黑客吗？"><a href="#你长大要当黑客吗？" class="headerlink" title="你长大要当黑客吗？"></a>你长大要当黑客吗？</h1><h2 id="不当"><a href="#不当" class="headerlink" title="不当"></a>不当</h2><h1 id="sea你是帮我盗个号行吗？"><a href="#sea你是帮我盗个号行吗？" class="headerlink" title="sea你是帮我盗个号行吗？"></a>sea你是帮我盗个号行吗？</h1><h2 id="不行"><a href="#不行" class="headerlink" title="不行"></a>不行</h2><h1 id="sea能不能借我点钱？"><a href="#sea能不能借我点钱？" class="headerlink" title="sea能不能借我点钱？"></a>sea能不能借我点钱？</h1><h2 id="不能"><a href="#不能" class="headerlink" title="不能"></a>不能</h2><h1 id="你会做熊猫烧香彩虹猫病毒吗？"><a href="#你会做熊猫烧香彩虹猫病毒吗？" class="headerlink" title="你会做熊猫烧香彩虹猫病毒吗？"></a>你会做熊猫烧香彩虹猫病毒吗？</h1><h2 id="不会-1"><a href="#不会-1" class="headerlink" title="不会"></a>不会</h2><h1 id="你能把他们家电脑黑了吗？"><a href="#你能把他们家电脑黑了吗？" class="headerlink" title="你能把他们家电脑黑了吗？"></a>你能把他们家电脑黑了吗？</h1><h2 id="不能-1"><a href="#不能-1" class="headerlink" title="不能"></a>不能</h2><h1 id="你能帮我免费做软件吗？"><a href="#你能帮我免费做软件吗？" class="headerlink" title="你能帮我免费做软件吗？"></a>你能帮我免费做软件吗？</h1><h2 id="不能-2"><a href="#不能-2" class="headerlink" title="不能"></a>不能</h2><h1 id="您会刷点卷吗？"><a href="#您会刷点卷吗？" class="headerlink" title="您会刷点卷吗？"></a>您会刷点卷吗？</h1><h2 id="老子不会"><a href="#老子不会" class="headerlink" title="老子不会"></a>老子不会</h2><h1 id="你是宅男吗？"><a href="#你是宅男吗？" class="headerlink" title="你是宅男吗？"></a>你是宅男吗？</h1><h2 id="不是"><a href="#不是" class="headerlink" title="不是"></a>不是</h2><h1 id="你喜欢穿格子衬衫吗？"><a href="#你喜欢穿格子衬衫吗？" class="headerlink" title="你喜欢穿格子衬衫吗？"></a>你喜欢穿格子衬衫吗？</h1><h2 id="不喜欢"><a href="#不喜欢" class="headerlink" title="不喜欢"></a>不喜欢</h2><h1 id="你怎么有头发？"><a href="#你怎么有头发？" class="headerlink" title="你怎么有头发？"></a>你怎么有头发？</h1><h2 id="我怎么不能有头发"><a href="#我怎么不能有头发" class="headerlink" title="我怎么不能有头发"></a>我怎么不能有头发</h2><h1 id="你中过病毒吗？"><a href="#你中过病毒吗？" class="headerlink" title="你中过病毒吗？"></a>你中过病毒吗？</h1><h2 id="人在江湖飘，哪能不挨刀"><a href="#人在江湖飘，哪能不挨刀" class="headerlink" title="人在江湖飘，哪能不挨刀"></a>人在江湖飘，哪能不挨刀</h2><h1 id="你能渗透和打ddos或者cc吗？"><a href="#你能渗透和打ddos或者cc吗？" class="headerlink" title="你能渗透和打ddos或者cc吗？"></a>你能渗透和打ddos或者cc吗？</h1><h2 id="中国保安队，扛起枪来就是兵"><a href="#中国保安队，扛起枪来就是兵" class="headerlink" title="中国保安队，扛起枪来就是兵"></a>中国保安队，扛起枪来就是兵</h2><h1 id="你谈恋爱吗？"><a href="#你谈恋爱吗？" class="headerlink" title="你谈恋爱吗？"></a>你谈恋爱吗？</h1><h2 id="谈，不过要你的加入比我的独处更加宜人"><a href="#谈，不过要你的加入比我的独处更加宜人" class="headerlink" title="谈，不过要你的加入比我的独处更加宜人"></a>谈，不过要你的加入比我的独处更加宜人</h2><h1 id="你有病吗？"><a href="#你有病吗？" class="headerlink" title="你有病吗？"></a>你有病吗？</h1><h1 id="没有"><a href="#没有" class="headerlink" title="没有"></a>没有</h1>]]></content>
    
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ优化防撤回自动点勋章去左侧</title>
    <link href="/2021/01/16/QQ%E4%BC%98%E5%8C%96%E9%98%B2%E6%92%A4%E5%9B%9E%E8%87%AA%E5%8A%A8%E7%82%B9%E5%8B%8B%E7%AB%A0%E5%8E%BB%E5%B7%A6%E4%BE%A7/"/>
    <url>/2021/01/16/QQ%E4%BC%98%E5%8C%96%E9%98%B2%E6%92%A4%E5%9B%9E%E8%87%AA%E5%8A%A8%E7%82%B9%E5%8B%8B%E7%AB%A0%E5%8E%BB%E5%B7%A6%E4%BE%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="PC魔改版QQ-防撤回-自动点亮勋章墙"><a href="#PC魔改版QQ-防撤回-自动点亮勋章墙" class="headerlink" title="PC魔改版QQ 防撤回 自动点亮勋章墙"></a>PC魔改版QQ 防撤回 自动点亮勋章墙</h1><p>相信大家有时候会很烦别人撤回消息 特别是女孩纸发个照片就撤回什么的啊 还没看清楚就撤回了</p><p>就很烦很难受 现在小编给大家找到一款防撤回的PC端破解版QQ 当然肯定是绿色纯净版 还没有任何广告哦</p><p>先去把自己的QQ卸载了 下载后先去打开“绿化.bat”等待运行完成 即可去使用破解版QQ了</p><h2 id="0消息防撤回"><a href="#0消息防撤回" class="headerlink" title="0消息防撤回"></a>0消息防撤回</h2><p><img src="https://www.qqwaw.com/upFiles/infoImg/202011121818545739.jpg" alt="sea"></p><h2 id="自动点亮勋章墙"><a href="#自动点亮勋章墙" class="headerlink" title="自动点亮勋章墙"></a>自动点亮勋章墙</h2><p><img src="https://www.qqwaw.com/upFiles/infoImg/202011121820039725.jpg" alt="sea"></p><h1 id="总得来说还是不错的-需要的小伙伴可点击下方链接进行下载"><a href="#总得来说还是不错的-需要的小伙伴可点击下方链接进行下载" class="headerlink" title="总得来说还是不错的 需要的小伙伴可点击下方链接进行下载:"></a>总得来说还是不错的 需要的小伙伴可点击下方链接进行下载:</h1><p><a href="https://seapit.lanzous.com/iAAMukgxw1c">https://seapit.lanzous.com/iAAMukgxw1c</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>QQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEU KMS Activator v20.0.0</title>
    <link href="/2021/01/15/HEU-KMS-Activator-v20-0-0/"/>
    <url>/2021/01/15/HEU-KMS-Activator-v20-0-0/</url>
    
    <content type="html"><![CDATA[<h1 id="HEU-KMS-Activator-v20-0-0"><a href="#HEU-KMS-Activator-v20-0-0" class="headerlink" title="HEU KMS Activator v20.0.0"></a>HEU KMS Activator v20.0.0</h1><p>HEU KMS Activator，简洁高效的全能KMS/OEM激活工具，适用所有Windows, Office版本，无需联网即可一键激活，支持UEFI的KMS激活工具。KMS服务是微软对Windows, Office等产品的批量许可服务，利用KMS可以激活局域网内的产品。该工具利用KMS机制在系统搭建KMS服务器，从而实现在线或离线激活。<br><img src="https://www.shanezy.com/uploads/allimg/201218/1608272231290501.jpg" alt="sea"><br>功能介绍</p><p>1、智能激活：智能识别最佳的激活方式</p><p>优先顺序依次为数字许可证/KMS38/OEM/KMS</p><p>自动识别并跳过已经永久激活的Windows/Office</p><p>2、KMS激活</p><p>安装/卸载自动续期功能，两种模式可供选择[1]自动续订模式(默认 [2]任务计划模式</p><p>清除KMS客户端信息：清除KMS服务器地址、端口、激活时间间隔、续订时间间隔等</p><p>搭建KMS服务器[手动激活]：KMS服务器地址/端口</p><p>3、数字激活（数字许可证激活、KMS38激活）</p><p>添加/解除KMS38保护，免受180天激活影响，除非解除保护，否则不能使用KMS38激活</p><p>查看当前系统信息：网络状态/激活状态，描述便于快速查看是否支持数字许可证/KMS38</p><p>4、OEM激活（提供6种模式）</p><p>卸载OEM激活信息：清除动态加载的SLIC等信息，OEM激活将失效</p><p>生产$OEM$文件夹：可将该文件夹置于ISO镜像source文件夹下，以集成OEM激活功能 </p><p>5、更改Windows 10版本、激活信息备份还原、Microsoft Office 零售版转换批量授权版</p><p>6、Windows/Office密钥管理功能：安装密钥、卸载密钥、查看密钥、清除Office许可证</p><p>7、智能激活、激活成功率高、支持静默参数、几乎支持所有 Windows/Office 所有版本</p><p>8、Windows 7上无需依赖.NET Framework、能够离线激活，也能连接网络服务器激活</p><p>静默参数</p><p>/? 查看命令行静默参数</p><p>/windows 激活Windows</p><p>/office 激活Microsoft Office</p><p>/renewal 安装自动续期功能</p><p>/unrenewal 卸载自动续期功能</p><p>/digital 采用数字许可永久激活Win10</p><p>/kms38 采用KMS38模式激活Win10至2038年</p><p>/oem OEM激活Windowns Vista/7/Server</p><p>/lock 为KMS38激活添加保护</p><p>/nologo 使用静默参数时不显示logo</p><h2 id="最后-下载地址奉上"><a href="#最后-下载地址奉上" class="headerlink" title="最后 下载地址奉上:"></a>最后 下载地址奉上:</h2><p><a href="https://seapit.lanzous.com/ieJ2Jkfrgxg">https://seapit.lanzous.com/ieJ2Jkfrgxg</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>系统激活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓iPhone12桌面启动修改器</title>
    <link href="/2021/01/15/%E5%AE%89%E5%8D%93iPhone12%E6%A1%8C%E9%9D%A2%E5%90%AF%E5%8A%A8%E4%BF%AE%E6%94%B9%E5%99%A8/"/>
    <url>/2021/01/15/%E5%AE%89%E5%8D%93iPhone12%E6%A1%8C%E9%9D%A2%E5%90%AF%E5%8A%A8%E4%BF%AE%E6%94%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓iPhone12桌面启动修改器"><a href="#安卓iPhone12桌面启动修改器" class="headerlink" title="安卓iPhone12桌面启动修改器"></a>安卓iPhone12桌面启动修改器</h1><p><img src="https://www.shanezy.com/uploads/allimg/210104/1609730413826147.jpg" alt="sea"><br>iPhone12启动器可让你的手机直接变成iPhone12的桌面。从主题,桌面,ui以及系统内的各种细节,完全深度的复刻了ios14系统,一键变换主题系统，装X必备神器。</p><h2 id="最后，链接奉上："><a href="#最后，链接奉上：" class="headerlink" title="最后，链接奉上："></a>最后，链接奉上：</h2><p><a href="https://seapit.lanzous.com/iTkvMkfr7nc">https://seapit.lanzous.com/iTkvMkfr7nc</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sisters阅读一款小说阅读极简神奇</title>
    <link href="/2021/01/15/sisters%E9%98%85%E8%AF%BB%E4%B8%80%E6%AC%BE%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E6%9E%81%E7%AE%80%E7%A5%9E%E5%A5%87/"/>
    <url>/2021/01/15/sisters%E9%98%85%E8%AF%BB%E4%B8%80%E6%AC%BE%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E6%9E%81%E7%AE%80%E7%A5%9E%E5%A5%87/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.shanezy.com/uploads/allimg/210112/1610421878785609.jpg" alt="sea"><br>sisters阅读是一款极简小说阅读软件。sisters阅读APP超多热门分类，汇聚全网热门书籍，极速加载无广告，体验畅快阅读体验。</p><h2 id="链接奉上："><a href="#链接奉上：" class="headerlink" title="链接奉上："></a>链接奉上：</h2><p><a href="https://seapit.lanzous.com/ic1GGkfr0if">https://seapit.lanzous.com/ic1GGkfr0if</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>老板键v19.9.0.3 上班摸鱼</title>
    <link href="/2021/01/15/%E8%80%81%E6%9D%BF%E9%94%AEv19-9-0-3-%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC/"/>
    <url>/2021/01/15/%E8%80%81%E6%9D%BF%E9%94%AEv19-9-0-3-%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.shanezy.com/uploads/allimg/210114/1610588303991826.png" alt="sea"><br>.永久免费的老板键!无任何弹窗广告！无任何功能限制！无任何锁主页！</p><p>2.能隐藏QQ、QQ游戏、浏览器等窗口界面，能隐藏32位和64位系统的任何软件的托盘图标，隐藏的时候能执行静音操作。</p><p>3.鼠标控制，自定义热键和加强的热键，能够解决热键冲突问题。</p><p>4.支持虚拟机中运行，支持修改为任何名称运行。</p><p>5.鼠标和键盘无操作，老板键可以自动隐藏。</p><p>6.可以按QQ号隐藏QQ，支持微信隐藏。</p><p>7.虚拟桌面功能,大型游戏窗口也能快速隐藏。</p><p>8.软件支持任何微软操作系统，支持任何系统的开机启动： winXP  win7 win8 win10系统….</p><h1 id="最后链接奉上："><a href="#最后链接奉上：" class="headerlink" title="最后链接奉上："></a>最后链接奉上：</h1><p><a href="https://seapit.lanzous.com/iwliUkfqsji">https://seapit.lanzous.com/iwliUkfqsji</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sandboxie v5.46.1 免费开源个人维护经典版</title>
    <link href="/2021/01/15/Sandboxie-v5-46-1-%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E4%B8%AA%E4%BA%BA%E7%BB%B4%E6%8A%A4%E7%BB%8F%E5%85%B8%E7%89%88/"/>
    <url>/2021/01/15/Sandboxie-v5-46-1-%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E4%B8%AA%E4%BA%BA%E7%BB%B4%E6%8A%A4%E7%BB%8F%E5%85%B8%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Sandboxie-v5-46-1-免费开源个人维护经典版"><a href="#Sandboxie-v5-46-1-免费开源个人维护经典版" class="headerlink" title="Sandboxie v5.46.1 免费开源个人维护经典版"></a>Sandboxie v5.46.1 免费开源个人维护经典版</h1><p>菜鸟高手裸奔工具沙盘Sandboxie是一款国外著名的系统安全工具，它可以让选定程序在安全的隔离环境下运行，只要在此环境中运行的软件，浏览器或注册表信息等都可以完整的进行清空，不留一点痕迹。同时可以防御些带有木马或者病毒的恶意网站，对于经常测试软件或者不放心的软件，可放心在沙盘里面运行！</p><p><img src="https://www.shanezy.com/uploads/allimg/210111/1610332205103023.png" alt="avatar"><br><img src="https://www.shanezy.com/uploads/allimg/210111/1610332209981466.png" alt="avatar"><br>新版特性</p><p>cdn.jsdelivr.net/gh/sandboxie-plus/Sandboxie@master/CHANGELOG.md</p><p>官方论坛于2020年3月份免费公布 Sandboxie 源码</p><p>官方数字签名的最后一个免费版本的版本号为v5.36</p><p>现在由开发者 @DavidXanatos 个人接手源码维护。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://seapit.lanzous.com/irPcUkfpp8d">https://seapit.lanzous.com/irPcUkfpp8d</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ccleaner</title>
    <link href="/2021/01/15/ccleaner/"/>
    <url>/2021/01/15/ccleaner/</url>
    
    <content type="html"><![CDATA[<h1 id="CCleaner-v5-76-8269专业版"><a href="#CCleaner-v5-76-8269专业版" class="headerlink" title="CCleaner v5.76.8269专业版"></a>CCleaner v5.76.8269专业版</h1><p>CCleaner是一款免费的系统优化和隐私保护工具，它的体积小、扫描速度非常快，支持自定义清理规则，增强了应用程序清理范围和效果。CCleaner是Piriform（梨子公司）最著名广受好评的系统清理优化及隐私保护软件，也是该公司主打和首发产品，可以有效清除各种系统垃圾文件及应用程序垃圾，同时具备系统优化功能；可以对临时文件夹、历史记录、注册表冗余条目等进行垃圾清理，附带启动项管理、软件卸载功能。</p><p><img src="https://www.shanezy.com/uploads/allimg/210114/1610591311353374.png" alt="avatar"></p><p>此版特点</p><ul><li><p>基于官方专业安装版拆包，离线集成注册码，配置便携化处理</p></li><li><p>反汇编处理，实现INI配置文件便携化后也能使用智能清理功能</p></li></ul><p>├—官方便携版，不支持智能清理功能，选项-&gt;智能清理是灰色的</p><ul><li>杜绝启动各种联网请求，提升启动速度，且无网络情况下启动不卡顿</li></ul><p>├—启动联网请求包括：发送匿名数据、检测许可密钥、检测升级提示</p><p>├—官方原版每次启动会后台偷偷联网请求avast安全中心上传匿名数据</p><ul><li><p>调整并补充未翻译的简体中文字串，将中文语言移到程序内，删除其它多语言模块</p></li><li><p>预设选项：跳过UAC、关闭获取收集隐私数据和优惠信息、不启用智能清理功能等</p></li><li><p>取消原版规则默认勾选清理Edge/谷歌/火狐等浏览器Cookies项的钩子避免误清理</p></li><li><p>增强扫描规则：最新WinApp2规则 + 昔之光规则 (飞扬时空、slzyk | 孤雨 、lrxy)</p></li></ul><p>最后<br>下载链接奉上：<br><a href="https://seapit.lanzous.com/iRrVwkfozva">https://seapit.lanzous.com/iRrVwkfozva</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC暗网进入教程</title>
    <link href="/2021/01/15/PC%E6%9A%97%E7%BD%91%E8%BF%9B%E5%85%A5%E6%95%99%E7%A8%8B/"/>
    <url>/2021/01/15/PC%E6%9A%97%E7%BD%91%E8%BF%9B%E5%85%A5%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>介绍一下什么是暗网并且如何登陆暗网。<br>首先先知道什么是明网：明网指的是合法大众化都可以访问的网站。暗网呢就是指的是一些灰色的非法网站，这些非法的网站将他们的资源联系到一起形成了一个庞大的网络，这就是暗网。这些网站的进入方式也和我们传统的访问不太一样，并不是输入个域名和地址就可以访问的。这样不就很容易的被安全部门追查到了吗？这么愚蠢的行为，我相信暗网的人绝对不会这么傻的。。。。。。。</p><p>先在我就演示一下如何带你去访问暗网。。。。（声明：本文只针对爱好者纯技术学习）<br>首先你要可以FQ（姿势有很多，花点银子你就可以做得到，这里不赘述，你要是连FQ都不会我觉得你还是先别看这篇文章了。。。。。。）<br>首先 要下载tor </p><p><a href="https://www.torproject.org/download/download-easy.html.en">https://www.torproject.org/download/download-easy.html.en</a><br>Tor是一个无痕浏览的神器。他的工作原理就是将你的ip跳到一连串的的代理上，比如：把你的ip从美国调到加拿大在调到荷兰。。。。。。。。。 其中的数据都是加密的目的就是掩藏真正访问者的ip，防止对访问者的追踪。</p><p>把他下载下来<br>解压后的文件就是这样</p><p>我们打开Browser去修改一下文件（直接打开会报错的）。 </p><p>改好后我们打开  第一次打开会有代理连接，记得要用代理连接去上网。<br>热点资讯<br>如何进入暗网（技术交流）<br>07-20栏目：技术<br>TAG：暗网怎么进入　</p><p>暗网怎么进入<br>介绍一下什么是暗网并且如何登陆暗网。<br>首先先知道什么是明网：明网指的是合法大众化都可以访问的网站。暗网呢就是指的是一些灰色的非法网站，这些非法的网站将他们的资源联系到一起形成了一个庞大的网络，这就是暗网。这些网站的进入方式也和我们传统的访问不太一样，并不是输入个域名和地址就可以访问的。这样不就很容易的被安全部门追查到了吗？这么愚蠢的行为，我相信暗网的人绝对不会这么傻的。。。。。。。</p><p>先在我就演示一下如何带你去访问暗网。。。。（声明：本文只针对爱好者纯技术学习）<br>首先你要可以FQ（姿势有很多，花点银子你就可以做得到，这里不赘述，你要是连FQ都不会我觉得你还是先别看这篇文章了。。。。。。）<br>首先 要下载tor</p><p><a href="https://www.torproject.org/download/download-easy.html.en">https://www.torproject.org/download/download-easy.html.en</a><br>Tor是一个无痕浏览的神器。他的工作原理就是将你的ip跳到一连串的的代理上，比如：把你的ip从美国调到加拿大在调到荷兰。。。。。。。。。 其中的数据都是加密的目的就是掩藏真正访问者的ip，防止对访问者的追踪。</p><p>我们打开Browser去修改一下文件（直接打开会报错的）。</p><p>改好后我们打开  第一次打开会有代理连接，记得要用代理连接去上网。</p><p>看一下运行的端口 也可以用别的浏览器代理到9150的口上哦！！！<br>暗网的样子。网站都是onion结尾的（这上面的网站大多数的交易都是违法的，其中交易的货币都是通过比特币来进行的。）</p><h1 id="郑重提醒：本文纯属技术学习，心里要有杆秤。坏的方面我不去做，你也别去做，里面大部分的交易都属于非法交易。望各位自重。"><a href="#郑重提醒：本文纯属技术学习，心里要有杆秤。坏的方面我不去做，你也别去做，里面大部分的交易都属于非法交易。望各位自重。" class="headerlink" title="郑重提醒：本文纯属技术学习，心里要有杆秤。坏的方面我不去做，你也别去做，里面大部分的交易都属于非法交易。望各位自重。"></a>郑重提醒：本文纯属技术学习，心里要有杆秤。坏的方面我不去做，你也别去做，里面大部分的交易都属于非法交易。望各位自重。</h1><h1 id="暗网进入的详细步骤："><a href="#暗网进入的详细步骤：" class="headerlink" title="暗网进入的详细步骤："></a>暗网进入的详细步骤：</h1><h2 id="1进入设置页面，点击设置。"><a href="#1进入设置页面，点击设置。" class="headerlink" title="1进入设置页面，点击设置。"></a>1进入设置页面，点击设置。</h2><p><img src="https://sea-3gkzomd90114852a-1302781314.tcloudbaseapp.com/%E8%BF%9B%E5%85%A5%E6%9A%97%E7%BD%91/%E6%9A%97%E7%BD%91%E8%BF%9B%E5%85%A5%E6%AD%A5%E9%AA%A41.png" alt="avatar"></p><h2 id="2、默认选否即可。"><a href="#2、默认选否即可。" class="headerlink" title="2、默认选否即可。"></a>2、默认选否即可。</h2><p><img src="https://sea-3gkzomd90114852a-1302781314.tcloudbaseapp.com/%E8%BF%9B%E5%85%A5%E6%9A%97%E7%BD%91/2.png" alt="avatar"></p><h2 id="3、这步选择是，然后点击下一步。"><a href="#3、这步选择是，然后点击下一步。" class="headerlink" title="3、这步选择是，然后点击下一步。"></a>3、这步选择是，然后点击下一步。</h2><p><img src="https://sea-3gkzomd90114852a-1302781314.tcloudbaseapp.com/%E8%BF%9B%E5%85%A5%E6%9A%97%E7%BD%91/3.png" alt="avatar"></p><h2 id="4·传输类型选择fte，然后点击链接，等待tor连接成功即可"><a href="#4·传输类型选择fte，然后点击链接，等待tor连接成功即可" class="headerlink" title="4·传输类型选择fte，然后点击链接，等待tor连接成功即可"></a>4·传输类型选择fte，然后点击链接，等待tor连接成功即可</h2><p><img src="https://sea-3gkzomd90114852a-1302781314.tcloudbaseapp.com/%E8%BF%9B%E5%85%A5%E6%9A%97%E7%BD%91/4.png" alt="avatar"></p><h2 id="5、等待连接，第一次连接时间可能有点长要有耐心。"><a href="#5、等待连接，第一次连接时间可能有点长要有耐心。" class="headerlink" title="5、等待连接，第一次连接时间可能有点长要有耐心。"></a>5、等待连接，第一次连接时间可能有点长要有耐心。</h2><p><img src="https://sea-3gkzomd90114852a-1302781314.tcloudbaseapp.com/%E8%BF%9B%E5%85%A5%E6%9A%97%E7%BD%91/chenggong.png" alt="avatar"></p><h1 id="sea再次提醒一下，请各位斟酌，坏的方面我们不去做，里面大部分都是违法交易-我只提供技术，不去承担后果！！！！"><a href="#sea再次提醒一下，请各位斟酌，坏的方面我们不去做，里面大部分都是违法交易-我只提供技术，不去承担后果！！！！" class="headerlink" title="sea再次提醒一下，请各位斟酌，坏的方面我们不去做，里面大部分都是违法交易,我只提供技术，不去承担后果！！！！"></a>sea再次提醒一下，请各位斟酌，坏的方面我们不去做，里面大部分都是违法交易,我只提供技术，不去承担后果！！！！</h1>]]></content>
    
    
    
    <tags>
      
      <tag>暗网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python面向对象</title>
    <link href="/2021/01/10/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/01/10/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>#1. 引言<br>引用在各种编程语言中都有涉及，如java中值传递和引用传递。python的对象引用也是学习python过程中需要特别关注的一个知识点，特别是对函数参数传递，可能会引起不必要的BUG。本文将对引用做一个梳理，内容涉及如下：</p><p>变量和赋值</p><p>可变对象和不可变对象</p><p>函数参数的引用</p><p>浅拷贝和深拷贝</p><p>垃圾回收</p><p>弱引用</p><p>#2. python引用<br>2.1 变量和赋值<br>任何一个python对象都有标签，类型和值三个属性。标签在对象创建后直到内存回收就保持不变，可以理解为内存地址。</p><p>python在给变量赋值，会把赋值的对象的内存地址赋值给变量。也就是说python的变量是地址引用式的变量。引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的值本身。</p><p>可以通过is或者比较id()的判断是否引用的是同一个内存地址的变量。</p><p>== 是比较两个对象的内容是否相等，即两个对象的值是否相等</p><p>is同时检查对象的值和内存地址。可以通过is判断是否是同一个对象</p><p>id() 列出变量的内存地址的编号</p><h1 id="这个例子a-和-b-两个变量共同指向了同一个内存空间"><a href="#这个例子a-和-b-两个变量共同指向了同一个内存空间" class="headerlink" title="这个例子a 和 b 两个变量共同指向了同一个内存空间"></a>这个例子a 和 b 两个变量共同指向了同一个内存空间</h1><p>a = [1, 2, 3]<br>c = [1, 2, 3]<br>print(a is c) # False<br>print(a == c) # True<br>b = a<br>a.append(5)<br>print(a is b) # True<br>初始化赋值：变量的每一次初始化，都开辟了一个新的空间，将新内容的地址赋值给变量</p><p>变量赋值：引用地址的传递</p><p>2.2 可变对象和不可变对象<br>python中的一切都是对象。python对象又分为可变对象和不可变对象。二者的区别在于对象的值在不改变内存地址的情况下是否可修改。</p><p>可变对象包括字典dict、列表list、集合set、手动声明的类对象等</p><p>不可变对象包括数字int float、字符str、None、元组tuple等</p><p>下面举几个典型的例子：</p><p>list 可变对象，内容变更地址不变</p><p>a = [1, 2, 3]<br>print(id(a))<br>a.append(5)<br>print(id(a))<br>不可变对象（常用的共享地址或缓存）</p><h1 id="较小整数频繁被使用，python采用共享地址方式来管理"><a href="#较小整数频繁被使用，python采用共享地址方式来管理" class="headerlink" title="较小整数频繁被使用，python采用共享地址方式来管理"></a>较小整数频繁被使用，python采用共享地址方式来管理</h1><p>a = 1<br>b = 1<br>print(a is b) # True</p><h1 id="对于单词类str，python采用共享缓存的方式来共享地址"><a href="#对于单词类str，python采用共享缓存的方式来共享地址" class="headerlink" title="对于单词类str，python采用共享缓存的方式来共享地址"></a>对于单词类str，python采用共享缓存的方式来共享地址</h1><p>a = ‘hello’<br>b = ‘hello’<br>print(a is b) # True<br>不可变对象（不共享地址）</p><p>a = (1999, 1)<br>b = (1999, 1)<br>print(a is b) # False</p><p>a = ‘hello everyone’<br>b = ‘hello everyone’<br>print(a is b) # False<br>元组的相对不可变型</p><h1 id="元组的里元素是可变，改变可变的元素，不改变元组的引用"><a href="#元组的里元素是可变，改变可变的元素，不改变元组的引用" class="headerlink" title="元组的里元素是可变，改变可变的元素，不改变元组的引用"></a>元组的里元素是可变，改变可变的元素，不改变元组的引用</h1><p>a = (1999, [1, 2])<br>ida = id(a)<br>a[-1].append(3)<br>idb = id(a)</p><p>print(ida == idb) # True<br>这里之所以要提到变量可变和不可变的特性，其实主要是想说明变量的引用其实和变量的可变和不可变没有直接的关系。变量可变和不可变主要着眼点是变量可不可以修改，注意这个修改不是通过赋值的操作来完成。</p><p>a = [1, 2, 3]<br>print(id(a))<br>a = a + [5]<br>print(id(a))</p><h1 id="前后两个变量a，-已经不是同一个地址了"><a href="#前后两个变量a，-已经不是同一个地址了" class="headerlink" title="前后两个变量a， 已经不是同一个地址了"></a>前后两个变量a， 已经不是同一个地址了</h1><p>2.3 函数参数的引用<br>python中函数的传参方式是共享传参，即函数的形参是实参中各个引用的副本（别名）。函数会修改是可变对象的实参（表示的同一个对象）；而不会改变实参的引用。</p><p>def func(d):<br>    d[‘a’] = 10<br>    d[‘b’] = 20    # 改变了外部实参的值<br>    d = {‘a’: 0, ‘b’: 1}  # 赋值操作， 局部d贴向了新的标识<br>    print(d) # {‘a’: 0, ‘b’: 1}</p><p>d = {}<br>func(d)<br>print(d) # {‘a’: 10, ‘b’: 20}<br>建议不要写上面例子的代码，局部变量和全局变量的名称一样，尽量编码，否则很容易出bug而不自知。</p><p>函数的参数的默认值避免使用可变参数，尽量用None来代替。原因是函数的默认值是作为函数对象的属性，如果默认值是可变对象，而且修改了它，那边后续的函数对象都会受到影响。</p><p>class bus():<br>    def <strong>init</strong>(self, param=[]):<br>        self.param = param</p><pre><code>def test(self, elem):    self.param.append(elem)</code></pre><p>b = bus([2, 3])<br>b.param # [2, 3]</p><p>c = bus()<br>c.test(3)<br>c.param # [3]</p><p>d = bus()<br>d.param # [3]  # c 中修改了默认值的引用的内容<br>2.4 浅拷贝和深拷贝<br>对于可变对象，我们要时刻注意它的可变性，特别是对赋值或者拷贝后的变量做内容修改操作的时候，需要考虑下是否会影响到原始变量的值，如果程序有bug，可以往这方面想一想。这里讲一下拷贝即建立副本。拷贝有两种：</p><p>浅拷贝：只复制顶层的对象，对于有嵌套数据结构，内部的元素还是原有对象的引用，这时候需要特别注意</p><p>深拷贝：复制了所有对象，递归式的复制所有对象。复制后的对象和原来的对象是完全不同的对象。对于不可变对象来说，浅拷贝和深拷贝都是一样的地址。但是对于嵌套了可变对象元素的情况，就有所不同</p><p>test_a = (1, 2, 3)<br>test_b = copy.copy(test_a)<br>test_c = copy.deepcopy(test_a)<br>print(test_a is test_b) # True<br>print(test_a is test_c) # True</p><p>test_a[2].append(5) # 改变不可变对象中可变元素的内容<br>print(test_a is test_b) # True<br>print(test_a is test_c) # False<br>print(test_c) # (1, 2, [3, 4])<br>对于可变对象，只要拷贝，就创建了一个新的顶层对象。如果是浅拷贝，内部嵌套的可变对象只是拷贝引用，这样就会相互影响。深拷贝就不会有这种问题。</p><p>l1 = [3, [66, 55, 44], (2, 3, 4)]<br>l2 = list(l1) # l2是l1的浅拷贝</p><h1 id="顶层改变不会相互影响，因为是两个不同对象"><a href="#顶层改变不会相互影响，因为是两个不同对象" class="headerlink" title="顶层改变不会相互影响，因为是两个不同对象"></a>顶层改变不会相互影响，因为是两个不同对象</h1><p>l1.append(50)<br>print(l1) # 3, [66, 55, 44], (2, 3, 4), 50]<br>print(l2) # [3, [66, 55, 44], (2, 3, 4)]</p><h1 id="嵌套可变元素，浅拷贝共享一个地址"><a href="#嵌套可变元素，浅拷贝共享一个地址" class="headerlink" title="嵌套可变元素，浅拷贝共享一个地址"></a>嵌套可变元素，浅拷贝共享一个地址</h1><p>l1[1].append(100)<br>print(l1) # [3, [66, 55, 44, 100], (2, 3, 4), 50]<br>print(l2) # [3, [66, 55, 44, 100], (2, 3, 4)]</p><h1 id="嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响"><a href="#嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响" class="headerlink" title="嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响"></a>嵌套不可变元素，不可变元素的操作是创建一个新的对象，所以不影响</h1><p>l1[2] += (2,3)<br>print(l1) # [3, [66, 55, 44, 100], (2, 3, 4, 2, 3), 50]<br>print(l2) #[3, [66, 55, 44, 100], (2, 3, 4)]<br>2.5 垃圾回收<br>python对于垃圾回收，采取的是引用计数为主，标记-清除+分代回收为辅的回收策略。</p><p>引用计数：python可以给所有的对象（内存中的区域）维护一个引用计数的属性，在一个引用被创建或复制的时候，让python,把相关对象的引用计数+1；相反当引用被销毁的时候就把相关对象的引用计数-1。当对象的引用计数减到0时，认为整个python中不会再有变量引用这个对象，所以就可以把这个对象所占据的内存空间释放出来了。可以通过sys.getrefcount()来查看对象的引用</p><p>分代回收: 分代回收主要是为了提高垃圾回收的效率。对象的创建和消费的频率不一样。由于python在垃圾回收前需要检测是否是垃圾，是否回收，然后再回收。当对象很多的时候，垃圾检测的耗时变得很大，效率很低。python采用的对对象进行分代，按不同的代进行不同的频率的检测。代等级的规则根据对象的生命时间来判断，比如一个对象连续几次检测都是可达的，这个对象代的等级高，降低检测频率。python中默认把所有对象分成三代。第0代包含了最新的对象，第2代则是最早的一些对象</p><p>循环引用：一个对象直接或者间接引用自己本身，引用链形成一个环。这样改对象的引用计数永远不可能为0。所有能够引用其他对象的对象都被称为容器(container). 循环引用只能发生容器之间发生. Python的垃圾回收机制利用了这个特点来寻找需要被释放的对象。</p><p>import sys<br>a = [1, 2]<br>b = a</p><p>print(sys.getrefcount(a)) # 3 命令本身也是一次引用<br>del b<br>print(sys.getrefcount(a)) # 2<br>#3. 弱引用<br>弱引用在许多高级语言中都存在。如前所述，当对象的引用计数为0时，垃圾回收机制就会销毁对象。但有时候需要引用对象，但不希望增加引用计数。这样有什么好处？</p><p>应用在缓存中，只存在一定的时间存在。当它引用的对象存在时，则对象可用，当对象不存在时，就返回None</p><p>不增加引用计数，在循环引用使用，就降低内存泄露的可能性</p><p>这就是弱引用weak reference，不会增加对象的引用数量。引用的目标对象称为 所指对象 （referent）。</p><p>import weakref<br>a_set = {0,1}<br>wref = weakref.ref(a_set) # 建立弱引用<br>print(wref()) # {0,1}<br>a_set = {2, 3, 4} # 原来的a_set 引用计数为0，垃圾回收<br>print(wref()) # None # 所值对象被垃圾回收， 弱引用也消失为None<br>弱引用一般使用时weakref集合, weakref.WeakValueDictionary, weakref.WeakKeyDictionary两者的区别是一个是值进行弱引用，一个是可以进行弱引用；另外还有weakref.WeakSet</p><p>#4. 总结<br>本文描述python中引用相关的几个方面，希望对大家有帮助。总结如下：</p><p>对象赋值就完成引用，变量是地址引用式的变量</p><p>要时刻注意，所以引用可变对象对象的改变，是否导致共同引用的变量值得变化</p><p>函数会修改是可变对象的实参<br>浅拷贝只是copy顶层，如果存在内部嵌套可变对象，要注意，copy的还是引用</p><p>对象的引用计数为0时，就开始垃圾回收</p><p>弱引用为增加引用计数，与被所指对象共存亡，而不影响循环引用</p><p>完结撒花累死我了</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现在线聊天功能</title>
    <link href="/2021/01/10/Java%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/01/10/Java%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>创建Client.java</p><p>import java.io.IOException;<br>import java.net.Socket;<br>import java.net.UnknownHostException;</p><p>/**</p><ul><li><p>@author sea</p></li><li><p>@sea</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class Client {<br>  public static void main(String[] args) {</p><pre><code>  try &#123;      // 创建8888端口      Socket s = new Socket(&quot;127.0.0.1&quot;, 8888);      // 启动发送消息线程      new SendThread(s).start();      // 启动接受消息线程      new RecieveThread(s).start();  &#125; catch (UnknownHostException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }<br>}</p></li></ul><p>#创建Server.java</p><p>import java.io.IOException;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p><p>/**</p><ul><li><p>@author sea</p></li><li><p>@sea</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class Server {<br>  public static void main(String[] args) {</p><pre><code>  try &#123;      // 监听8888端口      ServerSocket ss = new ServerSocket(8888);      System.out.println(&quot;监听在端口号:8888&quot;);      Socket s = ss.accept();      //启动发送消息线程      new SendThread(s).start();      //启动接受消息线程      new RecieveThread(s).start();  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }<br>}</p></li></ul><p>#创建RecieveThread.java</p><p>import java.io.*;<br>import java.net.Socket;</p><p>/**</p><ul><li><p>@author sea</p></li><li><p>@sea</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class RecieveThread extends Thread {</p><p>  private Socket s;</p><p>  public RecieveThread(Socket s) {</p><pre><code>  this.s = s;</code></pre><p>  }</p><p>  public void run() {</p><pre><code>  try &#123;      // 接收对方输入的内容      InputStream is = s.getInputStream();      DataInputStream dis = new DataInputStream(is);      while (true) &#123;          String msg = dis.readUTF();          System.out.println(msg);      &#125;  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }</p></li></ul><p>}<br>#创建SendThread.java</p><p>import java.io.*;<br>import java.net.Socket;<br>import java.util.Scanner;</p><p>/**</p><ul><li><p>@author sea</p></li><li><p>@sea</p></li><li><p>@createDate 2020- 07-04 22:13</p></li><li></li><li><ol><li>SendThread 发送消息线程</li></ol></li><li><ol start="2"><li>RecieveThread 接受消息线程</li></ol></li><li><p>/<br>public class SendThread extends Thread {</p><p>  private Socket s;</p><p>  public SendThread(Socket s) {</p><pre><code>  this.s = s;</code></pre><p>  }</p><p>  public void run() {</p><pre><code>  try &#123;      // 获取输入的内容      OutputStream os = s.getOutputStream();      DataOutputStream dos = new DataOutputStream(os);      while (true) &#123;          Scanner sc = new Scanner(System.in);          String str = sc.next();          dos.writeUTF(str);      &#125;  &#125; catch (IOException e) &#123;      // TODO Auto-generated catch block      e.printStackTrace();  &#125;</code></pre><p>  }</p></li></ul><p>}<br>okok这样就可以起飞啦</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3悬停效果</title>
    <link href="/2021/01/10/CSS3%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C/"/>
    <url>/2021/01/10/CSS3%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>font awesome 图标使用方法参考网站：</p><p><a href="https://fontawesome.dashgame.com/">https://fontawesome.dashgame.com/</a></p><p>#HTML<br><!DOCTYPE html></p><html>    <head>        <meta charset="utf-8">        <title>鼠标悬停效果:微信公众号AlbertYang</title>        <link rel="stylesheet" type="text/css" href="cursor.css" />        <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">    </head>    <body>        <ul>            <li><a href="#"><i class="fa fa-address-card"></i></a></li>            <li><a href="#"><i class="fa fa-address-card"></i></a></li>            <li><a href="#"><i class="fa fa-drivers-license-o"></i></a></li>            <li><a href="#"><i class="fa fa-envelope-open-o"></i></a></li>            <li><a href="#"><i class="fa fa-ravelry"></i></a></li>            <li><a href="#"><i class="fa fa-snowflake-o"></i></a></li>            <div class="cursor"></div>        </ul>        <script>            const cursor = document.querySelector(".cursor");            document.addEventListener('mousemove', (e) => {                cursor.style.left = e.pageX + 'px';                cursor.style.top = e.pageY + 'px';            })        </script>    </body></html><p>#cursor.css</p><ul><li>{<br>  margin: 0;<br>  padding: 0;<br>}</li></ul><p>body {<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>    height: 100vh;<br>    background-color: azure;<br>}</p><p>ul {<br>    position: relative;<br>    display: flex;<br>}</p><p>ul li {<br>    list-style: none;<br>    margin: 0 30px;<br>}</p><p>ul li a {<br>    position: relative;<br>    display: inline-block;<br>    font-size: 2em;<br>    color: gray;<br>    transition: all 0.3s;<br>}</p><p>ul li:hover a {<br>    color: deepskyblue;<br>    transform: scale(1.5);<br>}</p><p>.cursor {<br>    position: fixed;<br>    width: 0;<br>    height: 0;<br>    border: 15px solid gray;<br>    border-radius: 50%;<br>    transform: translate(-50%, -50%);<br>    pointer-events: none;<br>    transition: width 0.3s, height 0.3s;<br>}</p><p>ul li:hover~.cursor {<br>    width: 80px;<br>    height: 80px;<br>    border: 3px solid deepskyblue;<br>}</p><p>由于本人能力和知识有限，如果有写的不对的地方，还请各位大佬批评指正</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5分钟用CSS实现毛玻璃效果</title>
    <link href="/2021/01/10/5%E5%88%86%E9%92%9F%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/"/>
    <url>/2021/01/10/5%E5%88%86%E9%92%9F%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>##实现思路</p><ol><li><p>定义三个box，布局方式都为absolute。</p></li><li><p>第一个box 放背景图片，第二个box实现模糊过滤，第三个box放要显示的图片。</p></li><li><p>通过监听鼠标移动，改变css 自定义属性值，通过calc()， var()函数获取计算自定义属性值实现移动效果。<br>#参考代码HTML</p><!DOCTYPE html><html><head> <meta charset="utf-8"> <title>毛玻璃效果:微信公众号AlbertYang</title></head><link rel="stylesheet" type="text/css" href="style.css" /><body> <section>   <div class="imgBx">     <h1>毛玻璃效果</h1>   </div>   <div class="box box1"></div>   <div class="box box2">     <h1>毛玻璃效果</h1>   </div> </section> <script>   const position = document.documentElement;   position.addEventListener('mousemove', e => {     position.style.setProperty('--x', e.pageX + 'px');     position.style.setProperty('--y', e.pageY + 'px');   })</script></body></html></li></ol><p>#CSS</p><ul><li>{<br>margin: 0;<br>padding: 0;<br>box-sizing: border-box;<br>}<br>section {<br>position: absolute;<br>top: 0;<br>left: 0;<br>width: 100%;<br>height: 100%;<br>overflow: hidden;<br>}<br>section .imgBx {<br>position: absolute;<br>top: 0;<br>left: 0;<br>width: 100%;<br>height: 100%;<br>display: flex;<br>justify-content: center;<br>align-items: center;<br>background: url(wbb.jpg);<br>background-size: 100%;<br>background-position: calc(var(–x)/5) calc(var(–y)/5);<br>}<br>section .box {<br>position: absolute;<br>top: 0;<br>left: 0;<br>width: 100%;<br>height: 100%;<br>display: flex;<br>justify-content: center;<br>align-items: center;<br>backdrop-filter: blur(10px);<br>}<br>section .box.box2 {<br>background: url(wbb.jpg);<br>background-size: 100%;<br>clip-path: circle(260px at center);<br>background-position: calc(var(–x)/5) calc(var(–y)/5);<br>}<br>section .box.box2::before {<br>content: “”;<br>position: absolute;<br>top: 50%;<br>left: 50%;<br>transform: translate(-50%, -50%);<br>width: 520px;<br>height: 520px;<br>box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);<br>z-index: 10;<br>border-radius: 50%;<br>}<br>section h1 {<br>position: absolute;<br>margin-top: 30%;<br>color: #fff;<br>font-size: 88px;<br>transform: translate(calc(var(–x)/5), calc(var(–y)/5));<br>}<br>由于本人能力和知识有限，如果有写的不对的地方，还请各位大佬批评指正</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript实现 - LeetCode刷题</title>
    <link href="/2021/01/10/JavaScript%E5%AE%9E%E7%8E%B0-LeetCode%E5%88%B7%E9%A2%98/"/>
    <url>/2021/01/10/JavaScript%E5%AE%9E%E7%8E%B0-LeetCode%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#解题步骤<br>1.广度优先遍历二叉树<br>2.遍历过程中，记录每个节点的层级，并将其添加到不同的数组中<br>#代码<br>/**</p><ul><li>Definition for a binary tree node.</li><li>function TreeNode(val) {</li><li><pre><code>this.val = val;</code></pre></li><li><pre><code>this.left = this.right = null;</code></pre></li><li>}</li><li>/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number[][]}</li><li>/<br>var levelOrder = function(root) {<br>if (!root) return [];<br>const q = [root];<br>const res = [];<br>while (q.length) {<br>  let len = q.length;<br>  res.push([]);<br>  // 下面这个while循环，每结束一次，里面就只是同一级的值，非常巧妙<br>  while (len–) {<pre><code>const n = q.shift();res[res.length - 1].push(n.val);if (n.left) q.push(n.left);if (n.right) q.push(n.right);</code></pre>  }<br>}<br>return res;<br>};</li></ul><p>哈哈，是不是很简单，你学会了吗</p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_多态</title>
    <link href="/2021/01/10/python-%E5%A4%9A%E6%80%81/"/>
    <url>/2021/01/10/python-%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1、什么多态：同一事物有多种形态"><a href="#1、什么多态：同一事物有多种形态" class="headerlink" title="1、什么多态：同一事物有多种形态"></a>1、什么多态：同一事物有多种形态</h1><h1 id="class-Animal"><a href="#class-Animal" class="headerlink" title="class Animal:"></a>class Animal:</h1><h1 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="class-People-Animal"><a href="#class-People-Animal" class="headerlink" title="class People(Animal):"></a>class People(Animal):</h1><h1 id="pass-1"><a href="#pass-1" class="headerlink" title="pass"></a>pass</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="class-Dog-Animal"><a href="#class-Dog-Animal" class="headerlink" title="class Dog(Animal):"></a>class Dog(Animal):</h1><h1 id="pass-2"><a href="#pass-2" class="headerlink" title="pass"></a>pass</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="class-Pig-Animal"><a href="#class-Pig-Animal" class="headerlink" title="class Pig(Animal):"></a>class Pig(Animal):</h1><h1 id="pass-3"><a href="#pass-3" class="headerlink" title="pass"></a>pass</h1><h1 id="2、为何要有多态-》多态会带来什么样的特性，多态性"><a href="#2、为何要有多态-》多态会带来什么样的特性，多态性" class="headerlink" title="2、为何要有多态=》多态会带来什么样的特性，多态性"></a>2、为何要有多态=》多态会带来什么样的特性，多态性</h1><h1 id="多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象"><a href="#多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象" class="headerlink" title="多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象"></a>多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象</h1><p>class Animal: # 统一所有子类的方法<br>    def say(self):<br>        print(‘动物基本的发声频率。。。’,end=’ ‘)</p><p>class People(Animal):<br>    def say(self):<br>        super().say()<br>        print(‘嘤嘤嘤嘤嘤嘤嘤’)</p><p>class Dog(Animal):<br>    def say(self):<br>        super().say()<br>        print(‘汪汪汪’)</p><p>class Pig(Animal):<br>    def say(self):<br>        super().say()<br>        print(‘哼哼哼’)</p><p>obj1=People()</p><h1 id="print-People-mro"><a href="#print-People-mro" class="headerlink" title="print(People.mro())"></a>print(People.mro())</h1><h1 id="obj2-Dog"><a href="#obj2-Dog" class="headerlink" title="obj2=Dog()"></a>obj2=Dog()</h1><h1 id="obj3-Pig"><a href="#obj3-Pig" class="headerlink" title="obj3=Pig()"></a>obj3=Pig()</h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="obj1-say"><a href="#obj1-say" class="headerlink" title="obj1.say()"></a>obj1.say()</h1><h1 id="obj2-say"><a href="#obj2-say" class="headerlink" title="obj2.say()"></a>obj2.say()</h1><h1 id="obj3-say"><a href="#obj3-say" class="headerlink" title="obj3.say()"></a>obj3.say()</h1><h1 id="定义统一的接口，接收传入的动物对象"><a href="#定义统一的接口，接收传入的动物对象" class="headerlink" title="定义统一的接口，接收传入的动物对象"></a>定义统一的接口，接收传入的动物对象</h1><h1 id="def-animal-say-animal"><a href="#def-animal-say-animal" class="headerlink" title="def animal_say(animal):"></a>def animal_say(animal):</h1><h1 id="animal-say"><a href="#animal-say" class="headerlink" title="animal.say()"></a>animal.say()</h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="animal-say-obj1"><a href="#animal-say-obj1" class="headerlink" title="animal_say(obj1)"></a>animal_say(obj1)</h1><h1 id="animal-say-obj2"><a href="#animal-say-obj2" class="headerlink" title="animal_say(obj2)"></a>animal_say(obj2)</h1><h1 id="animal-say-obj3"><a href="#animal-say-obj3" class="headerlink" title="animal_say(obj3)"></a>animal_say(obj3)</h1><h1 id="print-‘hello’-len"><a href="#print-‘hello’-len" class="headerlink" title="print(‘hello’.len())"></a>print(‘hello’.<strong>len</strong>())</h1><h1 id="print-1-2-3-len"><a href="#print-1-2-3-len" class="headerlink" title="print([1,2,3].len())"></a>print([1,2,3].<strong>len</strong>())</h1><h1 id="print-‘a’-1-’b’-2-len"><a href="#print-‘a’-1-’b’-2-len" class="headerlink" title="print({‘a’:1,’b’:2}.len())"></a>print({‘a’:1,’b’:2}.<strong>len</strong>())</h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="def-my-len-val"><a href="#def-my-len-val" class="headerlink" title="def my_len(val):"></a>def my_len(val):</h1><h1 id="return-val-len"><a href="#return-val-len" class="headerlink" title="return val.len()"></a>return val.<strong>len</strong>()</h1><h1 id="print-my-len-‘hello’"><a href="#print-my-len-‘hello’" class="headerlink" title="print(my_len(‘hello’))"></a>print(my_len(‘hello’))</h1><h1 id="print-my-len-1-2-3"><a href="#print-my-len-1-2-3" class="headerlink" title="print(my_len([1,2,3]))"></a>print(my_len([1,2,3]))</h1><h1 id="print-my-len-‘a’-1-’b’-2"><a href="#print-my-len-‘a’-1-’b’-2" class="headerlink" title="print(my_len({‘a’:1,’b’:2}))"></a>print(my_len({‘a’:1,’b’:2}))</h1><h1 id="len-‘hello’"><a href="#len-‘hello’" class="headerlink" title="len(‘hello’)"></a>len(‘hello’)</h1><h1 id="len-1-2-3"><a href="#len-1-2-3" class="headerlink" title="len([1,2,3])"></a>len([1,2,3])</h1><h1 id="len-‘a’-1-’b’-2"><a href="#len-‘a’-1-’b’-2" class="headerlink" title="len({‘a’:1,’b’:2})"></a>len({‘a’:1,’b’:2})</h1><h1 id="python推崇的是鸭子类型"><a href="#python推崇的是鸭子类型" class="headerlink" title="python推崇的是鸭子类型"></a>python推崇的是鸭子类型</h1><h1 id="class-Cpu"><a href="#class-Cpu" class="headerlink" title="class Cpu:"></a>class Cpu:</h1><h1 id="def-read-self"><a href="#def-read-self" class="headerlink" title="def read(self):"></a>def read(self):</h1><h1 id="print-‘cpu-read’"><a href="#print-‘cpu-read’" class="headerlink" title="print(‘cpu read’)"></a>print(‘cpu read’)</h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="def-write-self"><a href="#def-write-self" class="headerlink" title="def write(self):"></a>def write(self):</h1><h1 id="print-‘cpu-write’"><a href="#print-‘cpu-write’" class="headerlink" title="print(‘cpu write’)"></a>print(‘cpu write’)</h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="class-Mem"><a href="#class-Mem" class="headerlink" title="class Mem:"></a>class Mem:</h1><h1 id="def-read-self-1"><a href="#def-read-self-1" class="headerlink" title="def read(self):"></a>def read(self):</h1><h1 id="print-‘mem-read’"><a href="#print-‘mem-read’" class="headerlink" title="print(‘mem read’)"></a>print(‘mem read’)</h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><h1 id="def-write-self-1"><a href="#def-write-self-1" class="headerlink" title="def write(self):"></a>def write(self):</h1><h1 id="print-‘mem-write’"><a href="#print-‘mem-write’" class="headerlink" title="print(‘mem write’)"></a>print(‘mem write’)</h1><h1 id="-9"><a href="#-9" class="headerlink" title=""></a></h1><h1 id="-10"><a href="#-10" class="headerlink" title=""></a></h1><h1 id="class-Txt"><a href="#class-Txt" class="headerlink" title="class Txt:"></a>class Txt:</h1><h1 id="def-read-self-2"><a href="#def-read-self-2" class="headerlink" title="def read(self):"></a>def read(self):</h1><h1 id="print-‘txt-read’"><a href="#print-‘txt-read’" class="headerlink" title="print(‘txt read’)"></a>print(‘txt read’)</h1><h1 id="-11"><a href="#-11" class="headerlink" title=""></a></h1><h1 id="def-write-self-2"><a href="#def-write-self-2" class="headerlink" title="def write(self):"></a>def write(self):</h1><h1 id="print-‘txt-write’"><a href="#print-‘txt-write’" class="headerlink" title="print(‘txt write’)"></a>print(‘txt write’)</h1><h1 id="-12"><a href="#-12" class="headerlink" title=""></a></h1><h1 id="-13"><a href="#-13" class="headerlink" title=""></a></h1><h1 id="obj1-Cpu"><a href="#obj1-Cpu" class="headerlink" title="obj1=Cpu()"></a>obj1=Cpu()</h1><h1 id="obj2-Mem"><a href="#obj2-Mem" class="headerlink" title="obj2=Mem()"></a>obj2=Mem()</h1><h1 id="obj3-Txt"><a href="#obj3-Txt" class="headerlink" title="obj3=Txt()"></a>obj3=Txt()</h1><h1 id="-14"><a href="#-14" class="headerlink" title=""></a></h1><h1 id="obj1-read"><a href="#obj1-read" class="headerlink" title="obj1.read()"></a>obj1.read()</h1><h1 id="obj1-write"><a href="#obj1-write" class="headerlink" title="obj1.write()"></a>obj1.write()</h1><h1 id="-15"><a href="#-15" class="headerlink" title=""></a></h1><h1 id="obj2-read"><a href="#obj2-read" class="headerlink" title="obj2.read()"></a>obj2.read()</h1><h1 id="obj2-write"><a href="#obj2-write" class="headerlink" title="obj2.write()"></a>obj2.write()</h1><h1 id="-16"><a href="#-16" class="headerlink" title=""></a></h1><h1 id="obj3-read"><a href="#obj3-read" class="headerlink" title="obj3.read()"></a>obj3.read()</h1><h1 id="obj3-write"><a href="#obj3-write" class="headerlink" title="obj3.write()"></a>obj3.write()</h1><h1 id="了解："><a href="#了解：" class="headerlink" title="了解："></a>了解：</h1><p>import abc</p><p>class Animal(metaclass=abc.ABCMeta): # 统一所有子类的标准<br>    @abc.abstractmethod<br>    def say(self):<br>        pass</p><h1 id="obj-Animal-不能实例化抽象类自己"><a href="#obj-Animal-不能实例化抽象类自己" class="headerlink" title="obj=Animal() # 不能实例化抽象类自己"></a>obj=Animal() # 不能实例化抽象类自己</h1><p>class People(Animal):<br>    def say(self):<br>        pass</p><p>class Dog(Animal):<br>    def say(self):<br>        pass</p><p>class Pig(Animal):<br>    def say(self):<br>        pass</p><h1 id="-17"><a href="#-17" class="headerlink" title=""></a></h1><h1 id="obj1-People"><a href="#obj1-People" class="headerlink" title="obj1=People()"></a>obj1=People()</h1><h1 id="obj2-Dog-1"><a href="#obj2-Dog-1" class="headerlink" title="obj2=Dog()"></a>obj2=Dog()</h1><h1 id="obj3-Pig-1"><a href="#obj3-Pig-1" class="headerlink" title="obj3=Pig()"></a>obj3=Pig()</h1>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python读取Hbase静态数据并绘制多个Echarts图</title>
    <link href="/2021/01/10/Python%E8%AF%BB%E5%8F%96Hbase%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%88%B6%E5%A4%9A%E4%B8%AAEcharts%E5%9B%BE/"/>
    <url>/2021/01/10/Python%E8%AF%BB%E5%8F%96Hbase%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%88%B6%E5%A4%9A%E4%B8%AAEcharts%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>##开始sea<br>from pyecharts import Bar, Line, Scatter, EffectScatter, Grid, Pie</p><p>import happybase<br>import pyecharts<br>#bytes.decode(‘utf-8’)<br>#from pyecharts.charts import Bar<br>from pyecharts import Bar<br>conn=happybase.Connection(“localhost”,9090)<br>table=conn.table(“gdp1”)<br>row=table.row(“AnHui_Province”)<br>#print((row))<br>Anhui_x=[]<br>Anhui_y=[]<br>Anhui_x1=[]<br>#print (row[b’year:2015’].decode(‘utf-8’))<br>for i in range(2000,2015):<br>    Anhui_x.append(i)<br>    Anhui_x1.append(str(i))<br>    a=’year:’+str(i)<br>    a=bytes(a,encoding=’utf-8’)<br>    Anhui_y.append(int(row[a]))<br>    #print(row[a])</p><h1 id="print-Anhui-x"><a href="#print-Anhui-x" class="headerlink" title="print (Anhui_x)"></a>print (Anhui_x)</h1><h1 id="print-Anhui-y"><a href="#print-Anhui-y" class="headerlink" title="print (Anhui_y)"></a>print (Anhui_y)</h1><p>row=table.row(“JiangSu_Province”)<br>#print((row))<br>JS_x=[]<br>JS_y=[]<br>JS_x1=[]<br>#print (row[b’year:2015’].decode(‘utf-8’))<br>for i in range(2000,2015):<br>    JS_x.append(i)<br>    JS_x1.append(str(i))<br>    a=’year:’+str(i)<br>    a=bytes(a,encoding=’utf-8’)<br>    JS_y.append(int(row[a]))</p><h1 id="print-JS-y"><a href="#print-JS-y" class="headerlink" title="print(JS_y)"></a>print(JS_y)</h1><p>keys=[]<br>eco=[]<br>dic={}<br>scaner=table.scan()<br>for k,v in scaner:<br>    row = table.row(k)<br>    a = ‘year:2017’<br>    a = bytes(a, encoding=’utf-8’)<br>    eco.append(int(row[a]))<br>    #k = bytes(k, encoding=’utf-8’)<br>    k=k.decode(‘utf-8’)<br>    #bytes.decode(‘utf-8’)<br>    keys.append(k)<br>    dic[k]=int(row[a])<br>    # print(k)</p><h1 id="print-keys"><a href="#print-keys" class="headerlink" title="print(keys)"></a>print(keys)</h1><h1 id="print-eco"><a href="#print-eco" class="headerlink" title="print(eco)"></a>print(eco)</h1><h1 id="print-dic"><a href="#print-dic" class="headerlink" title="print(dic)"></a>print(dic)</h1><p>key=[]<br>va=[]<br>A=sorted(dic.items(),key=lambda dic:dic[1],reverse=True)<br>j=0<br>for i in A:<br>    key.append(i[0])<br>    va.append(i[1])<br>    j=j+1<br>    if j&gt;5:<br>        break</p><h1 id="print-key"><a href="#print-key" class="headerlink" title="print(key)"></a>print(key)</h1><h1 id="print-va"><a href="#print-va" class="headerlink" title="print(va)"></a>print(va)</h1><h1 id="single"><a href="#single" class="headerlink" title="single=[]"></a>single=[]</h1><p>year=[]<br>year_str=[]<br>all=[]<br>#全国总经济走势</p><p>for i in range(1999, 2018):<br>    # if i==1997:<br>    #     continue<br>    year_str.append(str(i))<br>    a = ‘year:’ + str(i)<br>    year.append(i-1998)<br>    a = bytes(a, encoding=’utf-8’)<br>    sum=0<br>    scaner = table.scan()<br>    for k,v in scaner:<br>        # print(k)</p><pre><code>    row = table.row(k)    #print(int(row[a]))    sum=sum+int(row[a])    # single.append(int(row[a]))all.append(sum)</code></pre><p>print(year)<br>print(all)</p><h1 id="print-table"><a href="#print-table" class="headerlink" title="print(table)"></a>print(table)</h1><p>‘’’<br>    Grid类：并行显示多个图表 TODO 第一个图需为 有 x/y 轴的图，即不能为 Pie，其他位置顺序任意。<br>‘’’<br>attr=Anhui_x</p><p>v1=Anhui_y<br>bar = Bar(“经济柱状图”, title_pos=”65%”)<br>bar.add(“山东”, attr, v1, is_stack=True)<br>bar.add(“滨州”, JS_x, JS_y, is_stack=True, legend_pos=”80%”)</p><p>line = Line(“经济折线图”)<br>attr=Anhui_x1<br>line.add(<br>    “山东”,<br>    attr,<br>    Anhui_y,<br>    mark_point=[“max”, “min”],<br>    mark_line=[“average”],<br>)<br>line.add(<br>    “滨州”,<br>    JS_x1,<br>    JS_y,<br>    mark_point=[“max”, “min”],<br>    mark_line=[“average”],<br>    legend_pos=”20%”,<br>)</p><p>v1 = year<br>v2 = all<br>scatter = Scatter(“全国总经济散点图”, title_top=”50%”, title_pos=”65%”)<br>scatter.add(“scatter”, v1, v2, legend_top=”50%”, legend_pos=”80%”,<br>           # min_=’dataMin’,<br>            )</p><p>x = key<br>y = va<br>pie = Pie(“2017年前六经济饼图”,title_top=”50%”,title_pos=”20”)<br>pie.add(<br>    “2017”,<br>    x,<br>    y,<br>    radius=[15,35],<br>    center=[25,80],<br>    legend_top=”70%”,<br>    legend_pos=”5%”,<br>    legend_orient=”vertical”,<br>)</p><h1 id="TODO-配置Grid类"><a href="#TODO-配置Grid类" class="headerlink" title="TODO 配置Grid类"></a>TODO 配置Grid类</h1><p>grid = Grid(）</p><p>grid.render(“./templates/index.html”)</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python2和python3的区别</title>
    <link href="/2021/01/10/python2%E5%92%8Cpython3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/01/10/python2%E5%92%8Cpython3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>#区别<br>  python的3.0版本，常被称为python3000，简称py3k。相对于python的早期版本，这是一个较大的升级为了不带入过多累赘，python3.0在设计的时候没有考虑向下相容。<br>  许多针对早期python版本设计的程序都无法在python3.0上正常执行。为了照顾现有程序，python2.6作为一个过渡版本，基本使用了python2.x的语法和库，同时考虑了向python3.0的迁移，允许使用部分python3.0的语法与函数。<br>  新的python程序建议使用python3.0版本的语法。除非执行环境无法安装python3.0或者程序本身使用了不支持python3.0的第三方库。目前不支持python的第三方库有Twisted，py2exe，PIL等。<br>大多数第三方库都正在努力的兼容python3.0版本。即使无法立即使用python3.0，也建议编写相容的3.0版本python程序，然后使用2.6，2.7来执行。<br>#一、python3.0的一些变化<br>1.print函数<br>  print语句没有了，取而代之的是print()函数。python2.6与python2.7部分的支持这种形式的print语法。在python2.6与2.7里面以下三种形式是等价的</p><p>print “我是菜鸟”<br>print (我是菜鸟) #注意print后边有个空格<br>print(“我是菜鸟”) #print()不能带有其他任何参数<br>然而python2.6实际上已经支持新的print()语法<br>from _future_import print_function<br>print(“我是个菜鸟”,”我好菜啊”,sep=’, ‘)<br>#2.Unicode<br>python2有ASCII str()类型，unicode()是单独的，不是byte类型。现在python3有了Unicode(utf-8)字符串，以及一个字节类：byte和bytearrays。由于python3.x源码文件默认使用utf-8编码，这就使得以下代码合法</p><p>我没女友=’I have no girlfriends’<br>print(我没女友)<br>#3.除法运算<br>ython中的除法相较于其他语言会高端一些有些很复杂的规则，python中的除法有/与//两个运算符。<br>首先说除法，python2.x和大多数语言一样，比如java和c，整数相除结果是一个整数，把小数部分完全忽略掉，浮点数的除法会保留小数点的部分得到的一个浮点数结果。<br>  python3.x中除法就不再这样做了，对于整数间的相除结果也会是浮点数。（这里可以用0/1来理解）<br>  而对于//除法，这种除法叫floor除法，会对除法的结果自动进行一个floor操作，在python2.x和3.x中是一致的。</p><p>#python2.x与3.x<br>-1//2 #输出值是-1<br>注意的是并不是舍弃小数部分，而是执行floor操作，如果要截取小数部分，那么就需要使用math模块的trunc函数。<br>#4.异常<br>在python3中处理异常也轻微改变了，在python3中，我们使用as作为关键词。捕获异常的语法由 except exc,var改为 except exc as var。<br>  使用语法except(exc1,exc2) as var可以同时捕获多种类别的异常。python2.6已经支持这两种语法。<br>·在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代只有继承BaseException的对象才可被抛出。<br>·2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩写法，直接调用构造函数抛出对象即可。<br>  在2.x时代，异常在代码中除了表示程序错误，还经常做一些普通控制结构应该做的事，在3.x中可以看出，设计者让异常变得更加专一，只有在错误发生的情况下才能用去用异常捕获语句来处理。<br>#5.xrange<br>在python2中xrange()创建迭代对象的用法是非常流行的。比如：for循环或者是列表/集合/字典推导式。<br>  这个表现十分像生成器(比如：“惰性求值”)。但是这个xrange-iterable是无穷的，意味着你可以无限遍历。<br>  由于它的惰性求值，如果你要遍历它多次，xrange()函数比range()函数更快（比如for循环）。尽管如此，对比迭代一次，不建议你迭代多次，因此生成器每次都从头开始。<br>  在python3中，range()是像xrange()那样实现，以至于一个专门的xrange()函数都不再存在（在python3中xrange()会抛出命名异常。<br>#6.八进制字面量表示<br>八进制必须写成0o777，原来的形式0777不能用了；二进制0b111。新增了一个bin()函数用于将一个整数转换成二进制字串。python2.6已经支持这两种语法<br>#7.不等运算符<br>python2.x中不等于 ！=和&lt;&gt;<br>python3.x中不等于只有！=<br>#8.去掉了repr表达式”<br>python2.x中反引号”相当于repr函数的作用<br>python3.x中去掉了”这种写法，只允许repr函数，感觉repr只有debug的时候才用，多数时候还是用str函数来用字符串描述对象。<br>#9.多个模块被改名(根据PEP8)<br>旧名字    新名字<br>_winreg    winreg<br>ConfigParser    configparser<br>copy_reg    copyreg<br>Queue    queue<br>SocketServer    socketserver<br>repr    reprlib<br>  StringIO模块现在被合并到新的io模组内new，md5，gopherlib等模块被删除 。python2.6已经支援新的io模组。<br>  httplibBase，HTTPServer，CGIHTTPServer，SimpleHTTPServer，Cookie，cookerlib被合并到http包内。取消了exec语句只剩下exec()函数。python2.6已经支援exec()函数。<br>#10.数据类型<br>python3.x去除了long类型，现在只有一种整型——int<br>  新增了bytes类型，对应于2.x版本的八位串，定义一个butes字面量方法如下</p><p>b=b’lalala’<br>type(b)<br>#输出&lt;type ‘bytes’&gt;<br>str对象和bytes对象可以使用encode()(str-&gt;bytes)or.decode()(bytes-&gt;str)方法互相转换。</p><p>s=b.decode()<br>b1=s.encode()<br>dict的.keys()、.items和.values()方法返回迭代器，而之前的iterkeys()等函数都被遗弃。同事去掉的还有dict.has_key()，用in替代它吧&gt;_&lt;。</p><p>##总结<br>总之一句话，用python3吧，不要再倔强了！<br>  才开始学习计算机不久，第一次写博客，如果有问题希望大家指正，希望我们能一起学习一起进步。共勉！</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解压一个目录包括子目录中的所有 zip 文件</title>
    <link href="/2021/01/10/%E8%A7%A3%E5%8E%8B%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E5%8C%85%E6%8B%AC%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-zip-%E6%96%87%E4%BB%B6/"/>
    <url>/2021/01/10/%E8%A7%A3%E5%8E%8B%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E5%8C%85%E6%8B%AC%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-zip-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>package unzip;</p><p>import java.io.<em>;<br>import java.nio.charset.Charset;<br>import java.util.</em>;<br>import java.util.concurrent.ConcurrentLinkedQueue;<br>import java.util.zip.ZipEntry;<br>import java.util.zip.ZipFile;</p><p>/**</p><ul><li>@author jeffrey</li><li>@ClassName: UnZip</li><li>@Description: 为偷懒而生，解压一个目录包括子目录中的所有 zip 文件</li><li>@date: 2021/1/9 12:38 上午</li><li>@version:</li><li>@since JDK 1.8</li><li>/</li></ul><p>public class UnZip {</p><pre><code>/** * 用于存放于 zip 文件的安全队列 */public final static ConcurrentLinkedQueue&lt;File&gt; ZIP_QUEUE = new ConcurrentLinkedQueue&lt;&gt;();/** * 如 t1 不存活并 zipQueue 为空则修改为 true */public static boolean isFlag = false;/** * 输入流 */private static final Scanner SCANNER = new Scanner(System.in);/** * 提供一个工作路径 */private static String workPath;/** * 在解压完成后是否删除源文件 *      使用 Boolean 包装类进行判断，True / true 为 true，False / false 为 false，其他依然为 false */public static String isDelete;/** * 在解压文件时发生异常的集合 *      Key：文件名 *      Value：异常对象 */public static final HashMap&lt;File, Exception&gt; unZipFailedMap = new HashMap&lt;&gt;();/** * 找到相关的文件数量 */public static int foundCount = 0;/** * 成功解压的文件数量 */public static int succeedCount = 0;/** * 解压失败的文件数量 */public static int unZipFailedCount = 0;/** * 删除失败的文件个数 */public static int deleteFailedCount = 0;/** * 删除失败的文件名 */public static final HashSet&lt;File&gt; deleteFailedNameList = new HashSet&lt;&gt;();public static void main(String[] args) &#123;    input();    if (new File(workPath).exists()) &#123;            Thread t1 = new Thread(new FindZipFile(new File(workPath)));            Thread t2 = new Thread(new UnZipFile(ZIP_QUEUE));            t1.start();            t2.start();            while (true) &#123;                if (!t1.isAlive() &amp;&amp; ZIP_QUEUE.isEmpty()) &#123;                    isFlag = true;                    if (!t2.isAlive()) &#123;                        System.out.println                        (                                &quot;\n\n\n&quot; +                                &quot;共找到了 &quot; + foundCount + &quot; 个文件\n&quot; +                                &quot;成功解压了 &quot; + succeedCount + &quot; 个文件\n&quot; +                                        unZipFailedCount + &quot; 个文件解压失败，以下是失败原因：&quot;                        );                        Set&lt;Map.Entry&lt;File, Exception&gt;&gt; failedElement = unZipFailedMap.entrySet();                        for (Map.Entry&lt;File, Exception&gt; fileExceptionEntry : failedElement) &#123;                            System.out.println(&quot;文件：&quot; + fileExceptionEntry.getKey() + &quot; 异常：&quot; + fileExceptionEntry.getValue());                        &#125;                        if (deleteFailedCount &gt; 0) &#123;                            System.out.println(&quot;另外，还有一些文件删除失败，可能是在解压过程中失败了导致它们不被删除，它们是：&quot;);                            for (File file : deleteFailedNameList) &#123;                                System.out.println(file);                            &#125;                        &#125;                        break;                    &#125;                &#125;        &#125;    &#125;else&#123;        System.out.println(&quot;提供的工作路径不准确&quot;);    &#125;&#125;private static void input() &#123;    System.out.println(&quot;提供一个工作路径：&quot;);    workPath = SCANNER.nextLine();    System.out.println(&quot;成功解压完成后是否删除源文件（true / false）：&quot;);    isDelete = SCANNER.nextLine();&#125;</code></pre><p>}</p><p>class UnZipFile extends Thread {<br>    private final ConcurrentLinkedQueue<File> zipQueue;<br>    private static final int  BUFFER_SIZE = 2 * 1024;</p><pre><code>public UnZipFile(ConcurrentLinkedQueue&lt;File&gt; zipQueue) &#123;    this.zipQueue = zipQueue;&#125;@Overridepublic void run() &#123;    do &#123;        if (!zipQueue.isEmpty()) &#123;            File file = zipQueue.poll();            String fileName = file.getName();            File destPathName = new File(file.getParent(), fileName.substring(0, fileName.indexOf(&quot;.&quot;)));            System.out.println(destPathName.mkdirs());            unZip(file, destPathName.toString());        &#125;    &#125; while (!UnZip.isFlag);&#125;public void unZip(File srcFile, String destDirPath) throws RuntimeException &#123;    long start = System.currentTimeMillis();    // 开始解压    ZipFile zipFile = null;    FileOutputStream fos = null;    InputStream is = null;    try &#123;        zipFile = new ZipFile(srcFile, Charset.forName(&quot;GBK&quot;));        Enumeration&lt;?&gt; entries = zipFile.entries();        while (entries.hasMoreElements()) &#123;            ZipEntry entry = (ZipEntry) entries.nextElement();            File unZipPathName = new File(entry.getName());            if (!unZipPathName.isDirectory())&#123;                if (unZipPathName.getName().contains(&quot;.zip&quot;)) &#123;                    zipQueue.add(new File(srcFile.getParentFile(), unZipPathName.toString()));                    System.out.println(&quot;俄罗斯套娃文件：&quot; + unZipPathName);                &#125;            &#125;            System.out.println(&quot;解压：&quot; + unZipPathName);            // 如果是文件夹，就创建个文件夹            if (entry.isDirectory()) &#123;                String dirPath = destDirPath + File.separator + entry.getName();                File dir = new File(dirPath);                if(dir.mkdirs())&#123;                    System.out.println(&quot;No need to create&quot;);                &#125;            &#125; else &#123;                // 如果是文件，就先创建一个文件，然后用io流把内容copy过去                File targetFile = new File(destDirPath + File.separator + entry.getName());                // 保证这个文件的父文件夹必须要存在                if(!targetFile.getParentFile().exists())&#123;                    if(targetFile.getParentFile().mkdirs())&#123;                        System.out.println(&quot;No need to create&quot;);                    &#125;                &#125;                if (targetFile.createNewFile())&#123;                    System.out.println(&quot;No need to create&quot;);                &#125;                // 将压缩文件内容写入到这个文件中                is = zipFile.getInputStream(entry);                fos = new FileOutputStream(targetFile);                int len;                byte[] buf = new byte[BUFFER_SIZE];                while ((len = is.read(buf)) != -1) &#123;                    fos.write(buf, 0, len);                &#125;                fos.flush();                if (Boolean.parseBoolean(UnZip.isDelete))&#123;                    if(srcFile.delete())&#123;                        System.out.println(&quot;成功删除：&quot; + srcFile);                    &#125;else&#123;                        UnZip.deleteFailedNameList.add(srcFile);                        UnZip.deleteFailedCount++;                    &#125;                &#125;            &#125;        &#125;        long end = System.currentTimeMillis();        UnZip.succeedCount++;        System.out.println(&quot;解压完成，耗时：&quot; + (end - start) +&quot; ms&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();        UnZip.unZipFailedCount++;        UnZip.unZipFailedMap.put(srcFile, e);    &#125; finally &#123;        if(zipFile != null)&#123;            try &#123;                zipFile.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (fos != null)&#123;            try &#123;                fos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (is != null)&#123;            try &#123;                is.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>}</p><p>class FindZipFile extends Thread {<br>    private final File file;</p><pre><code>public FindZipFile(File file) &#123;    this.file = file;&#125;@Overridepublic void run() &#123;    find(file);&#125;public void find(File path)&#123;    File[] files = path.listFiles();    if (files != null) &#123;        for (File file : files) &#123;            if (file.isDirectory())&#123;                find(file);            &#125;else&#123;                UnZip.foundCount++;                String absolutePath = file.getAbsolutePath();                String[] split = absolutePath.split(&quot;\\.&quot;);                if (&quot;zip&quot;.equalsIgnoreCase(split[split.length - 1]))&#123;                    UnZip.ZIP_QUEUE.add(file);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择结构 分支结构 循环结构 方法 数组 面向对象 关键字</title>
    <link href="/2021/01/10/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-%E6%96%B9%E6%B3%95-%E6%95%B0%E7%BB%84-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/01/10/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-%E6%96%B9%E6%B3%95-%E6%95%B0%E7%BB%84-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>##一、选择结构与分支结构<br>概念：<br>根据已知条件‘进行逻辑判断，满足条件后执行相应操作;<br>#1.1基本if选择结构<br>语法：if(布尔表达式){<br>//代码块<br>}<br>//后续代码…..<br>执行流程：<br>对布尔表达式进行判断；<br>结果为true，则先执行代码块，再执行后续代码；<br>结果为false，则跳过代码块，直接执行后续代码；<br>#1.2if else选择结构<br>if(布尔表达式){<br> //代码块1<br>}else{<br> //代码块2<br>}<br>执行流程：<br>对布尔表达式进行判断；<br>结果为true，则先执行代码块1，再退出整个结构，执行后续代码；<br>结构为false，则先执行代码块2，再退出整个结构，执行后续代码；<br>#1.3多重if选择结构<br>if(布尔表达式1){<br>//代码块1<br>}else if(布尔表达式2){<br>//代码块2<br>}else if(布尔表达式3){<br>//代码块3<br>}else{<br>//代码块4<br>}<br>执行流程：<br>表达式1为true时，则执行代码块1，再退出整个结构；<br>表达式2为true时，则执行代码块2，再退出整个结构；<br>表达式3为true时，则执行代码块3，再退出整个结构；<br>以上均为false时，则执行代码块4，再退出整个结构；<br>注意：<br>相互排斥，有一个为true，其它均不再执行，适用于区间判断（区间条件，遵循从大到小或从小到大）；<br>#1.4嵌套if选择结构<br>if(外层表达式){<br> if(内层表达式){<br>  //内层代码块1<br> }else{<br>  //内层代码块2<br> }<br>}else{<br>//外层代码块<br>}<br>执行流程：<br>当外层条件满足时，再判断内层条件；<br>注意：<br>一个选择结构中，可以嵌套另一个选择结构；<br>嵌套格式正确的情况下，支持任意组合；<br>#举例<br>需求:</p><ul><li><pre><code>     键盘录入三个数据,求最大值(int类型)</code></pre></li><li></li><li><pre><code>    两种方案</code></pre></li><li><pre><code>     1)使用三元运算符去完成</code></pre></li><li><pre><code>     2)使用if格式2的嵌套</code></pre></li></ul><p>import  java.util.Scanner ;<br>public class IfTest2 {<br>    public static void main(String[] args){</p><pre><code>    //创建键盘录入对象    Scanner sc = new Scanner(System.in);    //提示并录入数据    System.out.println(&quot;请您输入第一个数据:&quot;) ;    int a = sc.nextInt() ;    System.out.println(&quot;请您输入第二个数据:&quot;) ;    int b = sc.nextInt() ;    System.out.println(&quot;请您输入第三个数据:&quot;) ;    int c = sc.nextInt() ;     //方案1:    //三元运输符 (表达式)? 执行true的结果:执行false的结果    //使用中间变量    int temp = (a&gt; b) ? a: b ;    //定义结果变量    int max = (temp &gt; c)? temp :c ;    System.out.println (&quot;三个数据中的最大值是:&quot;+max) ;    System.out.println(&quot;---------------------------------------&quot;) ;    //方式2:if格式2的嵌套 (不推荐的)    //定义变量max2    int max2 ;    if(a &gt; b)&#123;        //使用a和c进行对比        if(a&gt; c)&#123;           max2 = a ;        &#125;else&#123;           max2 = c ;        &#125;    &#125;else &#123;        //b大        if(b &gt; c)&#123;            max2 = b ;        &#125;else&#123;            max2 = c ;        &#125;    &#125;    System.out.println(&quot;三个数据中的最大值是:&quot;+max2) ;&#125;</code></pre><p>}<br>#1.5switch分支结构<br>switch(变量|表达式){<br> case  值1:<br>  逻辑代码1;<br> case  值2:<br>  逻辑代码2;<br> case  值n:<br>  逻辑代码n;<br> default:<br>  未满足时的逻辑代码;<br>}</p><p>可判断的类型：<br>byte、short、int、char、String(JDK7+)<br>执行流程：<br>如果变量中的值等于值1，则执行逻辑代码1；<br>如果变量中的值等于值2，则执行逻辑代码2；<br>如果变量中的值等与值n，则执行逻辑代码n；<br>如果变量中的值没有匹配的case值时，执行default中的逻辑代码；</p><p>注意：</p><p>所有case的取值不可相同；<br>程序演示：</p><p>import  java.util.Scanner  ;<br>public class SwitchDemo {</p><pre><code>public static void main(String[] args)&#123;    //创建键盘录入数据    Scanner sc = new Scanner(System.in) ;    //提示并录入数据    System.out.println(&quot;请您输入一个int数据:&quot;);    int week = sc.nextInt() ;     switch (week)&#123;        case 1 :            System.out.println(&quot;星期一&quot;);            break ;        case 2 :            System.out.println(&quot;星期二&quot;);            break ;        case 3 :            System.out.println(&quot;星期三&quot;);            break ;        case 4 :            System.out.println(&quot;星期四&quot;);            break ;        case 5 :            System.out.println(&quot;星期五&quot;);            break ;        case 6 :            System.out.println(&quot;星期六&quot;);            break ;        case 7 :            System.out.println(&quot;星期日&quot;);            break ;        default:            System.out.println(&quot;您输入的数据不合法&quot;);            break ;    &#125;&#125;</code></pre><p>}<br>注意：<br>当匹配的case被执行后，并不会自动退出整个结构，而是继续向下执行；<br>break关键字可以在匹配的case执行后，直接跳出整个结构；<br>##二、循环结构<br>for(初始化语句;条件判断语句;步长语句(控制体语句)){</p><pre><code>  循环体语句;</code></pre><p>  }<br>   流程:<br>  1)先执行初始化语句对变量进行赋值(只执行一次)<br>  2)判断条件语句是否成立,如果成立,执行  循环体语句<br>  3)执行步长语句(++,–)<br>  4)继续判断条件是否成立,如果还成立, 执行  循环体语句<br>  5)继续执行步长语句(++,–)<br>  …<br>  …<br>  n)当前条件不成立,for循环结束<br>  举例<br>  需求:</p><ul><li> 1)控制台输出1-10之间的数据</li><li> 2)求出1-10之间和</li><li> 3)1-100之间的数据之和</li></ul><p>public class ForDemo {<br>    public static void main(String[] args){<br>for(int x = 1 ; x &lt;= 10 ; x ++){<br>    System.out.println(x) ;<br>       }<br>//1-10之间的数据获取<br>int sum = 0 ;<br>for(int x = 1 ; x &lt;= 10 ; x ++){<br>   sum += x ; //sum = sum + x ;</p><pre><code>  &#125;</code></pre><p>System.out.println(“1-10之间的数据和是:”+sum);<br>  }<br>}<br>#2.2while循环语句<br>  while(条件表达式){<br>          循环体语句;<br>          控制体/步长语句;<br>      }<br>      扩展格式：<br>初始化语句;<br>while(条件判断语句){<br>循环体语句;<br>控制体/步长语句;<br>}<br>流程:<br>初始化语句执行一次<br>判断条件是否成立,成立,则执行循环体,再依次执行步长语句;<br>…<br>如果不成立,while循环语句结束!<br>举例<br>//需求:键盘不断录入数据,玩猜数字小游戏! (1-100之间的数据)</p><p>//分析:<br>//1)使用Math类的 random方法产生一个1-100之间的随机数 (要猜的数据)<br>//2)创建键盘录入对象,录入数据<br>//3)录入的数据和当前产生的随机数据的进行比较,<br>//4)如果大了,提示大了<br>//小了,提示小了<br>//相等,猜中了</p><p>//break:switch语句中,循环语句中使用</p><p>//产生一个1-100之间的随机数<br>int num = (int)(Math.random()*100+1) ;</p><p>while(true){<br>    //导包<br>    //创建键盘录入对象<br>    Scanner sc = new Scanner(System.in) ;</p><pre><code>//提示并录入数据System.out.println(&quot;请您输入1-100之间的数字:&quot;) ;int guessNumber = sc.nextInt() ;if(guessNumber&gt; num)&#123;    System.out.println(&quot;您要猜的数字大了!&quot;);&#125;else if(guessNumber &lt; num)&#123;    System.out.println(&quot;您要猜的数字小了!&quot;) ;&#125;else&#123;    System.out.println(&quot;恭喜您,猜中了!&quot;) ;    break ; //中断循环,否则死循环...&#125;</code></pre><p>}<br>需求:</p><ul><li><pre><code>输出所有的水仙花数</code></pre></li><li><pre><code>统计所有的水仙花数</code></pre></li></ul><p>public class WhileDemo {</p><pre><code>public static void main(String[] args)&#123; //输出所有的水仙花数    //初始化语句    int j = 100 ;    while(j&lt;1000)&#123;        //定义三个变量:ge shi bai        int ge = j % 10 ;        int shi = j /10 % 10 ;        int bai = j /10 /10 % 10 ;        if(j == (ge*ge*ge+shi*shi*shi+bai*bai*bai))&#123;            //输出            System.out.println(j)  ;         &#125;        j ++ ;    &#125;    System.out.println(&quot;-----------------------------------&quot;) ;    //统计水仙花    //定义统计变量    int count = 0 ;    //初始化语句    int i = 100 ;    while(i&lt;=999)&#123;        //定义三个变量:ge shi bai        int ge = i % 10 ;        int shi = i /10 % 10 ;        int bai = i /10 /10 % 10 ;        if(i == (ge*ge*ge+shi*shi*shi+bai*bai*bai))&#123;            //统计变量++            count ++ ;        &#125;        //步长语句        i ++;    &#125;    System.out.println(&quot;水仙花是共有:&quot;+count+&quot;个&quot;);&#125;</code></pre><p>}</p><p>while和for的区别<br>1)格式不同<br>2) 并且从内存角度考虑:<br>for循环的 格式: for循环语句外面不能够访问变量的,因为它随着for循环执行完毕,main方法结束之后,变量就会被GC(垃圾回收器)回收掉这些变量<br>while循环的扩展格式:循环结束,依然可以访问变量; 在内存中占用资源空间大于for循环<br>3)如果明确循环次数,优先使用for<br>不明确循环次数,使用while循环<br>#2.4do-while循环<br>初始化语句;<br>do{<br>循环体语句;<br>步长语句/控制体语句;<br>}while(条件表达式) ;<br>流程:<br>初始化语句执行一次,对变量进行赋值<br>执行循环体语句,<br>执行步长语句(++或者–)<br>判断while后的条件是否成立,成立,继续执行循环体语句…<br>不成立,语句结束!</p><p>do-while循环和for循环以及while循环的最大的区别就是:循环体至少执行一次!<br>举例<br>public class DoWhileDemo {<br>    public static void main(String[] args){</p><pre><code>    //控制台输出5次&quot;helloworld&quot;   // int i = 1 ;    int i = 6 ;    do&#123;        System.out.println(&quot;helloworld&quot;) ;        i++;    &#125;while(i&lt;=5) ;&#125;</code></pre><p>}<br>#2.5forfor循环嵌套<br>for循环嵌套<br>      for(初始化语句;条件表达式;步长语句){</p><pre><code>      //内层循环是外层循环的循环体语句      for(初始化语句;条件表达式;步长语句)&#123;              循环体语句;      &#125;  &#125;  注意：</code></pre><p>将内层循环看成是外层循环的循环体语句;<br>举例<br>需求:<br>  控制台输出<em>形(4行5列的</em>)<br>      <strong><strong>*<br>      *</strong></strong><br>      <strong><strong>*<br>      *</strong></strong><br>public class ForForDemo {<br>    public static void main(String[] args){<br>  for(int x = 0; x &lt; 4 ; x ++ ){//x =0 ,1,2,3  //控制行数</p><pre><code>        for(int y = 0 ; y &lt; 5; y++)&#123;//y =0,1,2,3,4 //控制列数            System.out.print(&quot;*&quot;) ;        &#125;        System.out.println() ;    &#125;&#125;</code></pre><p>}</p><p>##三、方法<br>3.1.1有具体返回值(数据类型)的方法<br>                                                //  形式参数列表<br>权限修饰符 + 静态修饰符 + 具体的返回值类型 + 方法名(数据类型1 变量名1 ,<br>数据类型2 变量名2 ,….){<br>              //方法体<br>              return 结果;<br>        }<br> 3.1.2没有具体返回值类型的方法     </p><ul><li><pre><code>     权限修饰符+静态修饰符+返回值类型 +方法名(形参列表)&#123;</code></pre></li><li><pre><code>                  没有return 语句 ;</code></pre></li><li><pre><code>                  直接完成输出操作</code></pre></li><li></li><li><pre><code>     &#125;</code></pre>定义方法有两个明确:</li></ul><p>1.明确放回值类型<br>2.明确参数类型和个数<br>3.2如何调用方法<br>调用方法:<br>1)单独调用:(没有输出)没有意义<br>2)输出调用:输出:写死了,不利于值的进一步操作<br>3)赋值调用(推荐)<br>3.3方法的重载<br>概念：<br>多个方法的方法名相同,参数列表不同,与返回值无关 —将这些方法称为”方法重载”<br>参数列表不同有两种情况<br>1)参数个数不同 (参数类型一致)<br>2)参数类型不一致(参数个数一致)<br>         public static float sum(float a,float b) {}<br>         public static float sum(int a,float b){}<br>         public static int  sum(int a,int b){}<br>         public static double sum(double a,double b,double c)<br>         public static int add(int a,float b)<br>         public static int add(float a ,int b)</p><p>##四·数组<br>4.1数组概述<br>数组概念<br>数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。<br>数组既可以存储基本数据类型，也可以存储引用数据类型。<br>数组定义的格式</p><p>格式1：数据类型[] 数组名;<br>格式2：数据类型 数组名[];<br>4.2数组的初始化<br>数组初始化概述：<br>Java中的数组必须先初始化,然后才能使用。<br>所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。<br>数组的初始化方式：<br>动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。<br>静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。<br>动态初始化<br>动态初始化初始化时只指定数组长度，由系统为数组分配初始值<br>格式：<br>数据类型[] 数组名 = new 数据类型[数组长度];<br>数组长度其实就是数组中元素的个数。</p><p>int[] arr = new int[3];</p><p>解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值。<br>静态初始化<br>静态初始化初始化时指定每个数组元素的初始值，由系统决定数组长度。<br>格式：<br>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};</p><p>int[] arr = new int[]{1,2,3};<br>解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值，并且值分别是1,2,3。<br>其实这种写法还有一个简化的写法<br>int[] arr = {1,2,3};<br>便利数组<br>//给int[]a={15,20,25,56,78,89,65};进行遍历,格式优雅<br>public class Demo {<br>    public static void main(String[] args){<br>        int[] a={15,20,25,56,78,89,65};<br>        System.out.print(“[“);//先输出左中括号”[“不换行<br>         //将元素的内容先获取到<br>        for(int i=0;i&lt;a.length;i++){ //i:数组中角标值(索引值)<br>            //需要判断元素是否为最后一个<br>            if (i==a.length-1){// 如果是最大角标值 a.length-1<br>                System.out.println(a[i]+”]”);<br>            }else{//表示是中间的元素,拼接逗号和空格,不能换行<br>                System.out.print(a[i]+”, “);<br>            }<br>        }<br>    }<br>}</p><h2 id="求数组的最值问题"><a href="#求数组的最值问题" class="headerlink" title="求数组的最值问题```"></a>求数组的最值问题```</h2><p>```java<br>//定义一个数组,静态初始化 int[] arr = {12,87,69,24,65};<br>//使用方法得到最值<br>public class Demo1 {<br>   public static  void main(String[] args){<br>       int[] arr = {12,87,69,24,65};<br>       int max = max(arr);<br>        System.out.println(“最大值是:”+max);<br>        System.out.println(“———————“);<br>       int min = min(arr);<br>       System.out.println(“最小值是:”+min);</p><p>   }<br>    public static int max(int arr[]){<br>       int max=arr[0];<br>       for(int i=1;i&lt;arr.length;i++){<br>           if(arr[i]&gt;max){<br>            max = arr[i];<br>           }<br>       }<br>       return max;<br>    }<br>    public static int min(int arr[]){<br>        int min=arr[0];<br>        for(int i=1;i&lt;arr.length;i++){<br>            if(arr[i]&lt;min){<br>                min = arr[i];<br>            }<br>        }<br>        return min;<br>    }</p><p>}</p><p>数组的逆序</p><p>//给定一个数组，把这个数组中所有元素顺序进行颠倒。（静态初始化）int arr[]={66,78,95,5,68,105}<br>public class test2 {<br>    public static  void main(String[] args){<br>        int arr[]={66,78,95,5,68,105};</p><pre><code>    System.out.println(&quot;逆序前:&quot;);    zx(arr);    System.out.println(&quot;逆序后:&quot;);    nx(arr);    zx(arr);&#125;public static void zx(int arr[])&#123;    System.out.print(&quot;[&quot;);    for(int x = 0;x&lt;arr.length;x++)&#123;        if(x==arr.length-1)&#123;            System.out.println(arr[x]+&quot;]&quot;);        &#125;else &#123;            System.out.print(arr[x]+&quot;, &quot;);        &#125;    &#125;&#125;public static void nx(int arr[])&#123;    for (int start=0,end =arr.length-1;start&lt;end;start++,end--)&#123;        int temp = arr[start];        arr[start] = arr[end];        arr[end] = temp;    &#125;&#125;</code></pre><p>}<br>查询数组索引值<br>//int[] arr = {10,55,30,24,17} ;查询30这个元素第一次在数组中出现的索引,查询元素使用功能完成!<br>public class test4 {<br>    public static void main(String[] args){<br>        int[] arr = {10,55,30,24,17} ;<br>        int key=jb(arr,17);<br>        System.out.println(“角标是:”+key);</p><pre><code>&#125;public static int jb(int arr[],int key)&#123;    for(int x =0;x&lt;arr.length;x++)&#123;        if (key == arr[x])&#123;            return x;        &#125;    &#125;    return -1;&#125;</code></pre><p>}<br>数组之冒泡排序<br>public class tset1 {<br>    public static void main(String[] args){<br>    int arr[]={78,56,13,98,105};</p><pre><code>    System.out.println(&quot;排序前:&quot;);    bl(arr);//遍历    System.out.println(&quot;排序后:&quot;);    maopao(arr);//调用方法来排序    bl(arr);//遍历&#125;public static void maopao(int arr[])&#123;    for (int x=0;x&lt;arr.length-1;x++)&#123;//0,1,2,3循环的次数        for (int y=0;y&lt;arr.length-1-x;y++)&#123;//y是角标0,1,2,3,4            if(arr[y]&gt;arr[y+1])&#123;//判断:如果前面的元素比后面元素大,将大的元素往后放                int temp=arr[y];//交互元素----采用中间变量的方法                arr[y]=arr[y+1];                arr[y+1]=temp;            &#125;        &#125;    &#125;&#125;//遍历数组public static void bl(int arr[])&#123;    System.out.print(&quot;[&quot;);    for (int x=0;x&lt;arr.length;x++)&#123;        if (x==arr.length-1)&#123;            System.out.println(arr[x]+&quot;]&quot;);        &#125; else &#123;            System.out.print(arr[x]+&quot;, &quot;);        &#125;    &#125;&#125;</code></pre><p>}<br>##五、面向对象<br>面向对象思想概述以及特点<br>思想概述:<br>面向对象是基于面向过程的编程思想<br>特点：<br>1.是一种更符合我们思想习惯的思想<br>2. 可以将复杂的事情简单化<br>3. 将我们从执行者变成了指挥者角色发生了转换<br>Java语言的面向对象特征:<br>封装(encapsulation) 继承(inheritance) 多态(polymorphism)<br>5.1类与对象关系<br>类：是一组相关的属性和行为的集合<br>类—Java中的最基本单元</p><p>对象：是该类事物的具体体现(应该是指定的某个类中具体的事物)<br>类的定义<br>例如：现实世界的事物 属性 人的身高，体重等 行为 人可以学习，吃饭等Java中用class描述事物也是如此</p><p>成员变量: 就是事物的属性</p><p>成员方法: 就是事物的行为 定义类其实就是定义类的成员(成员变量和成员方法)<br>5.2匿名对象<br>匿名对象：就是没有名字的对象。<br>是对象的一种简化表示形式<br>匿名对象的两种使用情况<br>对象调用方法仅仅一次的时候<br>作为实际参数传递<br>5.3封装<br>Java提供一个关键字:private 封装<br>封装概述:是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。<br>封装原则：<br>将不需要对外提供的内容都隐藏起来。<br>把属性隐藏，提供公共方法对其访问。<br>##六、关键字<br>6.1private关键字<br>private关键字：<br>是一个权限修饰符。<br>可以修饰成员(成员变量和成员方法)<br>被private修饰的成员只在本类中才能访问。<br>private最常见的应用：<br>把成员变量用private修饰<br>提供对应的getXxx()/setXxx()方法<br>一个标准的案例的使用\</p><p>6.2this关键字<br>this:代表所在类的对象引用<br>记住：<br>方法被哪个对象调用，this就代表那个对象<br>什么时候使用this呢?<br>局部变量隐藏成员变量<br>举例<br>/*</p><ul><li>将下面的需求写完后进行测试！<br>  编写一个矩形类Rect，包含：<br>  矩形的宽width；矩形的高height。<br>  两个构造方法：<pre><code>  一个带有两个参数的构造方法，用于将width和height属性初化；  一个不带参数的构造方法，将矩形初始化为宽和高都为10。</code></pre>  两个方法：<pre><code>  求矩形面积的方法area()  求矩形周长的方法perimeter()</code></pre></li><li></li><li>*/</li></ul><p>//创建一个矩形类<br>class Rect{<br>    //定义成员变量,并封装private<br>    private int width;<br>    private int height;<br>    public void setWidth(int width){<br>        this.width=width;<br>    }<br>    public int getWidth(){<br>        return width;<br>    }<br>    public void setHeight(int height){<br>        this.height=height;<br>    }<br>    public int getHeight(){<br>        return height;<br>    }<br>    //定义构造方法<br>    public Rect(){//无参数构造</p><pre><code>&#125;public Rect(int width,int height)&#123;//有参数构造方法    this.width=width;    this.height=height;&#125;//创建成员方法public  int mainji(int width,int height)&#123;//计算面积    return width*height;&#125;public  int zhouchang(int width,int height)&#123;//计算周长    return (width+height)*2;&#125;</code></pre><p>}</p><p>//矩形方法测试区<br>public class RectTest {<br>    public static void main(String[] args){<br>        Rect r=new Rect(10,10);//创建一个矩形对象</p><pre><code>   int a= r.mainji(r.getWidth(),r.getHeight());//调用方法算面积    System.out.println(&quot;矩形的面积是:&quot;+a);//输出    int b=r.zhouchang(r.getWidth(),r.getHeight());//调用方法算周长    System.out.println(&quot;矩形的周长是:&quot;+b);//输出周长&#125;</code></pre><p>}</p><p>ok完结</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring boot小白第一天 spring概述和简述</title>
    <link href="/2021/01/10/Spring-boot%E5%B0%8F%E7%99%BD%E7%AC%AC%E4%B8%80%E5%A4%A9-spring%E6%A6%82%E8%BF%B0%E5%92%8C%E7%AE%80%E8%BF%B0/"/>
    <url>/2021/01/10/Spring-boot%E5%B0%8F%E7%99%BD%E7%AC%AC%E4%B8%80%E5%A4%A9-spring%E6%A6%82%E8%BF%B0%E5%92%8C%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>##SpringBoot第一天<br>欢迎使用Markdown编辑器-JHui<br>springboot总结<br>1.2 编写第一个springboot工程<br>1.2.1 使用maven工具构建一个maven项目<br>1.2.2 在pom文件中引入父级依赖(spring boot项目启动时自动配置 pom文件如下<br>  <parent><br>        <groupId>org.springframework.boot</groupId><br>        <artifactId>spring-boot-starter-parent</artifactId><br>        <version>2.0.1.RELEASE</version><br>    </parent><br> <img src="https://img-blog.csdnimg.cn/20210109194916801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="pom第一步"></p><p> 1.2.3 在pom文件引入web启动器<br>         <!--             web 启动器  spring的自动配置         --><br>         <dependency><br>             <groupId>org.springframework.boot</groupId><br>             <artifactId>spring-boot-starter-web</artifactId><br>         </dependency></p><p>  1.2.4编写一个controller<br>  <img src="https://img-blog.csdnimg.cn/20210109195040790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="controller"></p><p>  1.2.5 编写springboot的启动类 这项目为 App.class 启动类  启动springboot项目<br>  <img src="https://img-blog.csdnimg.cn/20210109195125862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="App.class"></p><p>  @SpringbootApplication<br>  public class App{<br>     public static void main(String[] args) {<br>            SpringApplication.run(App.class,args);<br>        }<br>  }</p><p>1.3 构建springboot项目需要哪些细节<br>1.3.1 parent标签里面到底定义了什么<br>spring-boot-starter-parent继承了 spring-boot-dependencies，在spring-boot-dependencies<br>定义了大量的第三方技术的依赖 并做了相应的版本控制，我们需要引入某个技术的启动器，如果这个启动器<br>在spring-boot-starter-parent里面存在，那么springboot项目在运行时，会进行对应启动器的<br>自动配置<br>1.3.2 spring-boot-starter-web里面定义了什么<br>json格式数据装换的依赖 ，springmvc的依赖 ，tomcat依赖。。。。<br>1.3.3 spring boot如何进行包扫描?<br> 在springboot启动器上@SpringBootApplication    有@ComponentScan<br> <img src="https://img-blog.csdnimg.cn/20210109195332487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJSmlhSHVpMjMy,size_16,color_FFFFFF,t_70#pic_center" alt="ComponentScan"></p><p> 注解专门进行包扫描的操作  扫描当前注解所在的类的包下的所有子包<br>#拓展<br>Integer 和 int 到底底层有什么区别</p><p>1、Integer是int的包装类，int则是java的一种基本数据类型</p><p>2、Integer变量必bai须实例化后才能使用，而int变量不需要</p><p>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。<br>4、Integer的默认值是null，int的默认值是0<br>#扩展资料：</p><p>integer，整数 / 整型数，与小数 / 浮点数相对，是编程语言的基本数据类型之一，用以指示变量的数据类型，有时也用于常量（变量、表达式）的强制数据类型转换。整型数据的长度及其取值范围并不固定，受编译环境影响。在不同的编程语言中做此类型声明时，具体实现方式也可能会有所区别。</p><p>Integer 一个整型数据用来存储整数，整数包括正整数，负整数和零。整型常量采用十进制整数表示。如 1991，0，-123等等都是整型常量。而52.0或131.4都不是整型常量。</p><p>Integer 变量存储为最接近编译环境的长度，例如在32位的编译环境下，Integer为32位，其范围为 -2^15 到 2^15-1 之间。VB中Integer 的类型声明字符是百分比符号 (%)。Pascal中就是integer。在C语言中被缩写成为int。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML,javaScript,JQuery中怎么自定义属性</title>
    <link href="/2021/01/10/HTML-javaScript-JQuery%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/01/10/HTML-javaScript-JQuery%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>有两种方式选择，第一种是使用【data-名称】来实现自定义属性，这种方式在浏览器查看源代码时在标签上是看不到属性的；第二种就是直接使用【名称】来实现。<br>#方式一：直接在HTML标签中使用data-名称来进行定义即可<br>eg:<span data-age="22">hello</span><br><span age="22">hello</span></p><p>Tips:!!!【data-名称】这种方式的自定义属性，在使用js取值时，一定要把名称小写，不然取不到值。<br>#方式二：使用JavaScript进行设置自定义属性<br>/**</p><ul><li><ol><li>原生JavaScript操作</li></ol></li><li>/<br>var obj = document.getElementById(“hello”);<br>//方式1：<br>obj.setAttribute(“age”,”123456”);<br>//方式2：<br>obj.attributes[“age”].nodeValue = “123456”;<br>Tips:<br>JavaScript设置的自定义属性，用户查看源码在标签上也是看不到的<br>#方式三：使用JQuery进行设置自定义属性<br>$(function () {<pre><code>/** * 方法一：attr() */// 设置值$(&quot;#hello&quot;).attr(&quot;info&quot;,&quot;你好&quot;);// 设置多个值$(&quot;#hello&quot;).attr(&#123; name: &quot;Tom&quot;, age: &quot;22&quot; &#125;);/** * 方法二：data() */$(&quot;#hello&quot;).data(&quot;hope&quot;, &quot;年薪100k&quot;);</code></pre>})<br>Tips: 两种方法在标签上都是看不到属性的。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html前端css实现霓虹按钮</title>
    <link href="/2021/01/10/html%E5%89%8D%E7%AB%AFcss%E5%AE%9E%E7%8E%B0%E9%9C%93%E8%99%B9%E6%8C%89%E9%92%AE/"/>
    <url>/2021/01/10/html%E5%89%8D%E7%AB%AFcss%E5%AE%9E%E7%8E%B0%E9%9C%93%E8%99%B9%E6%8C%89%E9%92%AE/</url>
    
    <content type="html"><![CDATA[<p>视频<br>视频链接：<a href="https://www.bilibili.com/video/BV1Zi4y1F7ut">https://www.bilibili.com/video/BV1Zi4y1F7ut</a></p><p>#HTML<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>sea海洋</title>    <link rel="stylesheet" href="style.css"></head><body>    <!-- 容器 -->    <div class="container">        <!-- 按钮 -->        <a href="#" style="--x:0"><span>sea</span></a>        <a href="#" style="--x:1"><span>sea</span></a>        <a href="#" style="--x:2"><span>sea</span></a>        <a href="#" style="--x:3"><span>点赞</span></a>        <a href="#" style="--x:4"><span>评论</span></a>        <a href="#" style="--x:5"><span>sea</span></a>    </div></body></html><p>#CSS<br>/* 清除浏览器默认边距，<br>使边框和内边距的值包含在元素的height和width内 */</p><ul><li>{<br>  margin: 0;<br>  padding: 0;<br>  box-sizing: border-box;<br>}<br>/* flex布局，让内容垂直和水平居中 <em>/<br>body {<br> display: flex;<br> justify-content: center;<br> align-items: center;<br> min-height: 100vh;<br> background: #000;<br>}<br>/</em> flex布局，让内容垂直和水平居中，超过的部分换行显示 <em>/<br>.container {<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>  flex-wrap: wrap;<br>}<br>/</em> 按钮的基本样式 */<br>.container a {<br>  position: relative;<br>  padding: 15px 30px;<br>  margin: 50px;<br>  border: 2px solid #0f0;<br>  font-size: 18px;<br>  font-weight: 600;<br>  text-decoration: none;<br>  letter-spacing: 5px;<br>  color: #fff;<br>  filter: hue-rotate(calc(var(–x) * 60deg));<br>  transition: 0.5s;<br>}<br>/* 鼠标经过时改变按钮样式 */<br>.container a:hover {<br>  transition-delay: 1.5s;<br>  color: #000;<br>  box-shadow: 0 0 10px #0f0,<pre><code>          0 0 20px #0f0,          0 0 40px #0f0,          0 0 80px #0f0,          0 0 160px #0f0,          0 0 320px #0f0;</code></pre>}<br>a span {<br>  position: relative;<br>  z-index: 10;<br>}<br>/* 通过伪元素::before实现按钮左边的线 */<br>.container a::before {<br>  content: “”;<br>  position: absolute;<br>  left: -20px;<br>  top: 50%;<br>  transform: translateY(-50%);<br>  background: #0f0;<br>  width: 20px;<br>  height: 2px;<br>  box-shadow: 5px -8px 0 #0f0,<pre><code>          5px 8px 0 #0f0;</code></pre>  transition: width 0.5s, height 0.5s, left 0.5s,<pre><code>           box-shadow 0.5s;</code></pre>  transition-delay: 0s, 1s, 0s, 0.5s;<br>}<br>/* 鼠标经过时改变线条的样式 */<br>.container a:hover::before {<br>  width: 60%;<br>  height: 100%;<br>  left: -2px;<br>  box-shadow: 0 0 0 #0f0,<pre><code>          0 0 0 #0f0;</code></pre>}<br>/* 通过伪元素::after实现按钮右边的线 */<br>.container a::after {<br>  content: “”;<br>  position: absolute;<br>  right: -20px;<br>  top: 50%;<br>  transform: translateY(-50%);<br>  background: #0f0;<br>  width: 20px;<br>  height: 2px;<br>  box-shadow: -5px -8px 0 #0f0,<pre><code>          -5px 8px 0 #0f0;</code></pre>  transition: width 0.5s, height 0.5s, right 0.5s,<pre><code>           box-shadow 0.5s;</code></pre>  transition-delay: 0s, 1s, 0s, 0.5s;<br>}<br>/* 鼠标经过时改变线条的样式 */<br>.container a:hover::after {<br>  width: 60%;<br>  height: 100%;<br>  right: -2px;<br>  box-shadow: 0 0 0 #0f0,<pre><code>          0 0 0 #0f0;</code></pre>}<br>今天的学习就到这里了，由于本人能力和知识有限，如果有写的不对的地方，还请各位大佬批评指正。有什么不明白的地方欢迎给我留言</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java知识体系总结</title>
    <link href="/2021/01/10/java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/10/java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>一、Java基础知识<br>1、基础知识<br>分类    内容    链接<br>Java基础<br>【Java知识点详解 1】缓存</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104557984">https://blog.csdn.net/guorui_java/article/details/104557984</a><br>Java基础<br>【Java知识点详解 2】动态代理</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108630273">https://blog.csdn.net/guorui_java/article/details/108630273</a><br>Java基础<br>【Java知识点详解 3】序列化与反序列化</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106996834">https://blog.csdn.net/guorui_java/article/details/106996834</a><br>Java基础<br>【Java知识点详解 4】泛型</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106808115">https://blog.csdn.net/guorui_java/article/details/106808115</a><br>Java基础<br>【Java知识点详解 5】枚举</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106789054">https://blog.csdn.net/guorui_java/article/details/106789054</a><br>Java基础<br>【Java知识点详解 6】注解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106658179">https://blog.csdn.net/guorui_java/article/details/106658179</a><br>Java基础<br>【Java知识点详解 7】线程池</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247853">https://blog.csdn.net/guorui_java/article/details/104247853</a><br>Java基础<br>【Java知识点详解 8】ThreadLocal</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106643383">https://blog.csdn.net/guorui_java/article/details/106643383</a><br>Java基础<br>【Java知识点详解 9】守护线程</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247772">https://blog.csdn.net/guorui_java/article/details/104247772</a><br>Java基础<br>【Java知识点详解 10】装箱和拆箱</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247762">https://blog.csdn.net/guorui_java/article/details/104247762</a><br>Java基础<br>【Java知识点详解 11】反射</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108351185">https://blog.csdn.net/guorui_java/article/details/108351185</a><br>Java8 新特性<br>【Java8 新特性 1】Lambda表达式总结（全栈最强，绝对豪横）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106996651">https://blog.csdn.net/guorui_java/article/details/106996651</a><br>Java8 新特性<br>【Java8 新特性 2】函数式接口 + Lamda表达式推导过程</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107085921">https://blog.csdn.net/guorui_java/article/details/107085921</a><br>Java8 新特性<br>【Java8 新特性 3】Supplier简介</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108009650">https://blog.csdn.net/guorui_java/article/details/108009650</a><br>Java8 新特性<br>【Java8 新特性 4】Optional</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109747645">https://blog.csdn.net/guorui_java/article/details/109747645</a><br>Java8 新特性    【Java8 新特性 5】Java8中最重磅的升级Stream    <a href="https://blog.csdn.net/guorui_java/article/details/112336449">https://blog.csdn.net/guorui_java/article/details/112336449</a><br>Java基础    JDK 和 JRE 、final 与 static 、堆和栈    <a href="https://blog.csdn.net/guorui_java/article/details/104247758">https://blog.csdn.net/guorui_java/article/details/104247758</a><br>Java基础<br>String拓展：intern()方法</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109787051">https://blog.csdn.net/guorui_java/article/details/109787051</a><br>Java基础<br>Java之StringUtils的常用方法</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109758957">https://blog.csdn.net/guorui_java/article/details/109758957</a><br>Java基础<br>深入理解Java String类</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109758824">https://blog.csdn.net/guorui_java/article/details/109758824</a><br>Java基础<br>Java内联函数</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109388173">https://blog.csdn.net/guorui_java/article/details/109388173</a><br>TCP/IP<br>BIO、NIO、AIO 介绍和适用场景分析（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107081776">https://blog.csdn.net/guorui_java/article/details/107081776</a><br>反射<br>Java 反射 getClass()</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112251144">https://blog.csdn.net/guorui_java/article/details/112251144</a><br>反射<br>Java反射之Method的invoke方法实现</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109632137">https://blog.csdn.net/guorui_java/article/details/109632137</a><br>重构<br>为什么阿里巴巴不建议在for循环中使用”+”进行字符串拼接</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109759292">https://blog.csdn.net/guorui_java/article/details/109759292</a><br>重构    【Java程序员必知必会的90个细节】1、创建和销毁对象    <a href="https://blog.csdn.net/guorui_java/article/details/107982208">https://blog.csdn.net/guorui_java/article/details/107982208</a><br>IO流<br>FileInputStream 类与 FileReader 类的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109604482">https://blog.csdn.net/guorui_java/article/details/109604482</a><br>2、集合<br>内容    链接<br>Java集合基础知识总结（绝对经典）    <a href="https://blog.csdn.net/guorui_java/article/details/106716234">https://blog.csdn.net/guorui_java/article/details/106716234</a><br>List＜T＞和List＜?＞的区别    <a href="https://blog.csdn.net/guorui_java/article/details/111363761">https://blog.csdn.net/guorui_java/article/details/111363761</a><br>List遍历删除元素remove()    <a href="https://blog.csdn.net/guorui_java/article/details/110098348">https://blog.csdn.net/guorui_java/article/details/110098348</a><br>HashMap转JavaBean</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108875459">https://blog.csdn.net/guorui_java/article/details/108875459</a><br>HashMap + 软引用进行缓存    <a href="https://blog.csdn.net/guorui_java/article/details/112389454">https://blog.csdn.net/guorui_java/article/details/112389454</a><br>Java队列Queue</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104109604">https://blog.csdn.net/guorui_java/article/details/104109604</a><br>3、多线程<br>内容    链接<br>Java多线程基础知识总结（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107599455">https://blog.csdn.net/guorui_java/article/details/107599455</a><br>Java常见的线程池</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107632310">https://blog.csdn.net/guorui_java/article/details/107632310</a><br>死锁、活锁、饿死和阻塞的个人理解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247787">https://blog.csdn.net/guorui_java/article/details/104247787</a><br>Java多线程之Executor框架</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018444">https://blog.csdn.net/guorui_java/article/details/104018444</a><br>4、怪味杂谈<br>内容    链接<br>利用百度语音识别技术实现文字转语音的应用（Java版附源码）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106825378">https://blog.csdn.net/guorui_java/article/details/106825378</a><br>Java性能优化的35个细节（珍藏版）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104107390">https://blog.csdn.net/guorui_java/article/details/104107390</a><br>tableExport导出 excel报表</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104027002">https://blog.csdn.net/guorui_java/article/details/104027002</a><br>二、Spring + SpringMVC + MyBatis<br>分类    内容    链接<br>Java框架<br>【全栈最全Java框架总结】SSH、SSM、Springboot</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018528">https://blog.csdn.net/guorui_java/article/details/104018528</a><br>JavaWeb<br>过滤器和拦截器的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111740613">https://blog.csdn.net/guorui_java/article/details/111740613</a><br>JavaWeb<br>GET和POST的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112294323">https://blog.csdn.net/guorui_java/article/details/112294323</a><br>Spring<br>使用JSR-303进行校验</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111828359">https://blog.csdn.net/guorui_java/article/details/111828359</a><br>Spring<br>Spring AOP基础知识总结</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107406542">https://blog.csdn.net/guorui_java/article/details/107406542</a><br>Spring<br>Spring常用注解（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107347754">https://blog.csdn.net/guorui_java/article/details/107347754</a><br>Spring<br>浅谈Spring事件机制</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106022134">https://blog.csdn.net/guorui_java/article/details/106022134</a><br>Spring    Spring JdbcTemplate简介    <a href="https://blog.csdn.net/guorui_java/article/details/104177211">https://blog.csdn.net/guorui_java/article/details/104177211</a><br>SpringMVC<br>SpringMVC中put和post如何选择</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109715075">https://blog.csdn.net/guorui_java/article/details/109715075</a><br>SpringMVC<br>@RequestParam、@ModelAttribute、@RequestBody的区别</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112295474">https://blog.csdn.net/guorui_java/article/details/112295474</a><br>SpringMVC<br>HttpServletResponse response实现文件上传、下载</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111145510">https://blog.csdn.net/guorui_java/article/details/111145510</a><br>SpringMVC<br>ControllerAdvice的常用场景</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106883939">https://blog.csdn.net/guorui_java/article/details/106883939</a><br>MyBatis<br>MyBatis xml配置文件详解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109106704">https://blog.csdn.net/guorui_java/article/details/109106704</a><br>MyBatis<br>MyBatis常用标签和注解（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108875682">https://blog.csdn.net/guorui_java/article/details/108875682</a><br>MyBatis<br>【MyBatis 基础知识总结 1】SQL注入</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107220076">https://blog.csdn.net/guorui_java/article/details/107220076</a><br>MyBatis<br>【MyBatis 基础知识总结 2】MyBatis-Plus</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107219805">https://blog.csdn.net/guorui_java/article/details/107219805</a><br>SSM<br>Spring+SpringMVC+MyBatis整合</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105682019">https://blog.csdn.net/guorui_java/article/details/105682019</a><br>Hibernate<br>Hibernate基础知识总结（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106532795">https://blog.csdn.net/guorui_java/article/details/106532795</a><br>三、Spring Boot<br>内容    链接<br>超详细的springBoot学习笔记</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104137262">https://blog.csdn.net/guorui_java/article/details/104137262</a><br>【Spring Boot 1】入门篇</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104152433">https://blog.csdn.net/guorui_java/article/details/104152433</a><br>【Spring Boot 2】web应用开发，实现CRUD</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104181423">https://blog.csdn.net/guorui_java/article/details/104181423</a><br>【Spring Boot 3】Thymeleaf 使用详解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104231260">https://blog.csdn.net/guorui_java/article/details/104231260</a><br>【Spring Boot 4】如何优雅的使用 Mybatis</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104229009">https://blog.csdn.net/guorui_java/article/details/104229009</a><br>【Spring Boot 5】Spring Boot Jpa 的使用</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104241662">https://blog.csdn.net/guorui_java/article/details/104241662</a><br>【Spring Boot 6】自定义starter    <a href="https://blog.csdn.net/guorui_java/article/details/106867215">https://blog.csdn.net/guorui_java/article/details/106867215</a><br>【Spring Boot 7】RabbitMQ基础知识总结</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104261716">https://blog.csdn.net/guorui_java/article/details/104261716</a><br>【Spring Boot 8】Okhttp实现GitHub第三方登录</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104328355">https://blog.csdn.net/guorui_java/article/details/104328355</a><br>【Spring Boot 9】结合mybatis实现增删改查</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104352990">https://blog.csdn.net/guorui_java/article/details/104352990</a><br>【Spring Boot 10】Spring Boot + mybatis + Thymeleaf 分页示例（纯底层代码，不是pagehelper）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104408412">https://blog.csdn.net/guorui_java/article/details/104408412</a><br>【Spring Boot 11】如何测试打包部署</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104476691">https://blog.csdn.net/guorui_java/article/details/104476691</a><br>【Spring Boot 12】看完这篇，Redis你就入门了</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104277843">https://blog.csdn.net/guorui_java/article/details/104277843</a><br>【Spring Boot 13】实现热部署</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104496412">https://blog.csdn.net/guorui_java/article/details/104496412</a><br>【Spring Boot 14】原理篇</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104652332">https://blog.csdn.net/guorui_java/article/details/104652332</a><br>【Spring Boot 15】启动类原理解析</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104793766">https://blog.csdn.net/guorui_java/article/details/104793766</a><br>【Spring Boot 16】常用注解介绍及使用</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105070627">https://blog.csdn.net/guorui_java/article/details/105070627</a><br>【Spring Boot 17】浅谈分布式锁</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104277793">https://blog.csdn.net/guorui_java/article/details/104277793</a><br>【Spring Boot 18】Spring Boot + Vue 实现CRUD</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107010007">https://blog.csdn.net/guorui_java/article/details/107010007</a><br>【Spring Boot 19】Spring Boot整合阿里云OSS实现云存储</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107010852">https://blog.csdn.net/guorui_java/article/details/107010852</a><br>【Spring Boot 20】Spring Boot + Vue 整合阿里云视频点播</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107274455">https://blog.csdn.net/guorui_java/article/details/107274455</a><br>【Spring Boot 21】Spring Boot 项目如何部署</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108275920">https://blog.csdn.net/guorui_java/article/details/108275920</a><br>【Spring Boot 22】QueryMapper初探</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108596631">https://blog.csdn.net/guorui_java/article/details/108596631</a><br>【Spring Boot 23】MyBatis事务管理</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109088823">https://blog.csdn.net/guorui_java/article/details/109088823</a><br>【Spring Boot 24】MyBatis逆向工程（Example + Criteria简介）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/110311091">https://blog.csdn.net/guorui_java/article/details/110311091</a><br>【Spring Boot 25】JdbcTemplate配置类 + 事务控制 + API简介</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111936978">https://blog.csdn.net/guorui_java/article/details/111936978</a><br>【Spring Boot 26】分别在SpringBoot和Vue中解决跨域问题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109874891">https://blog.csdn.net/guorui_java/article/details/109874891</a><br>SpringBoot启动类中注入service</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108833612">https://blog.csdn.net/guorui_java/article/details/108833612</a><br>Spring Boot 谷粒学院、谷粒商城项目问题汇总</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106794847">https://blog.csdn.net/guorui_java/article/details/106794847</a><br>Spring Boot常用注解（绝对经典）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107379648">https://blog.csdn.net/guorui_java/article/details/107379648</a><br>四、SpringCloud<br>内容    链接<br>SpringCloud学习总纲</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112055672">https://blog.csdn.net/guorui_java/article/details/112055672</a><br>【Spring Cloud 1】分布式架构入门</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112056367">https://blog.csdn.net/guorui_java/article/details/112056367</a><br>【Spring Cloud 2】软件架构设计</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112093407">https://blog.csdn.net/guorui_java/article/details/112093407</a><br>【Spring Cloud 3】分布式架构下的高可用设计与可伸缩设计</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112102190">https://blog.csdn.net/guorui_java/article/details/112102190</a><br>【Spring Cloud 4】构建高性能的大型分布式网站</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112116728">https://blog.csdn.net/guorui_java/article/details/112116728</a><br>【Spring Cloud 5】SOA架构和微服务架构之间的关系</p><p><a href="https://blog.csdn.net/guorui_java/article/details/112134533">https://blog.csdn.net/guorui_java/article/details/112134533</a></p><p>【Spring Cloud 6】注册中心Eureka</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106524578">https://blog.csdn.net/guorui_java/article/details/106524578</a><br>【Spring Cloud 7】限流、降级和熔断Hystrix</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107179147">https://blog.csdn.net/guorui_java/article/details/107179147</a><br>【Spring Cloud 8】熔断与限流Sentinel</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104551146">https://blog.csdn.net/guorui_java/article/details/104551146</a><br>【Spring Cloud 9】看完这篇，Docker你就入门了</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104213743">https://blog.csdn.net/guorui_java/article/details/104213743</a><br>微服务与SOA架构</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104496409">https://blog.csdn.net/guorui_java/article/details/104496409</a><br>如果你还不懂微服务，你就危险了！</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107634737">https://blog.csdn.net/guorui_java/article/details/107634737</a><br>RPC服务和HTTP服务对比</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107513214">https://blog.csdn.net/guorui_java/article/details/107513214</a><br>五、读书笔记<br>1、重构 改善既有代码的设计<br>内容    链接<br>重构，改善既有代码的设计</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018540">https://blog.csdn.net/guorui_java/article/details/104018540</a><br>《重构 改善既有代码的设计 1》重构原则</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111305499">https://blog.csdn.net/guorui_java/article/details/111305499</a><br>《重构 改善既有代码的设计 2》重新组织函数、数据</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111434891">https://blog.csdn.net/guorui_java/article/details/111434891</a><br>《重构 改善既有代码的设计 3》代码的可理解性应该是我们虔诚追求的目标</p><p><a href="https://blog.csdn.net/guorui_java/article/details/111742701">https://blog.csdn.net/guorui_java/article/details/111742701</a><br>2、【编写高质量代码：改善Java程序的151个建议】<br>内容    链接<br>第1章：Java开发中通用的方法和准则___建议1~13</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247675">https://blog.csdn.net/guorui_java/article/details/104247675</a><br>第1章：Java开发中通用的方法和准则___建议14~20</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247792">https://blog.csdn.net/guorui_java/article/details/104247792</a><br>第2章:基本类型___建议21~30</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247793">https://blog.csdn.net/guorui_java/article/details/104247793</a><br>第3章:类、对象及方法___建议31~51</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247797">https://blog.csdn.net/guorui_java/article/details/104247797</a><br>第4章:字符串___建议52~59</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247800">https://blog.csdn.net/guorui_java/article/details/104247800</a><br>第5章:数组和集合___建议60~66</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247804">https://blog.csdn.net/guorui_java/article/details/104247804</a></p><p>第5章:数组和集合___建议67~82</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247810">https://blog.csdn.net/guorui_java/article/details/104247810</a><br>第6章:枚举和注解___建议83~92</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247824">https://blog.csdn.net/guorui_java/article/details/104247824</a><br>第7章:泛型和反射___建议93~100</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247834">https://blog.csdn.net/guorui_java/article/details/104247834</a><br>第7章:泛型和反射___建议101~109</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247868">https://blog.csdn.net/guorui_java/article/details/104247868</a><br>第8章:异常___建议110~117</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247839">https://blog.csdn.net/guorui_java/article/details/104247839</a><br>第9章:多线程和并发___建议118~124</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247845">https://blog.csdn.net/guorui_java/article/details/104247845</a><br>第9章:多线程和并发___建议125~131</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247855">https://blog.csdn.net/guorui_java/article/details/104247855</a><br>第10章:性能和效率，第11章:开源世界，第12章:思想为源___建议132~151</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247858">https://blog.csdn.net/guorui_java/article/details/104247858</a><br>3、深入理解Java虚拟机<br>内容    链接<br>《深入理解Java虚拟机 1》Java内存区域与内存分配策略</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104018475">https://blog.csdn.net/guorui_java/article/details/104018475</a><br>《深入理解Java虚拟机 2》性能监控与调优</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104026992">https://blog.csdn.net/guorui_java/article/details/104026992</a><br>《深入理解Java虚拟机 3》类加载机制与字节码执行引擎</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104026995">https://blog.csdn.net/guorui_java/article/details/104026995</a><br>类加载与执行子系统的案例与实战</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104038430">https://blog.csdn.net/guorui_java/article/details/104038430</a><br>【JVM】HotSpot VM GC 的种类</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104036507">https://blog.csdn.net/guorui_java/article/details/104036507</a><br>【JVM】内存调优</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104036501">https://blog.csdn.net/guorui_java/article/details/104036501</a><br>【JVM】Eclipse运行速度调优</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104036482">https://blog.csdn.net/guorui_java/article/details/104036482</a><br>JVM堆内存详解</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109437377">https://blog.csdn.net/guorui_java/article/details/109437377</a><br>说一下 jvm 有哪些垃圾回收器？</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108405844">https://blog.csdn.net/guorui_java/article/details/108405844</a><br>六、高频面试题<br>内容    链接<br>Java面试题总结（附答案）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107803283">https://blog.csdn.net/guorui_java/article/details/107803283</a><br>Java基础知识面试题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108153368">https://blog.csdn.net/guorui_java/article/details/108153368</a><br>如果当时这12道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-7-14）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107343135">https://blog.csdn.net/guorui_java/article/details/107343135</a><br>如果当时这15道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-7-20）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107477924">https://blog.csdn.net/guorui_java/article/details/107477924</a><br>如果当时这15道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-7-23）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/107547386">https://blog.csdn.net/guorui_java/article/details/107547386</a><br>如果当时这20道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-8-27）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108197232">https://blog.csdn.net/guorui_java/article/details/108197232</a><br>如果当时这16道题能答好，现在应该已经被录取了（记一次面试的亲身经历 2020-9-9）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108503215">https://blog.csdn.net/guorui_java/article/details/108503215</a><br>Java面试题总结（乱序版，2020-08-17）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108049191">https://blog.csdn.net/guorui_java/article/details/108049191</a><br>Java面试题总结（乱序版，2020-08-18）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108076036">https://blog.csdn.net/guorui_java/article/details/108076036</a><br>Java面试题总结（乱序版，2020-08-20）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108121583">https://blog.csdn.net/guorui_java/article/details/108121583</a><br>Java面试题总结（乱序版，2020-08-31）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108151596">https://blog.csdn.net/guorui_java/article/details/108151596</a><br>Java面试题总结（乱序版，2020-09-03）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108381144">https://blog.csdn.net/guorui_java/article/details/108381144</a><br>Java面试题总结（乱序版，2020-09-19）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108689349">https://blog.csdn.net/guorui_java/article/details/108689349</a><br>Java面试题总结（乱序版，2020-09-29）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/108876169">https://blog.csdn.net/guorui_java/article/details/108876169</a><br>Java面试题总结（基础面试题完结版，2020-10-13）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/109043769">https://blog.csdn.net/guorui_java/article/details/109043769</a><br>Spring面试题整理</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105987495">https://blog.csdn.net/guorui_java/article/details/105987495</a><br>七、数据结构与算法<br>内容    链接<br>常见数据结构与算法整理总结</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106217472">https://blog.csdn.net/guorui_java/article/details/106217472</a><br>【数据结构与算法 1】稀疏数组</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106050189">https://blog.csdn.net/guorui_java/article/details/106050189</a><br>【数据结构与算法 2】循环队列</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106092804">https://blog.csdn.net/guorui_java/article/details/106092804</a><br>【数据结构与算法 3】单链表</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106096006">https://blog.csdn.net/guorui_java/article/details/106096006</a><br>【数据结构与算法 4】单链表面试题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106101884">https://blog.csdn.net/guorui_java/article/details/106101884</a><br>【数据结构与算法 5】环形链表解决约瑟夫问题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106155636">https://blog.csdn.net/guorui_java/article/details/106155636</a><br>【数据结构与算法 6】栈实现综合计算器</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106193563">https://blog.csdn.net/guorui_java/article/details/106193563</a><br>【数据结构与算法 7】中缀表达式转为后缀表达式，实现逆波兰计算器</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106215643">https://blog.csdn.net/guorui_java/article/details/106215643</a><br>【数据结构与算法 8】递归之迷宫问题</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106230186">https://blog.csdn.net/guorui_java/article/details/106230186</a><br>【数据结构与算法 9】谁发明的八皇后，本宫赐你一丈红</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106235887">https://blog.csdn.net/guorui_java/article/details/106235887</a><br>【数据结构与算法 10】算法的时间复杂度和空间复杂度</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105925046">https://blog.csdn.net/guorui_java/article/details/105925046</a><br>【数据结构与算法 11】常见的7种排序算法</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106270186">https://blog.csdn.net/guorui_java/article/details/106270186</a><br>【数据结构与算法 12】二分查找、插值查找、斐波那契查找</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106341658">https://blog.csdn.net/guorui_java/article/details/106341658</a><br>【数据结构与算法 13】二叉树</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106398737">https://blog.csdn.net/guorui_java/article/details/106398737</a><br>八、设计模式<br>内容    链接<br>Java设计模式：23种设计模式全面解析（超级详细）</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104026988">https://blog.csdn.net/guorui_java/article/details/104026988</a><br>【源码分析设计模式 1】JDK中的单例模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106585965">https://blog.csdn.net/guorui_java/article/details/106585965</a><br>【源码分析设计模式 2】JDK中的抽象工厂模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106535411">https://blog.csdn.net/guorui_java/article/details/106535411</a><br>【源码分析设计模式 3】JDK中的工厂模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/105087806">https://blog.csdn.net/guorui_java/article/details/105087806</a><br>【源码分析设计模式 4】JDK中的原型模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106544941">https://blog.csdn.net/guorui_java/article/details/106544941</a><br>【源码分析设计模式 5】Java I/O系统中的装饰器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106613220">https://blog.csdn.net/guorui_java/article/details/106613220</a><br>【源码分析设计模式 6】Mybatis中的组合模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106617887">https://blog.csdn.net/guorui_java/article/details/106617887</a><br>【源码分析设计模式 7】Integer中的享元模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106640489">https://blog.csdn.net/guorui_java/article/details/106640489</a><br>【源码分析设计模式 8】mybatis中的代理模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106665200">https://blog.csdn.net/guorui_java/article/details/106665200</a><br>【源码分析设计模式 9】SpringIOC中的模板方法模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106677554">https://blog.csdn.net/guorui_java/article/details/106677554</a><br>【源码分析设计模式 10】SpringMVC中的适配器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106584559">https://blog.csdn.net/guorui_java/article/details/106584559</a><br>【源码分析设计模式 11】SpringMVC中的策略模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104039882">https://blog.csdn.net/guorui_java/article/details/104039882</a><br>【源码分析设计模式 12】JDBC中的桥接模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106688252">https://blog.csdn.net/guorui_java/article/details/106688252</a><br>【源码分析设计模式 13】命令模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106718457">https://blog.csdn.net/guorui_java/article/details/106718457</a><br>浅谈Visitor访问者模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247935">https://blog.csdn.net/guorui_java/article/details/104247935</a><br>浅谈Facade外观模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247938">https://blog.csdn.net/guorui_java/article/details/104247938</a><br>浅谈Observer观察者模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247965">https://blog.csdn.net/guorui_java/article/details/104247965</a><br>浅谈Mediator仲裁者模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247966">https://blog.csdn.net/guorui_java/article/details/104247966</a><br>浅谈Interpreter解释器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247972">https://blog.csdn.net/guorui_java/article/details/104247972</a><br>浅谈Memento备忘录模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247969">https://blog.csdn.net/guorui_java/article/details/104247969</a><br>浅谈State状态模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247975">https://blog.csdn.net/guorui_java/article/details/104247975</a><br>浅谈（chain of responsibility）责任链模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247978">https://blog.csdn.net/guorui_java/article/details/104247978</a><br>浅谈Iterator迭代器模式</p><p><a href="https://blog.csdn.net/guorui_java/article/details/104247911">https://blog.csdn.net/guorui_java/article/details/104247911</a><br>单一职责、接口隔离、依赖倒转、里氏替换、开闭原则、迪米特、合成复用</p><p><a href="https://blog.csdn.net/guorui_java/article/details/106469226">https://blog.csdn.net/guorui_java/article/details/106469226</a></p><p>以上来自csdn</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬虫自动化</title>
    <link href="/2021/01/10/python%E7%88%AC%E8%99%AB%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2021/01/10/python%E7%88%AC%E8%99%AB%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>导入需要用到的库</p><p>import requests<br>import pandas as pd<br>from random import choice<br>from lxml import etree<br>import openpyxl<br>import logging<br>基本配置参数</p><h1 id="日志输出的基本配置"><a href="#日志输出的基本配置" class="headerlink" title="日志输出的基本配置"></a>日志输出的基本配置</h1><p>logging.basicConfig(level=logging.INFO, format=’%(asctime)s - %(levelname)s: %(message)s’)<br>wb = openpyxl.Workbook()    # 创建工作簿对象<br>sheet = wb.active    # 获取活动的工作表<br>sheet.append([‘学校名称’, ‘中文简称’, ‘学校名称（英文）’, ‘描述’, ‘百度百科链接’])   # 添加第一行列名</p><h1 id="产生随机请求头用于切换"><a href="#产生随机请求头用于切换" class="headerlink" title="产生随机请求头用于切换"></a>产生随机请求头用于切换</h1><p>user_agent = [<br>    “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1”,<br>    “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6”,<br>……<br>    “Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24”<br>    ]<br>读取数据、爬取网页</p><h1 id="读取已有的学校名称数据"><a href="#读取已有的学校名称数据" class="headerlink" title="读取已有的学校名称数据"></a>读取已有的学校名称数据</h1><p>df = pd.read_excel(‘学校名称.xlsx’)[‘学校名称’]<br>items = df.values</p><h1 id="遍历-获取每所学校名称"><a href="#遍历-获取每所学校名称" class="headerlink" title="遍历  获取每所学校名称"></a>遍历  获取每所学校名称</h1><p>for item in items:<br>    try:<br>        # 随机生成请求头<br>        headers = {<br>            ‘User-Agent’:choice(user_agent)<br>        }<br>        # 构造url<br>        url = f’<a href="https://baike.baidu.com/item/%7Bitem%7D&#39;">https://baike.baidu.com/item/{item}&#39;</a><br>        # 发送请求   获取响应<br>        rep = requests.get(url, headers=headers)<br>        # Xpath解析提取数据<br>        html = etree.HTML(rep.text)<br>        # 描述<br>        description = ‘’.join(html.xpath(‘/html/head/meta[4]/@content’))<br>        # 外文名<br>        en_name = ‘，’.join(html.xpath(‘//dl[@class=”basicInfo-block basicInfo-left”]/dd[2]/text()’)).strip()<br>        # 中文简称  有的话  是在dd[3]标签下<br>        simple_name = ‘’.join(html.xpath(‘//dl[@class=”basicInfo-block basicInfo-left”]/dd[3]/text()’)).strip()<br>        sheet.append([item, simple_name, en_name, url])<br>        logging.info([item, simple_name, en_name, description, url])</p><pre><code>except Exception as e:    logging.info(e.args)    pass</code></pre><h1 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h1><p>wb.save(‘成果.xlsx’)<br>程序运行一会儿，数据就全部爬取下来啦。</p><p>因为开多线程，爬取的顺序会打乱，按照学姐给的学校名称的表格里的顺序排列好，就可以交付了。</p><h1 id="程序中记录一下它原本的序号-一起写入Excel"><a href="#程序中记录一下它原本的序号-一起写入Excel" class="headerlink" title="程序中记录一下它原本的序号   一起写入Excel"></a>程序中记录一下它原本的序号   一起写入Excel</h1><p> sort_num = items.index(item)<br>import pandas as pd</p><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>df = pd.read_excel(‘成果.xlsx’)</p><h1 id="按原始序号排序"><a href="#按原始序号排序" class="headerlink" title="按原始序号排序"></a>按原始序号排序</h1><p>df1 = df.sort_values(by=’原始序号’)</p><h1 id="查看排序后的数据"><a href="#查看排序后的数据" class="headerlink" title="查看排序后的数据"></a>查看排序后的数据</h1><p>df1.head(8)</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我对自己的认识</title>
    <link href="/2021/01/03/%E6%88%91%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <url>/2021/01/03/%E6%88%91%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>总觉得自己是一个无趣且内向的人。好像从小到大身边的所有人都在告诉我，你要学会变得活泼开朗，多说话，脚下的路才会特别好走。</p><p>小时候和家人出门，路上碰见熟人，我不知道该怎么开口打招呼，也分不清该叫什么敬称，逢年过节时也不知道怎么开口说些祝福的话。<br>于是被家人视为不懂事的孩子，总是被说，看别人家的孩子嘴那么甜，多讨人欢心。后来慢慢长大，到了中学，班级里的各种聚餐活动也都通通避之。<br>中学是开始学习编程，每天早上都看一两眼书，有异性坐到了自己身侧，于是一直头死死的盯着窗外，根本不敢看对方一眼。<br>这种内向浸透到我身体里的每一个角落，只喜欢下班后自己一个人待着，无趣的重复着每天的。。<br>生活。也曾尝试着让自己去适应去改变，每次很不情愿地交流后，都会觉得难受无比，也很疲惫，总是在进退两难中纠结，本来就很不开心，慢慢变得更不开心了。<br>你快乐吗，长大后与这个世界的诸多交手。或许大部分人的答案都是否定的吧。<br>我们原本想要更加痛快地生活，可那股杀<br>伐决断的勇气去哪了，被生活消磨殆尽了吗<br>很遗憾，我们终究没有为更自由的未来，冲锋陷阵过。<br>就像我们期待遇见鲸鱼，却从没有出海，甚至没有涉足野生的湖泊<br>周围人的人都在笑，他们始终不相信语言能杀人，用冰冷的语言戳别人的痛处来取乐<br>这些都像一些玻璃渣子，支离破碎，句句伤人<br>也不是每一个家庭都是避风港，我羡慕在温室里的孩子，他们骨子里发出来的自信，是我这辈子学不来的<br>我的父亲没有散文集，他的日记本里，只有给别人干活的日期<br>我的母亲脸上手上已经有了许多皱印<br>从前不理解父亲，为什么不能赚大钱，为什么不能让一家人过上更好的日子，长大后才明白为了我已经拼尽全力了<br>同级的同学不断地秀着爸妈的转账纪律和高端生活，我承认我羡慕了，但我忘不了我之前的时候恨过我父亲没有钱<br>我认为我这个15岁出头的人，应当谦卑一些，<br>每当想要评价什么人的时候切记这个世界上的人并非都具备你禀有的条件。</p><p>以上纯属我一个15岁的孩子个人主观认为，有问题也很正常，毕竟我只有这么大，对于社会经验和家庭问题所能理解的非常有限</p>]]></content>
    
    
    
    <tags>
      
      <tag>情感诉讼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于父母</title>
    <link href="/2021/01/03/%E5%85%B3%E4%BA%8E%E7%88%B6%E6%AF%8D/"/>
    <url>/2021/01/03/%E5%85%B3%E4%BA%8E%E7%88%B6%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>匿名用户</p><p>434 人赞同了该回答</p><p>好讨厌这样的自己，我也是有时候对着父母莫名其妙的控制不住情绪，知道父母很爱自己，但是聊着天就会加重语气，甚至因为很小的事情争吵，其实我觉得基本上每次都是我的错的，所以事后心里超后悔。</p><p>有次我生日，爸爸打电话跟我说：生日快乐，等下发个红包给你贺贺。</p><p>我一口就说不用了，不知道是出于什么心态，可能是想着能不向父母要钱就不要伸手拿钱（但是天知道我现在的一切都是父母给我的）</p><p>我爸爸一听，声音低下去了，他说：要的，你在外面读书过生日发个红包也是要有的。</p><p>然后我就开始控制不住自己的情绪，很急躁的回答：都说不用就不用了啦，没空了，我先挂了。</p><p>其实我觉得这个时候的我是个人渣，电话打通还不够30秒我就挂电话了，而且电话那头的人还是我爸爸在跟我说生日快乐。我一挂完电话我就开始懊恼，我为什么这么过分，明明是家人的一片心意却被我这样糟蹋，越想越后悔，我就赶紧回拨给爸爸，但是我觉得我是一个表面很冷但是内心有点感性的人（就像我对着父母说不出我爱你这几个字），所以我假装刚忙完再打电话回去给他的，然而电话正在通话中，我就想我肯定是伤到老爸的心了，所以我爸可能打电话给我大姐倾诉了（我爸爸对于我们姐妹对他的态度那些觉得有什么委屈或者烦恼的都会跟我大姐倾诉，比如经常打电话给手机调静音的我，由于经常没人接，所以很少打电话给我这些），</p><p>然后我再次回拨老爸电话时，通了，这个时候手机收到了几条信息，但是我没来得及看，就继续跟我爸说：不要发红包给我了，今天有同学已经发过红包给我了，你先把钱留着，我没钱用了再找你，</p><p>我爸坚持要发，说：这是心意，生日总要有生日的样子嘛，接受心意是种礼貌，</p><p>然后我就不想推脱了，说好吧，我爸就挂了电话急忙要发红包给我，</p><p>这时候我一打开手机看到了几个二姐发来的红包，我瞬间泪崩了，这时候我觉得我是个恶魔，因为我二姐是不记得我的生日的，每年都是我爸爸提醒她们才记得的，所以也就是说在我跟我爸通了第一通不够30秒的电话被我挂了电话的情况下，我爸爸接着打电话告诉我二姐我今天生日，不管我的语气多恶劣，爸爸好像完全忘记了我刚刚所做的那些过分的事情一样，还是继续付出着他对我的好，而我却这样子对待父母对女儿的心意，糟蹋了这些，我真的瞬间觉得用恶魔来形容我都是糟蹋了恶魔这个词了，</p><p>接着我爸爸跟我妈妈都发了一个红包给我，因为他们不会打字，但是还是一个字一个字地写了一大段祝福我的话发给我，好像希望最好的都可以加在我身上一样，那一刻我真的是无比懊悔，懊悔到想死，我是多人渣才能对父母的爱做出如此回应，我不知道我要做多少才能弥补我对父母的爱，但是我觉得我不能这样对待自己的父母，这样的我才是真正的恶魔。</p><p>我想改变，我想控制自己的情绪去对待生活中爱自己的每个人，愿他们开开心心健健康康地陪伴在自己身边。</p><p>知乎首答，忏悔和想改变。</p><p>以上来自知乎，如有侵权请联系站长</p>]]></content>
    
    
    
    <tags>
      
      <tag>情感诉讼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人matter优化</title>
    <link href="/2021/01/03/%E4%B8%AA%E4%BA%BAmatter%E4%BC%98%E5%8C%96/"/>
    <url>/2021/01/03/%E4%B8%AA%E4%BA%BAmatter%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题，点击 这里 可以查看示例效果。点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到 Hexo 的 themes 文件夹中即可。</p><p>切换主题<br>修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery</p><p>_config.yml 文件的其它修改建议:<br>请修改 _config.yml 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io)./">http://xxx.github.io）。</a><br>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。<br>如果是中文用户，则建议修改 language 的值为 zh-CN。<br>新建分类 categories 页<br>categories 页是用来展示所有分类的页面，如果 source 目录下还没有 categories/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “categories”<br>1<br>编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容：</p><hr><p>title: categories<br>date: 2018-09-30 17:25:30<br>type: “categories”<br>layout: “categories”</p><hr><p>1<br>2<br>3<br>4<br>5<br>6<br>新建标签 tags 页<br>tags 页是用来展示所有标签的页面，如果 source 目录下还没有 tags/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “tags”<br>1<br>编辑刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容：</p><hr><p>title: tags<br>date: 2018-09-30 18:23:38<br>type: “tags”<br>layout: “tags”</p><hr><p>1<br>2<br>3<br>4<br>5<br>6<br>新建关于我 about 页<br>about 页是用来展示关于我和我的博客信息的页面，如果 source 目录下还没有 about/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “about”<br>1<br>编辑刚刚新建的页面文件 /source/about/index.md，至少需要以下内容：</p><hr><p>title: about<br>date: 2018-09-30 17:25:30<br>type: “about”<br>layout: “about”</p><hr><p>新建友情连接 friends 页（可选的）<br>friends 页是用来展示友情连接信息的页面，如果 source 目录下还没有 friends/index.md 文件，那么就需要新建一个，命令如下：</p><p>hexo new page “friends”<br>1<br>编辑刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容：</p><hr><p>title: friends<br>date: 2018-12-12 21:25:30<br>type: “friends”<br>layout: “friends”</p><hr><p>同时，在 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示：</p><p>[{<br>    “avatar”: “<a href="https://www.lixl.cn/medias/avatar.jpg&quot;">https://www.lixl.cn/medias/avatar.jpg&quot;</a>,<br>    “name”: “悟尘记”,<br>    “introduction”: “人生就是一场修行，上善若水，厚德载物。”,<br>    “url”: “<a href="https://www.lixl.cn/&quot;">https://www.lixl.cn/&quot;</a>,<br>    “title”: “前去参观”<br>}, {<br>    “avatar”: “<a href="https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2&quot;">https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2&quot;</a>,<br>    “name”: “Fabric”,<br>    “introduction”: “A Blockchain Platform for the Enterprise”,<br>    “url”: “<a href="https://hyperledger-fabric.readthedocs.io/en/master/&quot;">https://hyperledger-fabric.readthedocs.io/en/master/&quot;</a>,<br>    “title”: “前去学习”<br>}, {<br>    “avatar”: “<a href="https://www.bootcdn.cn/assets/img/maoyun.svg&quot;">https://www.bootcdn.cn/assets/img/maoyun.svg&quot;</a>,<br>    “name”: “BootCDN”,<br>    “introduction”: “稳定、快速、免费的前端开源项目 CDN 加速服务。”,<br>    “url”: “<a href="https://www.bootcdn.cn/&quot;">https://www.bootcdn.cn/&quot;</a>,<br>    “title”: “前去加速”<br>}]</p><p>代码高亮<br>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：</p><p>npm i -S hexo-prism-plugin<br>1<br>然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：</p><p>highlight:<br>  enable: false</p><p>prism_plugin:<br>  mode: ‘preprocess’    # realtime/preprocess<br>  theme: ‘tomorrow’<br>  line_number: false    # default false<br>  custom_css:<br>搜索<br>本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：</p><p>npm install hexo-generator-search –save<br>1<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>search:<br>  path: search.xml<br>  field: post<br>1<br>2<br>3<br>修改页脚<br>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。</p><p>修改社交链接<br>在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">    <i class="fa fa-github"></i></a>123其中，社交图标（如：fa-github）可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供参考：<p>Facebook: fa-facebook<br>Twitter: fa-twitter<br>Google-plus: fa-google-plus<br>Linkedin: fa-linkedin<br>Tumblr: fa-tumblr<br>Medium: fa-medium<br>Slack: fa-slack<br>新浪微博: fa-weibo<br>微信: fa-wechat<br>QQ: fa-qq<br>修改打赏的二维码图片<br>在主题文件的 source/medias/reward 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><p>一键部署<br>通过 hexo-deployer-git 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：</p><p>npm install hexo-deployer-git –save<br>1<br>修改 Hexo 根目录下的 _config.yml 文件中的如下内容:</p><h2 id="Docs-https-hexo-io-docs-deployment-html"><a href="#Docs-https-hexo-io-docs-deployment-html" class="headerlink" title="Docs: https://hexo.io/docs/deployment.html"></a>Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a></h2><p>deploy:</p><ul><li>type: git<br>repo: <a href="https://github.com/lxl80/blog.git">https://github.com/lxl80/blog.git</a><br>branch: gh-pages<br>ignore_hidden: false</li><li>type: git<br>repo: <a href="https://gitee.com/lxl80/lxl80.git">https://gitee.com/lxl80/lxl80.git</a><br>branch: master<br>ignore_hidden: false<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>也可以如本站一样，采用 hexo-deployer-cos-enhanced 插件将静态内容部署到腾讯云对象存储服务中，在DNS配置中将境内线路解析到腾讯云CDN地址，实现加速。部署完成后会自动刷新被更新文件的CDN缓存。</li></ul><p>安装：</p><p>npm install hexo-deployer-cos-enhanced –save<br>1<br>_config.yml 配置如下:</p><p>deploy:</p><ul><li>type: git<br>repo: <a href="https://github.com/lxl80/blog.git">https://github.com/lxl80/blog.git</a><br>branch: gh-pages<br>ignore_hidden: false</li><li>type: cos<br>bucket: lxl80-130****<br>region: ap-beijing<br>secretId: AKIDh9**<strong>F8FvL<br>secretKey: Z3IGiur**</strong>QZR3PgjXmlVg<br>cdnConfig:<br>  enable: true<br>  cdnUrl: <a href="https://static.lixl.cn/">https://static.lixl.cn</a><br>  bucket: static-130****<br>  region: ap-beijing<br>  folder: static<br>  secretId: AKIDh9**<strong>F8FvL<br>  secretKey: Z3IGiur**</strong>QZR3PgjXmlVg<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>然后通过 hexo g -d 即可实现一键发布，并更新CDN缓存。</li></ul><p>文章链接转静态短地址（建议安装）<br>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件生成文章时生成中文拼音的永久链接，或者用hexo-abbrlink 生成静态文章链接。以下结合hexo-abbrlink生成类似 /yyyy/mmdd+随机数.html 的文章链接地址。</p><p>安装命令如下：</p><p>npm install hexo-abbrlink –save<br>1<br>在 Hexo 根目录下的 _config.yml 文件中，修改 permalink: ，并在文件末尾新增 abbrlink:配置项：</p><p>permalink: :year/:month:day:abbrlink.html</p><p>abbrlink:<br>  alg: crc16 #算法选项：crc16丨crc32<br>  rep: dec #输出进制：dec为十进制，hex为十六进制<br>1<br>2<br>3<br>4<br>5<br>CND加速（建议启用）<br>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。也可以选择主流云服务商提供的对象存储+CDN来获得更快速及稳定的访问效果，费用低到几乎可忽略。</p><p>用法：</p><p><a href="https://cdn.jsdelivr.net/gh/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D@%E5%8F%91%E5%B8%83%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a><br>1<br>例如：</p><p><a href="https://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg">https://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg</a><br>1<br>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源。</p><p>还可以配合 PicGo图床上传工具的自定义域名前缀来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章: 使用Typora+iPic/PicGo图床+CDN实现高效Markdown创作</p><p>文章字数统计插件（可选的）<br>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><p>安装命令如下：</p><p>npm i –save hexo-wordcount<br>1<br>然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可：</p><p>wordCount:<br>  enable: false # 将这个值设置为 true 即可.<br>  postWordCount: true<br>  min2read: true<br>  totalCount: true<br>1<br>2<br>3<br>4<br>5<br>添加 RSS 订阅支持（可选的）<br>本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：</p><p>npm install hexo-generator-feed –save<br>1<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>feed:<br>  type: atom<br>  path: atom.xml<br>  limit: 20<br>  hub:<br>  content:<br>  content_limit: 140<br>  content_limit_delim: ‘ ‘<br>  order_by: -date<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明已经安装成功了。</p><p>自定制修改<br>在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分：</p><p>菜单<br>我的梦想<br>首页的音乐播放器和视频播放器配置<br>是否显示推荐文章名称和按钮配置<br>favicon 和 Logo<br>个人信息<br>TOC 目录<br>文章打赏信息<br>复制文章内容时追加版权信息<br>MathJax<br>文章字数统计、阅读时长<br>点击页面的’爱心’效果<br>我的项目<br>我的技能<br>我的相册<br>Gitalk、Gitment、Valine 和 disqus 评论配置<br>不蒜子统计和谷歌分析（Google Analytics）<br>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图<br>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><p>修改主题颜色<br>在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色：</p><p>/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */<br>.bg-color {<br>    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);<br>}</p><p>@-webkit-keyframes rainbow {<br>   /* 动态切换背景颜色. */<br>}</p><p>@keyframes rainbow {<br>    /* 动态切换背景颜色. */<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>修改 banner 图和文章特色图<br>可以直接在 /source/medias/banner 文件夹中更换喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果会 JavaScript 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 <script></script> 代码中：</p><p>$(‘.bg-cover’).css(‘background-image’, ‘url(/medias/banner/‘ + new Date().getDay() + ‘.jpg)’);<br>1<br>在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。</p><p>文章 Front-matter 介绍<br>Front-matter 选项详解<br>Front-matter 选项中的所有内容均为非必填的。但仍然建议至少填写 title 和 date 的值。</p><p>配置选项    默认值    描述<br>title    Markdown 的文件标题    文章标题，强烈建议填写此选项<br>date    文件创建时的日期时间    发布时间，强烈建议填写此选项，且最好保证全局唯一<br>author    根 _config.yml 中的 author    文章作者<br>img    featureImages 中的某个值    文章特征图<br>top    true    推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章<br>cover    false    表示该文章是否需要加入到首页轮播封面中<br>coverImg    无    表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片<br>password    无    文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项<br>toc    true    是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项<br>mathjax    false    是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行<br>summary    无    文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<br>categories    无    文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类<br>tags    无    文章标签，一篇文章可以多个标签<br>注意:</p><p>如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。<br>date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。<br>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供使用：开源中国在线工具、chahuo、站长工具。<br>以下为文章的 Front-matter 示例。</p><h2 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h2><p>title: 基于Hexo的hexo-theme-matery主题搭建博客并优化<br>date: 2019-10-03 14:25:00</p><hr><p>1<br>2<br>3<br>4<br>最全示例</p><hr><p>title: 基于Hexo的hexo-theme-matery主题搭建博客并优化<br>date: 2019-10-03 14:25:00<br>author: 悟尘<br>img: /source/images/xxx.jpg<br>top: true<br>cover: true<br>coverImg: /images/1.jpg<br>password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<br>toc: false<br>mathjax: false<br>summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<br>categories: 工具<br>tags:</p><ul><li>blog</li><li>hexo</li></ul><hr><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>SEO优化<br>搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（GitHub不允许百度的Spider爬取GitHub上的内容）。</p><p>百度优化<br>登录百度搜索资源平台， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击添加网站，按提示操作。</p><p>![](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjEzMzAyLnBuZy93MTI4MA?x-oss-process=image/format,png">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjEzMzAyLnBuZy93MTI4MA?x-oss-process=image/format,png</a> =50)</p><p>提示：由于百度的spider是爬取不到GitHub的内容的，所以在第三步验证网站的时候，建议选择CNAME验证的方式。</p><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。hexo-theme-matery主题已经内置了 自动推送 的方式， 检查 themes/hexo-theme-matery/_config.yml 文件中如下配置:</p><h1 id="百度搜索资源平台提交链接"><a href="#百度搜索资源平台提交链接" class="headerlink" title="百度搜索资源平台提交链接"></a>百度搜索资源平台提交链接</h1><p>baiduPush: true<br>1<br>2<br>自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。</p><p>谷歌优化<br>登录 Google Search Console，点击添加资源，输入自己的域名，按提示操作。</p><p>提示：需要进行DNS验证，进入DNS域名解析设置页面，按提示增加TXT记录，如下图:</p><p>验证成功后，需要提交站点地图。通过安装sitemap插件生成站点地图文件:</p><p>npm install hexo-generator-sitemap –save<br>npm install hexo-generator-baidu-sitemap –save  #百度专用，可选<br>1<br>2<br>安装后直接执行 hexo cl&amp;&amp;hexo g -d 命令，就会在网站根目录生成 sitemap.xml 文件。参照下图提交，等待收录。</p><p>注意：hexo配置文件中的url一定要输入正确的域名，插件是根据url生成站点地图的。</p><p>常用命令<br>指令说明<br>hexo server #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p>hexo server -s #以静态模式启动</p><p>hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)</p><p>hexo server -i IP地址 #自定义 IP</p><p>hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p><p>hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)</p><p>hexo d #自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)</p><p>hexo init 文件夹名称 #初始化XX文件夹名称</p><p>npm update hexo -g#升级</p><p>npm install hexo -g #安装</p><p>node-v #查看node.js版本号</p><p>npm -v #查看npm版本号</p><p>git –version #查看git版本号</p><p>hexo -v #查看hexo版本号</p><p>简写指令<br>hexo n “我的第一篇文章” 等价于 hexo new “我的第一篇文章” 还等价于 hexo new post “我的第一篇文章”</p><p>hexo p 等价于 hexo publish</p><p>hexo g 等价于 hexo generate</p><p>hexo s等价于 hexo server</p><p>hexo d 等价于 hexo deploy</p><p>hexo g -d等价于hexo generate –deploy</p><p>注: hexo clean 没有 简写, git –version 没有简写</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用github搭建静态网站</title>
    <link href="/2021/01/02/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    <url>/2021/01/02/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>1.nodejs，Git环境搭建：nodejs搭建教程:注意了，像Git这种服务器在国外的东西，它的官网下载这个软件会非常慢，建议直接在百度上搜索git下载与安装，各种软件园都能直接快速下载，留一下版本最好不要太旧就行。git搭建教程：补充参考文档（可能你会用到）：配置淘宝云<br>2.注册GitHub账号并创建仓库1. 注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度的，太简单了）2. 格式要求：xxx.github.io<br>3. 下面两个东西选其一我在里面没有演示，因为我早已经弄好了，你们看着弄。<br>4. 参考文档（可能用到）——GitHub的ssh密匙添加：<br>5. 参考文档（可能用到）——Gitee的ssh密匙添加：<br>3.快速利用hexo搭建博客：1. 脚本教程2. matery主题安装及优化matery主题官网：博客搭建完成我的博客工具自行下载vs code</p><p>另外检测 node hoxe 代码奉上<br>source install.sh test_node<br>如果出现了如图的情况证明环境变量是配置成功的<br>(出现了版本号和成功的提示信息代表配置成功)<br>source install.sh test_git<br> 一般情况下安装git工具后git环境是会自动配置的,可以无需检测git环境.此脚本可以用于linux系统,出现版本号信息则配置为成功.<br>source install.sh hexo_win<br> 提示:此时你可以去来一杯卡布奇诺,大约两分钟的时间,博客即可自动安装完成,如图:<br> 当您看到出现<code>Please run hexo s to check it out!</code>的提示,证明您已经安装成功,此时你可以运行hexo s 然后查看你的博客<br> cd hexoblog<br>hexo s<br>注意:要先cd到hexoblog目录哦!执行以上命令即可<br>可以看到出现了一段地址:<a href="http://localhost:4000/">http://localhost:4000</a><br>在浏览器访问:<a href="http://localhost:4000/">http://localhost:4000</a> ,你就可以在本地预览了<br>一键生成SSH秘钥<br>部署hexo博客的必要之物<br>git_ssh的使用<br>您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><p>./install.sh git_ssh<br>可以看到会有四条可执行命令,输入对应数字可以执行对应的命令<br>1)Key<br>2)SSH<br>3)Verify-github<br>4)Verify-coding<br>1)Key 执行1后可以一键生成秘钥<br>如果你的电脑已经存在秘钥,程序将会自动退出<br>2)SSH 执行2后可以查看你电脑中已生成的秘钥]<br>3)Verify-github 执行3后可以检查秘钥是否配置github成功<br>4)Verify-coding 执行4后可以检查秘钥是否配置coding成功<br>生成秘钥后别忘记将秘钥添加到账号里,否则秘钥不会配置成功</p><p>最后配置及部署<br>deploy:<br>  type: git<br>  repo: 这里填你的仓库地址,建议使用SSH地址,它是以git开头的<br>  branch: master<br>在1.3版本的[heox-script]后你无需自己安装上传插件,但如果报出了not found git的错误证明上传插件没有安装成功,你需要执行以下命令<br>cnpm install hexo-deployer-git –save<br>或者是npm install hexo-deployer-git –save<br>hexo g<br>就可以看到您的博客了最后关于博客主题问题<br>我会斟酌以后出一个优化教程<br>seaQQ：2021672898</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>����github���̬��վ</title>
    <link href="/2021/01/02/%E5%85%B3%E4%BA%8E%E7%88%B1%E4%B8%80%E4%B8%AA%E4%BA%BA/"/>
    <url>/2021/01/02/%E5%85%B3%E4%BA%8E%E7%88%B1%E4%B8%80%E4%B8%AA%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p>��ȷʵ����Ҫ��ȥѧϰ�ģ�������������Ǽ���ʹ��ġ��ܶ�������Զѧ����ģ���Ϊ��ֻ������һ���������úܳ�����Ȼ��һ����������̣����������Լ��ܲ�������ࡣ</p><p>��Ҫѧ�ᰮ���ͱ���֪������ʲô�������������ҪѧӢ�ѧ����ѧС����һ���ģ����Ƕ�֪����Щ����ʲô���ӣ�ѧ������һ��ʲô���ĸ��</p><p>���ǰ����������������˵�����̫��������ˣ����һ���˲���֪������ʲô���������԰���������ȫ�������壬��ô����ν�İ����ˣ���νѧϰ��ô����Ҳ���Ǵ��ű��������ġ�</p><p>������Ҫѧ��ȥ������ô����Ҫ������Ϊ��׼��Ȼ���ð��ı�׼ȥ�������ǵ������ֹ��˼ά��ʽ��������Щ��Ϊ��˼ά���ǰ�Ӧ���еı��֣����Ǿ���Ҫȥ˼�������������Ҫ��Ҫ���������뷨Ҫ��Ҫ���ڡ�</p><p>����������У����ǻ������ܶ��ʹ������飬��ǡǡ�������������ѵ�ĥ���£����Ƕ�û�ж�ҡ�����ᶨ���԰��ı�׼Ҫ�����Լ������ǲſ���ѧ�ᰮ��</p><p>����һ����������һ��죬����Ҫͨ������˼����ѧϰ�Ķ�������ʵ˵������ĺܼ򵥣���������ѧ��Ӿ��ѧ����һ������������Ҫ����սʤ�Լ���һֱ����һ��Ŀ�겻����ǰ�����ܿ˷����Ѻ�����Ĺ��̡�</p><p>����Ȼ��һ�����������벻�������ǿ����Լ����ҿ��ģ����밮�㣬�Ҳ����ģ��Ҳ��밮�㣬��Ư���Ұ��㣬�㲻Ư����Ҳ���԰��㡣�Ҷ�֪����һ˵���㲻Ư����Ҳ���԰��㣬���Ͼͻ������룺�⻰���Ƿ�ƨ��</p><p>�ҿ���ȥ��һ����Ư����Ů�ˣ��ҿ��ܲ��������һ��Ҫ���ף�Ҫ��������Ϊ�Ҳ�ϲ��������Ϊ�Ҷ������ҿ��԰�������Ҳ���Լ���</p>]]></content>
    
    
    
    <tags>
      
      <tag>��</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/20/hello-world/"/>
    <url>/2020/12/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
